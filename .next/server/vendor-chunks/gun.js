/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gun";
exports.ids = ["vendor-chunks/gun"];
exports.modules = {

/***/ "(ssr)/./node_modules/gun/axe.js":
/*!*********************************!*\
  !*** ./node_modules/gun/axe.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(";(function(){\n\n\tvar sT = setTimeout || {}, u;\n  if(typeof window !== ''+u){ sT.window = window }\n\tvar AXE = (sT.window||'').AXE || function(){};\n  if(AXE.window = sT.window){ AXE.window.AXE = AXE }\n\n\tvar Gun = (AXE.window||'').GUN || __webpack_require__(/*! ./gun */ \"(ssr)/./node_modules/gun/gun.js\");\n\t(Gun.AXE = AXE).GUN = AXE.Gun = Gun;\n\n  //if(!Gun.window){ try{ require('./lib/axe') }catch(e){} }\n  if(!Gun.window){ __webpack_require__(/*! ./lib/axe */ \"(ssr)/./node_modules/gun/lib/axe.js\") }\n\n\tGun.on('opt', function(at){ start(at) ; this.to.next(at) }); // make sure to call the \"next\" middleware adapter.\n\n\tfunction start(root){\n\t\tif(root.axe){ return }\n\t\tvar opt = root.opt, peers = opt.peers;\n\t\tif(false === opt.axe){ return }\n\t\tif(!Gun.window){ return } // handled by ^ lib/axe.js\n\t\tvar w = Gun.window, lS = w.localStorage || opt.localStorage || {}, loc = w.location || opt.location || {}, nav = w.navigator || opt.navigator || {};\n\t\tvar axe = root.axe = {}, tmp, id;\n\t\tvar mesh = opt.mesh = opt.mesh || Gun.Mesh(root); // DAM!\n\n\t\ttmp = peers[id = loc.origin + '/gun'] = peers[id] || {};\n\t\ttmp.id = tmp.url = id; tmp.retry = tmp.retry || 0;\n\t\ttmp = peers[id = 'http://localhost:8765/gun'] = peers[id] || {};\n\t\ttmp.id = tmp.url = id; tmp.retry = tmp.retry || 0;\n\t\tGun.log.once(\"AXE\", \"AXE enabled: Trying to find network via (1) local peer (2) last used peers (3) a URL parameter, and last (4) hard coded peers.\");\n\t\tGun.log.once(\"AXEWarn\", \"Warning: AXE is in alpha, use only for testing!\");\n\t\tvar last = lS.peers || ''; if(last){ last += ' ' }\n\t\tlast += ((loc.search||'').split('peers=')[1]||'').split('&')[0];\n\n\t\troot.on('bye', function(peer){\n\t\t\tthis.to.next(peer);\n\t\t\tif(!peer.url){ return } // ignore WebRTC disconnects for now.\n\t\t\tif(!nav.onLine){ peer.retry = 1 }\n\t\t\tif(peer.retry){ return }\n\t\t\tif(axe.fall){ delete axe.fall[peer.url || peer.id] }\n\t\t\t(function next(){\n\t\t\t\tif(!axe.fall){ setTimeout(next, 9); return } // not found yet\n\t\t\t\tvar fall = Object.keys(axe.fall||''), one = fall[(Math.random()*fall.length) >> 0];\n\t\t\t\tif(!fall.length){ lS.peers = ''; one = 'https://gunjs.herokuapp.com/gun' } // out of peers\n\t\t\t\tif(peers[one]){ next(); return } // already choose\n\t\t\t\tmesh.hi(one);\n\t\t\t}());\n\t\t});\n\n\t\troot.on('hi', function(peer){ // TEMPORARY! Try to connect all peers.\n\t\t\tthis.to.next(peer);\n\t\t\tif(!peer.url){ return } // ignore WebRTC disconnects for now.\n\t\t\treturn; // DO NOT COMMIT THIS FEATURE YET! KEEP TESTING NETWORK PERFORMANCE FIRST!\n\t\t\t(function next(){\n\t\t\t\tif(!peer.wire){ return }\n\t\t\t\tif(!axe.fall){ setTimeout(next, 9); return } // not found yet\n\t\t\t\tvar one = (next.fall = next.fall || Object.keys(axe.fall||'')).pop();\n\t\t\t\tif(!one){ return }\n\t\t\t\tsetTimeout(next, 99);\n\t\t\t\tmesh.say({dam: 'opt', opt: {peers: one}}, peer);\n\t\t\t}());\n\t\t});\n\n\t\tfunction found(text){\n\n\t\t\taxe.fall = {};\n\t\t\t((text||'').match(/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/ig)||[]).forEach(function(url){\n\t\t\t\taxe.fall[url] = {url: url, id: url, retry: 0}; // RETRY\n\t\t\t});\n\t\t\t\n\t\t\treturn;\n\n\t\t\t// TODO: Finish porting below? Maybe not.\n\n\t\t\tObject.keys(last.peers||'').forEach(function(key){\n\t\t\t\ttmp = peers[id = key] = peers[id] || {};\n\t\t\t\ttmp.id = tmp.url = id;\n\t\t\t});\n\t\t\ttmp = peers[id = 'https://guntest.herokuapp.com/gun'] = peers[id] || {};\n\t\t\ttmp.id = tmp.url = id;\n\n\t\t\tvar mesh = opt.mesh = opt.mesh || Gun.Mesh(root); // DAM!\n\t\t\tmesh.way = function(msg){\n\t\t\t\tif(root.$ === msg.$ || (msg._||'').via){\n\t\t\t\t\tmesh.say(msg, opt.peers);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar at = (msg.$||'')._;\n\t\t\t\tif(!at){ mesh.say(msg, opt.peers); return }\n\t\t\t\tif(msg.get){\n\t\t\t\t\tif(at.axe){ return } // don't ask for it again!\n\t\t\t\t\tat.axe = {};\n\t\t\t\t}\n\t\t\t\tmesh.say(msg, opt.peers);\n\t\t\t}\n\t\t}\n\n\t\tif(last){ found(last); return }\n\t\ttry{ fetch(((loc.search||'').split('axe=')[1]||'').split('&')[0] || loc.axe || 'https://raw.githubusercontent.com/wiki/amark/gun/volunteer.dht.md').then(function(res){\n\t  \treturn res.text()\n\t  }).then(function(text){\n\t  \tfound(lS.peers = text);\n\t  }).catch(function(){\n\t  \tfound(); // nothing\n\t  })}catch(e){found()}\n\t}\n\n\tvar empty = {}, yes = true;\n  try{ if(\"object\" != ''+u){ module.exports = AXE } }catch(e){}\n}());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2F4ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxDQUFDOztBQUVELDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7O0FBRTlCLG1DQUFtQyxtQkFBTyxDQUFDLDhDQUFPO0FBQ2xEOztBQUVBLHFCQUFxQixLQUFLLHNCQUFzQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyxzREFBVzs7QUFFdEMsNkJBQTZCLFlBQVksa0JBQWtCLEdBQUc7O0FBRTlEO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EseUJBQXlCO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCLG1FQUFtRSx3Q0FBd0M7QUFDM0cseUJBQXlCO0FBQ3pCLG9EQUFvRDs7QUFFcEQ7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBLG1CQUFtQixxQkFBcUIsU0FBUztBQUNqRDtBQUNBLHNCQUFzQixlQUFlLDBDQUEwQztBQUMvRSxvQkFBb0IsUUFBUSxTQUFTO0FBQ3JDO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUgsZ0NBQWdDO0FBQ2hDO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0IsV0FBVztBQUNYO0FBQ0Esb0JBQW9CO0FBQ3BCLG1CQUFtQixxQkFBcUIsU0FBUztBQUNqRDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWMsa0JBQWtCLFlBQVk7QUFDNUMsSUFBSTtBQUNKLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSxnRUFBZ0UsTUFBTSxnQkFBZ0IsSUFBSTtBQUMxRixxQkFBcUIsOEJBQThCO0FBQ25ELElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxhQUFhO0FBQ3pCLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixhQUFhO0FBQ2IsSUFBSSxFQUFFLFNBQVM7QUFDZjs7QUFFQSxlQUFlO0FBQ2YsT0FBTyxHQUFHLFFBQWEsV0FBVyx3QkFBd0I7QUFDMUQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjMtY2hhdC8uL25vZGVfbW9kdWxlcy9ndW4vYXhlLmpzP2NiYzEiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpe1xuXG5cdHZhciBzVCA9IHNldFRpbWVvdXQgfHwge30sIHU7XG4gIGlmKHR5cGVvZiB3aW5kb3cgIT09ICcnK3UpeyBzVC53aW5kb3cgPSB3aW5kb3cgfVxuXHR2YXIgQVhFID0gKHNULndpbmRvd3x8JycpLkFYRSB8fCBmdW5jdGlvbigpe307XG4gIGlmKEFYRS53aW5kb3cgPSBzVC53aW5kb3cpeyBBWEUud2luZG93LkFYRSA9IEFYRSB9XG5cblx0dmFyIEd1biA9IChBWEUud2luZG93fHwnJykuR1VOIHx8IHJlcXVpcmUoJy4vZ3VuJyk7XG5cdChHdW4uQVhFID0gQVhFKS5HVU4gPSBBWEUuR3VuID0gR3VuO1xuXG4gIC8vaWYoIUd1bi53aW5kb3cpeyB0cnl7IHJlcXVpcmUoJy4vbGliL2F4ZScpIH1jYXRjaChlKXt9IH1cbiAgaWYoIUd1bi53aW5kb3cpeyByZXF1aXJlKCcuL2xpYi9heGUnKSB9XG5cblx0R3VuLm9uKCdvcHQnLCBmdW5jdGlvbihhdCl7IHN0YXJ0KGF0KSA7IHRoaXMudG8ubmV4dChhdCkgfSk7IC8vIG1ha2Ugc3VyZSB0byBjYWxsIHRoZSBcIm5leHRcIiBtaWRkbGV3YXJlIGFkYXB0ZXIuXG5cblx0ZnVuY3Rpb24gc3RhcnQocm9vdCl7XG5cdFx0aWYocm9vdC5heGUpeyByZXR1cm4gfVxuXHRcdHZhciBvcHQgPSByb290Lm9wdCwgcGVlcnMgPSBvcHQucGVlcnM7XG5cdFx0aWYoZmFsc2UgPT09IG9wdC5heGUpeyByZXR1cm4gfVxuXHRcdGlmKCFHdW4ud2luZG93KXsgcmV0dXJuIH0gLy8gaGFuZGxlZCBieSBeIGxpYi9heGUuanNcblx0XHR2YXIgdyA9IEd1bi53aW5kb3csIGxTID0gdy5sb2NhbFN0b3JhZ2UgfHwgb3B0LmxvY2FsU3RvcmFnZSB8fCB7fSwgbG9jID0gdy5sb2NhdGlvbiB8fCBvcHQubG9jYXRpb24gfHwge30sIG5hdiA9IHcubmF2aWdhdG9yIHx8IG9wdC5uYXZpZ2F0b3IgfHwge307XG5cdFx0dmFyIGF4ZSA9IHJvb3QuYXhlID0ge30sIHRtcCwgaWQ7XG5cdFx0dmFyIG1lc2ggPSBvcHQubWVzaCA9IG9wdC5tZXNoIHx8IEd1bi5NZXNoKHJvb3QpOyAvLyBEQU0hXG5cblx0XHR0bXAgPSBwZWVyc1tpZCA9IGxvYy5vcmlnaW4gKyAnL2d1biddID0gcGVlcnNbaWRdIHx8IHt9O1xuXHRcdHRtcC5pZCA9IHRtcC51cmwgPSBpZDsgdG1wLnJldHJ5ID0gdG1wLnJldHJ5IHx8IDA7XG5cdFx0dG1wID0gcGVlcnNbaWQgPSAnaHR0cDovL2xvY2FsaG9zdDo4NzY1L2d1biddID0gcGVlcnNbaWRdIHx8IHt9O1xuXHRcdHRtcC5pZCA9IHRtcC51cmwgPSBpZDsgdG1wLnJldHJ5ID0gdG1wLnJldHJ5IHx8IDA7XG5cdFx0R3VuLmxvZy5vbmNlKFwiQVhFXCIsIFwiQVhFIGVuYWJsZWQ6IFRyeWluZyB0byBmaW5kIG5ldHdvcmsgdmlhICgxKSBsb2NhbCBwZWVyICgyKSBsYXN0IHVzZWQgcGVlcnMgKDMpIGEgVVJMIHBhcmFtZXRlciwgYW5kIGxhc3QgKDQpIGhhcmQgY29kZWQgcGVlcnMuXCIpO1xuXHRcdEd1bi5sb2cub25jZShcIkFYRVdhcm5cIiwgXCJXYXJuaW5nOiBBWEUgaXMgaW4gYWxwaGEsIHVzZSBvbmx5IGZvciB0ZXN0aW5nIVwiKTtcblx0XHR2YXIgbGFzdCA9IGxTLnBlZXJzIHx8ICcnOyBpZihsYXN0KXsgbGFzdCArPSAnICcgfVxuXHRcdGxhc3QgKz0gKChsb2Muc2VhcmNofHwnJykuc3BsaXQoJ3BlZXJzPScpWzFdfHwnJykuc3BsaXQoJyYnKVswXTtcblxuXHRcdHJvb3Qub24oJ2J5ZScsIGZ1bmN0aW9uKHBlZXIpe1xuXHRcdFx0dGhpcy50by5uZXh0KHBlZXIpO1xuXHRcdFx0aWYoIXBlZXIudXJsKXsgcmV0dXJuIH0gLy8gaWdub3JlIFdlYlJUQyBkaXNjb25uZWN0cyBmb3Igbm93LlxuXHRcdFx0aWYoIW5hdi5vbkxpbmUpeyBwZWVyLnJldHJ5ID0gMSB9XG5cdFx0XHRpZihwZWVyLnJldHJ5KXsgcmV0dXJuIH1cblx0XHRcdGlmKGF4ZS5mYWxsKXsgZGVsZXRlIGF4ZS5mYWxsW3BlZXIudXJsIHx8IHBlZXIuaWRdIH1cblx0XHRcdChmdW5jdGlvbiBuZXh0KCl7XG5cdFx0XHRcdGlmKCFheGUuZmFsbCl7IHNldFRpbWVvdXQobmV4dCwgOSk7IHJldHVybiB9IC8vIG5vdCBmb3VuZCB5ZXRcblx0XHRcdFx0dmFyIGZhbGwgPSBPYmplY3Qua2V5cyhheGUuZmFsbHx8JycpLCBvbmUgPSBmYWxsWyhNYXRoLnJhbmRvbSgpKmZhbGwubGVuZ3RoKSA+PiAwXTtcblx0XHRcdFx0aWYoIWZhbGwubGVuZ3RoKXsgbFMucGVlcnMgPSAnJzsgb25lID0gJ2h0dHBzOi8vZ3VuanMuaGVyb2t1YXBwLmNvbS9ndW4nIH0gLy8gb3V0IG9mIHBlZXJzXG5cdFx0XHRcdGlmKHBlZXJzW29uZV0peyBuZXh0KCk7IHJldHVybiB9IC8vIGFscmVhZHkgY2hvb3NlXG5cdFx0XHRcdG1lc2guaGkob25lKTtcblx0XHRcdH0oKSk7XG5cdFx0fSk7XG5cblx0XHRyb290Lm9uKCdoaScsIGZ1bmN0aW9uKHBlZXIpeyAvLyBURU1QT1JBUlkhIFRyeSB0byBjb25uZWN0IGFsbCBwZWVycy5cblx0XHRcdHRoaXMudG8ubmV4dChwZWVyKTtcblx0XHRcdGlmKCFwZWVyLnVybCl7IHJldHVybiB9IC8vIGlnbm9yZSBXZWJSVEMgZGlzY29ubmVjdHMgZm9yIG5vdy5cblx0XHRcdHJldHVybjsgLy8gRE8gTk9UIENPTU1JVCBUSElTIEZFQVRVUkUgWUVUISBLRUVQIFRFU1RJTkcgTkVUV09SSyBQRVJGT1JNQU5DRSBGSVJTVCFcblx0XHRcdChmdW5jdGlvbiBuZXh0KCl7XG5cdFx0XHRcdGlmKCFwZWVyLndpcmUpeyByZXR1cm4gfVxuXHRcdFx0XHRpZighYXhlLmZhbGwpeyBzZXRUaW1lb3V0KG5leHQsIDkpOyByZXR1cm4gfSAvLyBub3QgZm91bmQgeWV0XG5cdFx0XHRcdHZhciBvbmUgPSAobmV4dC5mYWxsID0gbmV4dC5mYWxsIHx8IE9iamVjdC5rZXlzKGF4ZS5mYWxsfHwnJykpLnBvcCgpO1xuXHRcdFx0XHRpZighb25lKXsgcmV0dXJuIH1cblx0XHRcdFx0c2V0VGltZW91dChuZXh0LCA5OSk7XG5cdFx0XHRcdG1lc2guc2F5KHtkYW06ICdvcHQnLCBvcHQ6IHtwZWVyczogb25lfX0sIHBlZXIpO1xuXHRcdFx0fSgpKTtcblx0XHR9KTtcblxuXHRcdGZ1bmN0aW9uIGZvdW5kKHRleHQpe1xuXG5cdFx0XHRheGUuZmFsbCA9IHt9O1xuXHRcdFx0KCh0ZXh0fHwnJykubWF0Y2goL2h0dHBzPzpcXC9cXC8od3d3XFwuKT9bLWEtekEtWjAtOUA6JS5fXFwrfiM9XXsxLDI1Nn1cXC5bYS16QS1aMC05KCldezEsNn1cXGIoWy1hLXpBLVowLTkoKUA6JV9cXCsufiM/Ji8vPV0qKS9pZyl8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHVybCl7XG5cdFx0XHRcdGF4ZS5mYWxsW3VybF0gPSB7dXJsOiB1cmwsIGlkOiB1cmwsIHJldHJ5OiAwfTsgLy8gUkVUUllcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIFRPRE86IEZpbmlzaCBwb3J0aW5nIGJlbG93PyBNYXliZSBub3QuXG5cblx0XHRcdE9iamVjdC5rZXlzKGxhc3QucGVlcnN8fCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG5cdFx0XHRcdHRtcCA9IHBlZXJzW2lkID0ga2V5XSA9IHBlZXJzW2lkXSB8fCB7fTtcblx0XHRcdFx0dG1wLmlkID0gdG1wLnVybCA9IGlkO1xuXHRcdFx0fSk7XG5cdFx0XHR0bXAgPSBwZWVyc1tpZCA9ICdodHRwczovL2d1bnRlc3QuaGVyb2t1YXBwLmNvbS9ndW4nXSA9IHBlZXJzW2lkXSB8fCB7fTtcblx0XHRcdHRtcC5pZCA9IHRtcC51cmwgPSBpZDtcblxuXHRcdFx0dmFyIG1lc2ggPSBvcHQubWVzaCA9IG9wdC5tZXNoIHx8IEd1bi5NZXNoKHJvb3QpOyAvLyBEQU0hXG5cdFx0XHRtZXNoLndheSA9IGZ1bmN0aW9uKG1zZyl7XG5cdFx0XHRcdGlmKHJvb3QuJCA9PT0gbXNnLiQgfHwgKG1zZy5ffHwnJykudmlhKXtcblx0XHRcdFx0XHRtZXNoLnNheShtc2csIG9wdC5wZWVycyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBhdCA9IChtc2cuJHx8JycpLl87XG5cdFx0XHRcdGlmKCFhdCl7IG1lc2guc2F5KG1zZywgb3B0LnBlZXJzKTsgcmV0dXJuIH1cblx0XHRcdFx0aWYobXNnLmdldCl7XG5cdFx0XHRcdFx0aWYoYXQuYXhlKXsgcmV0dXJuIH0gLy8gZG9uJ3QgYXNrIGZvciBpdCBhZ2FpbiFcblx0XHRcdFx0XHRhdC5heGUgPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZXNoLnNheShtc2csIG9wdC5wZWVycyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYobGFzdCl7IGZvdW5kKGxhc3QpOyByZXR1cm4gfVxuXHRcdHRyeXsgZmV0Y2goKChsb2Muc2VhcmNofHwnJykuc3BsaXQoJ2F4ZT0nKVsxXXx8JycpLnNwbGl0KCcmJylbMF0gfHwgbG9jLmF4ZSB8fCAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dpa2kvYW1hcmsvZ3VuL3ZvbHVudGVlci5kaHQubWQnKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG5cdCAgXHRyZXR1cm4gcmVzLnRleHQoKVxuXHQgIH0pLnRoZW4oZnVuY3Rpb24odGV4dCl7XG5cdCAgXHRmb3VuZChsUy5wZWVycyA9IHRleHQpO1xuXHQgIH0pLmNhdGNoKGZ1bmN0aW9uKCl7XG5cdCAgXHRmb3VuZCgpOyAvLyBub3RoaW5nXG5cdCAgfSl9Y2F0Y2goZSl7Zm91bmQoKX1cblx0fVxuXG5cdHZhciBlbXB0eSA9IHt9LCB5ZXMgPSB0cnVlO1xuICB0cnl7IGlmKHR5cGVvZiBtb2R1bGUgIT0gJycrdSl7IG1vZHVsZS5leHBvcnRzID0gQVhFIH0gfWNhdGNoKGUpe31cbn0oKSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/axe.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/gun.js":
/*!*********************************!*\
  !*** ./node_modules/gun/gun.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n;(function(){\n\n  /* UNBUILD */\n  function USE(arg, req){\n    return req? __webpack_require__(\"(ssr)/./node_modules/gun sync recursive\")(arg) : arg.slice? USE[R(arg)] : function(mod, path){\n      arg(mod = {exports: {}});\n      USE[R(path)] = mod.exports;\n    }\n    function R(p){\n      return p.split('/').slice(-1).toString().replace('.js','');\n    }\n  }\n  if(true){ var MODULE = module }\n  /* UNBUILD */\n\n\t;USE(function(module){\n\t\t// Shim for generic javascript utilities.\n\t\tString.random = function(l, c){\n\t\t\tvar s = '';\n\t\t\tl = l || 24; // you are not going to make a 0 length random number, so no need to check type\n\t\t\tc = c || '0123456789ABCDEFGHIJKLMNOPQRSTUVWXZabcdefghijklmnopqrstuvwxyz';\n\t\t\twhile(l-- > 0){ s += c.charAt(Math.floor(Math.random() * c.length)) }\n\t\t\treturn s;\n\t\t}\n\t\tString.match = function(t, o){ var tmp, u;\n\t\t\tif('string' !== typeof t){ return false }\n\t\t\tif('string' == typeof o){ o = {'=': o} }\n\t\t\to = o || {};\n\t\t\ttmp = (o['='] || o['*'] || o['>'] || o['<']);\n\t\t\tif(t === tmp){ return true }\n\t\t\tif(u !== o['=']){ return false }\n\t\t\ttmp = (o['*'] || o['>']);\n\t\t\tif(t.slice(0, (tmp||'').length) === tmp){ return true }\n\t\t\tif(u !== o['*']){ return false }\n\t\t\tif(u !== o['>'] && u !== o['<']){\n\t\t\t\treturn (t >= o['>'] && t <= o['<'])? true : false;\n\t\t\t}\n\t\t\tif(u !== o['>'] && t >= o['>']){ return true }\n\t\t\tif(u !== o['<'] && t <= o['<']){ return true }\n\t\t\treturn false;\n\t\t}\n\t\tString.hash = function(s, c){ // via SO\n\t\t\tif(typeof s !== 'string'){ return }\n\t    c = c || 0; // CPU schedule hashing by\n\t    if(!s.length){ return c }\n\t    for(var i=0,l=s.length,n; i<l; ++i){\n\t      n = s.charCodeAt(i);\n\t      c = ((c<<5)-c)+n;\n\t      c |= 0;\n\t    }\n\t    return c;\n\t  }\n\t\tvar has = Object.prototype.hasOwnProperty;\n\t\tObject.plain = function(o){ return o? (o instanceof Object && o.constructor === Object) || Object.prototype.toString.call(o).match(/^\\[object (\\w+)\\]$/)[1] === 'Object' : false }\n\t\tObject.empty = function(o, n){\n\t\t\tfor(var k in o){ if(has.call(o, k) && (!n || -1==n.indexOf(k))){ return false } }\n\t\t\treturn true;\n\t\t}\n\t\tObject.keys = Object.keys || function(o){\n\t\t\tvar l = [];\n\t\t\tfor(var k in o){ if(has.call(o, k)){ l.push(k) } }\n\t\t\treturn l;\n\t\t}\n\t\t;(function(){\n\t\t\tvar u, sT = setTimeout, l = 0, c = 0\n\t\t\t, sI = (typeof setImmediate !== ''+u && setImmediate) || (function(c,f){\n\t\t\t\tif(typeof MessageChannel == ''+u){ return sT }\n\t\t\t\t(c = new MessageChannel()).port1.onmessage = function(e){ ''==e.data && f() }\n\t\t\t\treturn function(q){ f=q;c.port2.postMessage('') }\n\t\t\t}()), check = sT.check = sT.check || (typeof performance !== ''+u && performance)\n\t\t\t|| {now: function(){ return +new Date }};\n\t\t\tsT.hold = sT.hold || 9; // half a frame benchmarks faster than < 1ms?\n\t\t\tsT.poll = sT.poll || function(f){\n\t\t\t\tif((sT.hold >= (check.now() - l)) && c++ < 3333){ f(); return }\n\t\t\t\tsI(function(){ l = check.now(); f() },c=0)\n\t\t\t}\n\t\t}());\n\t\t;(function(){ // Too many polls block, this \"threads\" them in turns over a single thread in time.\n\t\t\tvar sT = setTimeout, t = sT.turn = sT.turn || function(f){ 1 == s.push(f) && p(T) }\n\t\t\t, s = t.s = [], p = sT.poll, i = 0, f, T = function(){\n\t\t\t\tif(f = s[i++]){ f() }\n\t\t\t\tif(i == s.length || 99 == i){\n\t\t\t\t\ts = t.s = s.slice(i);\n\t\t\t\t\ti = 0;\n\t\t\t\t}\n\t\t\t\tif(s.length){ p(T) }\n\t\t\t}\n\t\t}());\n\t\t;(function(){\n\t\t\tvar u, sT = setTimeout, T = sT.turn;\n\t\t\t(sT.each = sT.each || function(l,f,e,S){ S = S || 9; (function t(s,L,r){\n\t\t\t  if(L = (s = (l||[]).splice(0,S)).length){\n\t\t\t  \tfor(var i = 0; i < L; i++){\n\t\t\t  \t\tif(u !== (r = f(s[i]))){ break }\n\t\t\t  \t}\n\t\t\t  \tif(u === r){ T(t); return }\n\t\t\t  } e && e(r);\n\t\t\t}())})();\n\t\t}());\n\t})(USE, './shim');\n\n\t;USE(function(module){\n\t\t// On event emitter generic javascript utility.\n\t\tmodule.exports = function onto(tag, arg, as){\n\t\t\tif(!tag){ return {to: onto} }\n\t\t\tvar u, f = 'function' == typeof arg, tag = (this.tag || (this.tag = {}))[tag] || f && (\n\t\t\t\tthis.tag[tag] = {tag: tag, to: onto._ = { next: function(arg){ var tmp;\n\t\t\t\t\tif(tmp = this.to){ tmp.next(arg) }\n\t\t\t}}});\n\t\t\tif(f){\n\t\t\t\tvar be = {\n\t\t\t\t\toff: onto.off ||\n\t\t\t\t\t(onto.off = function(){\n\t\t\t\t\t\tif(this.next === onto._.next){ return !0 }\n\t\t\t\t\t\tif(this === this.the.last){\n\t\t\t\t\t\t\tthis.the.last = this.back;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.to.back = this.back;\n\t\t\t\t\t\tthis.next = onto._.next;\n\t\t\t\t\t\tthis.back.to = this.to;\n\t\t\t\t\t\tif(this.the.last === this.the){\n\t\t\t\t\t\t\tdelete this.on.tag[this.the.tag];\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t\tto: onto._,\n\t\t\t\t\tnext: arg,\n\t\t\t\t\tthe: tag,\n\t\t\t\t\ton: this,\n\t\t\t\t\tas: as,\n\t\t\t\t};\n\t\t\t\t(be.back = tag.last || tag).to = be;\n\t\t\t\treturn tag.last = be;\n\t\t\t}\n\t\t\tif((tag = tag.to) && u !== arg){ tag.next(arg) }\n\t\t\treturn tag;\n\t\t};\n\t})(USE, './onto');\n\n\t;USE(function(module){\n\t\t// Valid values are a subset of JSON: null, binary, number (!Infinity), text,\n\t\t// or a soul relation. Arrays need special algorithms to handle concurrency,\n\t\t// so they are not supported directly. Use an extension that supports them if\n\t\t// needed but research their problems first.\n\t\tmodule.exports = function (v) {\n\t\t  // \"deletes\", nulling out keys.\n\t\t  return v === null ||\n\t\t\t\"string\" === typeof v ||\n\t\t\t\"boolean\" === typeof v ||\n\t\t\t// we want +/- Infinity to be, but JSON does not support it, sad face.\n\t\t\t// can you guess what v === v checks for? ;)\n\t\t\t(\"number\" === typeof v && v != Infinity && v != -Infinity && v === v) ||\n\t\t\t(!!v && \"string\" == typeof v[\"#\"] && Object.keys(v).length === 1 && v[\"#\"]);\n\t\t}\n\t})(USE, './valid');\n\n\t;USE(function(module){\n\t\tUSE('./shim');\n\t\tfunction State(){\n\t\t\tvar t = +new Date;\n\t\t\tif(last < t){\n\t\t\t\treturn N = 0, last = t + State.drift;\n\t\t\t}\n\t\t\treturn last = t + ((N += 1) / D) + State.drift;\n\t\t}\n\t\tState.drift = 0;\n\t\tvar NI = -Infinity, N = 0, D = 999, last = NI, u; // WARNING! In the future, on machines that are D times faster than 2016AD machines, you will want to increase D by another several orders of magnitude so the processing speed never out paces the decimal resolution (increasing an integer effects the state accuracy).\n\t\tState.is = function(n, k, o){ // convenience function to get the state on a key on a node and return it.\n\t\t\tvar tmp = (k && n && n._ && n._['>']) || o;\n\t\t\tif(!tmp){ return }\n\t\t\treturn ('number' == typeof (tmp = tmp[k]))? tmp : NI;\n\t\t}\n\t\tState.ify = function(n, k, s, v, soul){ // put a key's state on a node.\n\t\t\t(n = n || {})._ = n._ || {}; // safety check or init.\n\t\t\tif(soul){ n._['#'] = soul } // set a soul if specified.\n\t\t\tvar tmp = n._['>'] || (n._['>'] = {}); // grab the states data.\n\t\t\tif(u !== k && k !== '_'){\n\t\t\t\tif('number' == typeof s){ tmp[k] = s } // add the valid state.\n\t\t\t\tif(u !== v){ n[k] = v } // Note: Not its job to check for valid values!\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\t\tmodule.exports = State;\n\t})(USE, './state');\n\n\t;USE(function(module){\n\t\tUSE('./shim');\n\t\tfunction Dup(opt){\n\t\t\tvar dup = {s:{}}, s = dup.s;\n\t\t\topt = opt || {max: 999, age: 1000 * 9};//*/ 1000 * 9 * 3};\n\t\t\tdup.check = function(id){\n\t\t\t\tif(!s[id]){ return false }\n\t\t\t\treturn dt(id);\n\t\t\t}\n\t\t\tvar dt = dup.track = function(id){\n\t\t\t\tvar it = s[id] || (s[id] = {});\n\t\t\t\tit.was = dup.now = +new Date;\n\t\t\t\tif(!dup.to){ dup.to = setTimeout(dup.drop, opt.age + 9) }\n\t\t\t\tif(dt.ed){ dt.ed(id) }\n\t\t\t\treturn it;\n\t\t\t}\n\t\t\tdup.drop = function(age){\n\t\t\t\tdup.to = null;\n\t\t\t\tdup.now = +new Date;\n\t\t\t\tvar l = Object.keys(s);\n\t\t\t\tconsole.STAT && console.STAT(dup.now, +new Date - dup.now, 'dup drop keys'); // prev ~20% CPU 7% RAM 300MB // now ~25% CPU 7% RAM 500MB\n\t\t\t\tsetTimeout.each(l, function(id){ var it = s[id]; // TODO: .keys( is slow?\n\t\t\t\t\tif(it && (age || opt.age) > (dup.now - it.was)){ return }\n\t\t\t\t\tdelete s[id];\n\t\t\t\t},0,99);\n\t\t\t}\n\t\t\treturn dup;\n\t\t}\n\t\tmodule.exports = Dup;\n\t})(USE, './dup');\n\n\t;USE(function(module){\n\t\t// request / response module, for asking and acking messages.\n\t\tUSE('./onto'); // depends upon onto!\n\t\tmodule.exports = function ask(cb, as){\n\t\t\tif(!this.on){ return }\n\t\t\tvar lack = (this.opt||{}).lack || 9000;\n\t\t\tif(!('function' == typeof cb)){\n\t\t\t\tif(!cb){ return }\n\t\t\t\tvar id = cb['#'] || cb, tmp = (this.tag||'')[id];\n\t\t\t\tif(!tmp){ return }\n\t\t\t\tif(as){\n\t\t\t\t\ttmp = this.on(id, as);\n\t\t\t\t\tclearTimeout(tmp.err);\n\t\t\t\t\ttmp.err = setTimeout(function(){ tmp.off() }, lack);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar id = (as && as['#']) || random(9);\n\t\t\tif(!cb){ return id }\n\t\t\tvar to = this.on(id, cb, as);\n\t\t\tto.err = to.err || setTimeout(function(){ to.off();\n\t\t\t\tto.next({err: \"Error: No ACK yet.\", lack: true});\n\t\t\t}, lack);\n\t\t\treturn id;\n\t\t}\n\t\tvar random = String.random || function(){ return Math.random().toString(36).slice(2) }\n\t})(USE, './ask');\n\n\t;USE(function(module){\n\n\t\tfunction Gun(o){\n\t\t\tif(o instanceof Gun){ return (this._ = {$: this}).$ }\n\t\t\tif(!(this instanceof Gun)){ return new Gun(o) }\n\t\t\treturn Gun.create(this._ = {$: this, opt: o});\n\t\t}\n\n\t\tGun.is = function($){ return ($ instanceof Gun) || ($ && $._ && ($ === $._.$)) || false }\n\n\t\tGun.version = 0.2020;\n\n\t\tGun.chain = Gun.prototype;\n\t\tGun.chain.toJSON = function(){};\n\n\t\tUSE('./shim');\n\t\tGun.valid = USE('./valid');\n\t\tGun.state = USE('./state');\n\t\tGun.on = USE('./onto');\n\t\tGun.dup = USE('./dup');\n\t\tGun.ask = USE('./ask');\n\n\t\t;(function(){\n\t\t\tGun.create = function(at){\n\t\t\t\tat.root = at.root || at;\n\t\t\t\tat.graph = at.graph || {};\n\t\t\t\tat.on = at.on || Gun.on;\n\t\t\t\tat.ask = at.ask || Gun.ask;\n\t\t\t\tat.dup = at.dup || Gun.dup();\n\t\t\t\tvar gun = at.$.opt(at.opt);\n\t\t\t\tif(!at.once){\n\t\t\t\t\tat.on('in', universe, at);\n\t\t\t\t\tat.on('out', universe, at);\n\t\t\t\t\tat.on('put', map, at);\n\t\t\t\t\tGun.on('create', at);\n\t\t\t\t\tat.on('create', at);\n\t\t\t\t}\n\t\t\t\tat.once = 1;\n\t\t\t\treturn gun;\n\t\t\t}\n\t\t\tfunction universe(msg){\n\t\t\t\t// TODO: BUG! msg.out = null being set!\n\t\t\t\t//if(!F){ var eve = this; setTimeout(function(){ universe.call(eve, msg,1) },Math.random() * 100);return; } // ADD F TO PARAMS!\n\t\t\t\tif(!msg){ return }\n\t\t\t\tif(msg.out === universe){ this.to.next(msg); return }\n\t\t\t\tvar eve = this, as = eve.as, at = as.at || as, gun = at.$, dup = at.dup, tmp, DBG = msg.DBG;\n\t\t\t\t(tmp = msg['#']) || (tmp = msg['#'] = text_rand(9));\n\t\t\t\tif(dup.check(tmp)){ return } dup.track(tmp);\n\t\t\t\ttmp = msg._; msg._ = ('function' == typeof tmp)? tmp : function(){};\n\t\t\t\t(msg.$ && (msg.$ === (msg.$._||'').$)) || (msg.$ = gun);\n\t\t\t\tif(msg['@'] && !msg.put){ ack(msg) }\n\t\t\t\tif(!at.ask(msg['@'], msg)){ // is this machine listening for an ack?\n\t\t\t\t\tDBG && (DBG.u = +new Date);\n\t\t\t\t\tif(msg.put){ put(msg); return } else\n\t\t\t\t\tif(msg.get){ Gun.on.get(msg, gun) }\n\t\t\t\t}\n\t\t\t\tDBG && (DBG.uc = +new Date);\n\t\t\t\teve.to.next(msg);\n\t\t\t\tDBG && (DBG.ua = +new Date);\n\t\t\t\tif(msg.nts || msg.NTS){ return } // TODO: This shouldn't be in core, but fast way to prevent NTS spread. Delete this line after all peers have upgraded to newer versions.\n\t\t\t\tmsg.out = universe; at.on('out', msg);\n\t\t\t\tDBG && (DBG.ue = +new Date);\n\t\t\t}\n\t\t\tfunction put(msg){\n\t\t\t\tif(!msg){ return }\n\t\t\t\tvar ctx = msg._||'', root = ctx.root = ((ctx.$ = msg.$||'')._||'').root;\n\t\t\t\tif(msg['@'] && ctx.faith && !ctx.miss){ // TODO: AXE may split/route based on 'put' what should we do here? Detect @ in AXE? I think we don't have to worry, as DAM will route it on @.\n\t\t\t\t\tmsg.out = universe;\n\t\t\t\t\troot.on('out', msg);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tctx.latch = root.hatch; ctx.match = root.hatch = [];\n\t\t\t\tvar put = msg.put;\n\t\t\t\tvar DBG = ctx.DBG = msg.DBG, S = +new Date; CT = CT || S;\n\t\t\t\tif(put['#'] && put['.']){ /*root && root.on('put', msg);*/ return } // TODO: BUG! This needs to call HAM instead.\n\t\t\t\tDBG && (DBG.p = S);\n\t\t\t\tctx['#'] = msg['#'];\n\t\t\t\tctx.msg = msg;\n\t\t\t\tctx.all = 0;\n\t\t\t\tctx.stun = 1;\n\t\t\t\tvar nl = Object.keys(put);//.sort(); // TODO: This is unbounded operation, large graphs will be slower. Write our own CPU scheduled sort? Or somehow do it in below? Keys itself is not O(1) either, create ES5 shim over ?weak map? or custom which is constant.\n\t\t\t\tconsole.STAT && console.STAT(S, ((DBG||ctx).pk = +new Date) - S, 'put sort');\n\t\t\t\tvar ni = 0, nj, kl, soul, node, states, err, tmp;\n\t\t\t\t(function pop(o){\n\t\t\t\t\tif(nj != ni){ nj = ni;\n\t\t\t\t\t\tif(!(soul = nl[ni])){\n\t\t\t\t\t\t\tconsole.STAT && console.STAT(S, ((DBG||ctx).pd = +new Date) - S, 'put');\n\t\t\t\t\t\t\tfire(ctx);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!(node = put[soul])){ err = ERR+cut(soul)+\"no node.\" } else\n\t\t\t\t\t\tif(!(tmp = node._)){ err = ERR+cut(soul)+\"no meta.\" } else\n\t\t\t\t\t\tif(soul !== tmp['#']){ err = ERR+cut(soul)+\"soul not same.\" } else\n\t\t\t\t\t\tif(!(states = tmp['>'])){ err = ERR+cut(soul)+\"no state.\" }\n\t\t\t\t\t\tkl = Object.keys(node||{}); // TODO: .keys( is slow\n\t\t\t\t\t}\n\t\t\t\t\tif(err){\n\t\t\t\t\t\tmsg.err = ctx.err = err; // invalid data should error and stun the message.\n\t\t\t\t\t\tfire(ctx);\n\t\t\t\t\t\t//console.log(\"handle error!\", err) // handle!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar i = 0, key; o = o || 0;\n\t\t\t\t\twhile(o++ < 9 && (key = kl[i++])){\n\t\t\t\t\t\tif('_' === key){ continue }\n\t\t\t\t\t\tvar val = node[key], state = states[key];\n\t\t\t\t\t\tif(u === state){ err = ERR+cut(key)+\"on\"+cut(soul)+\"no state.\"; break }\n\t\t\t\t\t\tif(!valid(val)){ err = ERR+cut(key)+\"on\"+cut(soul)+\"bad \"+(typeof val)+cut(val); break }\n\t\t\t\t\t\t//ctx.all++; //ctx.ack[soul+key] = '';\n\t\t\t\t\t\tham(val, key, soul, state, msg);\n\t\t\t\t\t\t++C; // courtesy count;\n\t\t\t\t\t}\n\t\t\t\t\tif((kl = kl.slice(i)).length){ turn(pop); return }\n\t\t\t\t\t++ni; kl = null; pop(o);\n\t\t\t\t}());\n\t\t\t} Gun.on.put = put;\n\t\t\t// TODO: MARK!!! clock below, reconnect sync, SEA certify wire merge, User.auth taking multiple times, // msg put, put, say ack, hear loop...\n\t\t\t// WASIS BUG! local peer not ack. .off other people: .open\n\t\t\tfunction ham(val, key, soul, state, msg){\n\t\t\t\tvar ctx = msg._||'', root = ctx.root, graph = root.graph, lot, tmp;\n\t\t\t\tvar vertex = graph[soul] || empty, was = state_is(vertex, key, 1), known = vertex[key];\n\t\t\t\t\n\t\t\t\tvar DBG = ctx.DBG; if(tmp = console.STAT){ if(!graph[soul] || !known){ tmp.has = (tmp.has || 0) + 1 } }\n\n\t\t\t\tvar now = State(), u;\n\t\t\t\tif(state > now){\n\t\t\t\t\tsetTimeout(function(){ ham(val, key, soul, state, msg) }, (tmp = state - now) > MD? MD : tmp); // Max Defer 32bit. :(\n\t\t\t\t\tconsole.STAT && console.STAT(((DBG||ctx).Hf = +new Date), tmp, 'future');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(state < was){ /*old;*/ if(true){ return } } // but some chains have a cache miss that need to re-fire. // TODO: Improve in future. // for AXE this would reduce rebroadcast, but GUN does it on message forwarding. // TURNS OUT CACHE MISS WAS NOT NEEDED FOR NEW CHAINS ANYMORE!!! DANGER DANGER DANGER, ALWAYS RETURN! (or am I missing something?)\n\t\t\t\tif(!ctx.faith){ // TODO: BUG? Can this be used for cache miss as well? // Yes this was a bug, need to check cache miss for RAD tests, but should we care about the faith check now? Probably not.\n\t\t\t\t\tif(state === was && (val === known || L(val) <= L(known))){ /*console.log(\"same\");*/ /*same;*/ if(!ctx.miss){ return } } // same\n\t\t\t\t}\n\t\t\t\tctx.stun++; // TODO: 'forget' feature in SEA tied to this, bad approach, but hacked in for now. Any changes here must update there.\n\t\t\t\tvar aid = msg['#']+ctx.all++, id = {toString: function(){ return aid }, _: ctx}; id.toJSON = id.toString; // this *trick* makes it compatible between old & new versions.\n\t\t\t\troot.dup.track(id)['#'] = msg['#']; // fixes new OK acks for RPC like RTC.\n\t\t\t\tDBG && (DBG.ph = DBG.ph || +new Date);\n\t\t\t\troot.on('put', {'#': id, '@': msg['@'], put: {'#': soul, '.': key, ':': val, '>': state}, ok: msg.ok, _: ctx});\n\t\t\t}\n\t\t\tfunction map(msg){\n\t\t\t\tvar DBG; if(DBG = (msg._||'').DBG){ DBG.pa = +new Date; DBG.pm = DBG.pm || +new Date}\n      \tvar eve = this, root = eve.as, graph = root.graph, ctx = msg._, put = msg.put, soul = put['#'], key = put['.'], val = put[':'], state = put['>'], id = msg['#'], tmp;\n      \tif((tmp = ctx.msg) && (tmp = tmp.put) && (tmp = tmp[soul])){ state_ify(tmp, key, state, val, soul) } // necessary! or else out messages do not get SEA transforms.\n      \t//var bytes = ((graph[soul]||'')[key]||'').length||1;\n\t\t\t\tgraph[soul] = state_ify(graph[soul], key, state, val, soul);\n\t\t\t\tif(tmp = (root.next||'')[soul]){\n\t\t\t\t\t//tmp.bytes = (tmp.bytes||0) + ((val||'').length||1) - bytes;\n\t\t\t\t\t//if(tmp.bytes > 2**13){ Gun.log.once('byte-limit', \"Note: In the future, GUN peers will enforce a ~4KB query limit. Please see https://gun.eco/docs/Page\") }\n\t\t\t\t\ttmp.on('in', msg)\n\t\t\t\t}\n\t\t\t\tfire(ctx);\n\t\t\t\teve.to.next(msg);\n\t\t\t}\n\t\t\tfunction fire(ctx, msg){ var root;\n\t\t\t\tif(ctx.stop){ return }\n\t\t\t\tif(!ctx.err && 0 < --ctx.stun){ return } // TODO: 'forget' feature in SEA tied to this, bad approach, but hacked in for now. Any changes here must update there.\n\t\t\t\tctx.stop = 1;\n\t\t\t\tif(!(root = ctx.root)){ return }\n\t\t\t\tvar tmp = ctx.match; tmp.end = 1;\n\t\t\t\tif(tmp === root.hatch){ if(!(tmp = ctx.latch) || tmp.end){ delete root.hatch } else { root.hatch = tmp } }\n\t\t\t\tctx.hatch && ctx.hatch(); // TODO: rename/rework how put & this interact.\n\t\t\t\tsetTimeout.each(ctx.match, function(cb){cb && cb()}); \n\t\t\t\tif(!(msg = ctx.msg) || ctx.err || msg.err){ return }\n\t\t\t\tmsg.out = universe;\n\t\t\t\tctx.root.on('out', msg);\n\n\t\t\t\tCF(); // courtesy check;\n\t\t\t}\n\t\t\tfunction ack(msg){ // aggregate ACKs.\n\t\t\t\tvar id = msg['@'] || '', ctx, ok, tmp;\n\t\t\t\tif(!(ctx = id._)){\n\t\t\t\t\tvar dup = (dup = msg.$) && (dup = dup._) && (dup = dup.root) && (dup = dup.dup);\n\t\t\t\t\tif(!(dup = dup.check(id))){ return }\n\t\t\t\t\tmsg['@'] = dup['#'] || msg['@']; // This doesn't do anything anymore, backtrack it to something else?\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tctx.acks = (ctx.acks||0) + 1;\n\t\t\t\tif(ctx.err = msg.err){\n\t\t\t\t\tmsg['@'] = ctx['#'];\n\t\t\t\t\tfire(ctx); // TODO: BUG? How it skips/stops propagation of msg if any 1 item is error, this would assume a whole batch/resync has same malicious intent.\n\t\t\t\t}\n\t\t\t\tctx.ok = msg.ok || ctx.ok;\n\t\t\t\tif(!ctx.stop && !ctx.crack){ ctx.crack = ctx.match && ctx.match.push(function(){back(ctx)}) } // handle synchronous acks. NOTE: If a storage peer ACKs synchronously then the PUT loop has not even counted up how many items need to be processed, so ctx.STOP flags this and adds only 1 callback to the end of the PUT loop.\n\t\t\t\tback(ctx);\n\t\t\t}\n\t\t\tfunction back(ctx){\n\t\t\t\tif(!ctx || !ctx.root){ return }\n\t\t\t\tif(ctx.stun || ctx.acks !== ctx.all){ return }\n\t\t\t\tctx.root.on('in', {'@': ctx['#'], err: ctx.err, ok: ctx.err? u : ctx.ok || {'':1}});\n\t\t\t}\n\n\t\t\tvar ERR = \"Error: Invalid graph!\";\n\t\t\tvar cut = function(s){ return \" '\"+(''+s).slice(0,9)+\"...' \" }\n\t\t\tvar L = JSON.stringify, MD = 2147483647, State = Gun.state;\n\t\t\tvar C = 0, CT, CF = function(){if(C>999 && (C/-(CT - (CT = +new Date))>1)){Gun.window && console.log(\"Warning: You're syncing 1K+ records a second, faster than DOM can update - consider limiting query.\");CF=function(){C=0}}};\n\n\t\t}());\n\n\t\t;(function(){\n\t\t\tGun.on.get = function(msg, gun){\n\t\t\t\tvar root = gun._, get = msg.get, soul = get['#'], node = root.graph[soul], has = get['.'];\n\t\t\t\tvar next = root.next || (root.next = {}), at = next[soul];\n\n\t\t\t\t// TODO: Azarattum bug, what is in graph is not same as what is in next. Fix!\n\n\t\t\t\t// queue concurrent GETs?\n\t\t\t\t// TODO: consider tagging original message into dup for DAM.\n\t\t\t\t// TODO: ^ above? In chat app, 12 messages resulted in same peer asking for `#user.pub` 12 times. (same with #user GET too, yipes!) // DAM note: This also resulted in 12 replies from 1 peer which all had same ##hash but none of them deduped because each get was different.\n\t\t\t\t// TODO: Moving quick hacks fixing these things to axe for now.\n\t\t\t\t// TODO: a lot of GET #foo then GET #foo.\"\" happening, why?\n\t\t\t\t// TODO: DAM's ## hash check, on same get ACK, producing multiple replies still, maybe JSON vs YSON?\n\t\t\t\t// TMP note for now: viMZq1slG was chat LEX query #.\n\t\t\t\t/*if(gun !== (tmp = msg.$) && (tmp = (tmp||'')._)){\n\t\t\t\t\tif(tmp.Q){ tmp.Q[msg['#']] = ''; return } // chain does not need to ask for it again.\n\t\t\t\t\ttmp.Q = {};\n\t\t\t\t}*/\n\t\t\t\t/*if(u === has){\n\t\t\t\t\tif(at.Q){\n\t\t\t\t\t\t//at.Q[msg['#']] = '';\n\t\t\t\t\t\t//return;\n\t\t\t\t\t}\n\t\t\t\t\tat.Q = {};\n\t\t\t\t}*/\n\t\t\t\tvar ctx = msg._||{}, DBG = ctx.DBG = msg.DBG;\n\t\t\t\tDBG && (DBG.g = +new Date);\n\t\t\t\t//console.log(\"GET:\", get, node, has, at);\n\t\t\t\t//if(!node && !at){ return root.on('get', msg) }\n\t\t\t\t//if(has && node){ // replace 2 below lines to continue dev?\n\t\t\t\tif(!node){ return root.on('get', msg) }\n\t\t\t\tif(has){\n\t\t\t\t\tif('string' != typeof has || u === node[has]){\n\t\t\t\t\t\tif(!((at||'').next||'')[has]){ root.on('get', msg); return }\n\t\t\t\t\t}\n\t\t\t\t\tnode = state_ify({}, has, state_is(node, has), node[has], soul);\n\t\t\t\t\t// If we have a key in-memory, do we really need to fetch?\n\t\t\t\t\t// Maybe... in case the in-memory key we have is a local write\n\t\t\t\t\t// we still need to trigger a pull/merge from peers.\n\t\t\t\t}\n\t\t\t\t//Gun.window? Gun.obj.copy(node) : node; // HNPERF: If !browser bump Performance? Is this too dangerous to reference root graph? Copy / shallow copy too expensive for big nodes. Gun.obj.to(node); // 1 layer deep copy // Gun.obj.copy(node); // too slow on big nodes\n\t\t\t\tnode && ack(msg, node);\n\t\t\t\troot.on('get', msg); // send GET to storage adapters.\n\t\t\t}\n\t\t\tfunction ack(msg, node){\n\t\t\t\tvar S = +new Date, ctx = msg._||{}, DBG = ctx.DBG = msg.DBG;\n\t\t\t\tvar to = msg['#'], id = text_rand(9), keys = Object.keys(node||'').sort(), soul = ((node||'')._||'')['#'], kl = keys.length, j = 0, root = msg.$._.root, F = (node === root.graph[soul]);\n\t\t\t\tconsole.STAT && console.STAT(S, ((DBG||ctx).gk = +new Date) - S, 'got keys');\n\t\t\t\t// PERF: Consider commenting this out to force disk-only reads for perf testing? // TODO: .keys( is slow\n\t\t\t\tnode && (function go(){\n\t\t\t\t\tS = +new Date;\n\t\t\t\t\tvar i = 0, k, put = {}, tmp;\n\t\t\t\t\twhile(i < 9 && (k = keys[i++])){\n\t\t\t\t\t\tstate_ify(put, k, state_is(node, k), node[k], soul);\n\t\t\t\t\t}\n\t\t\t\t\tkeys = keys.slice(i);\n\t\t\t\t\t(tmp = {})[soul] = put; put = tmp;\n\t\t\t\t\tvar faith; if(F){ faith = function(){}; faith.ram = faith.faith = true; } // HNPERF: We're testing performance improvement by skipping going through security again, but this should be audited.\n\t\t\t\t\ttmp = keys.length;\n\t\t\t\t\tconsole.STAT && console.STAT(S, -(S - (S = +new Date)), 'got copied some');\n\t\t\t\t\tDBG && (DBG.ga = +new Date);\n\t\t\t\t\troot.on('in', {'@': to, '#': id, put: put, '%': (tmp? (id = text_rand(9)) : u), $: root.$, _: faith, DBG: DBG, FOO: 1});\n\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'got in');\n\t\t\t\t\tif(!tmp){ return }\n\t\t\t\t\tsetTimeout.turn(go);\n\t\t\t\t}());\n\t\t\t\tif(!node){ root.on('in', {'@': msg['#']}) } // TODO: I don't think I like this, the default lS adapter uses this but \"not found\" is a sensitive issue, so should probably be handled more carefully/individually.\n\t\t\t} Gun.on.get.ack = ack;\n\t\t}());\n\n\t\t;(function(){\n\t\t\tGun.chain.opt = function(opt){\n\t\t\t\topt = opt || {};\n\t\t\t\tvar gun = this, at = gun._, tmp = opt.peers || opt;\n\t\t\t\tif(!Object.plain(opt)){ opt = {} }\n\t\t\t\tif(!Object.plain(at.opt)){ at.opt = opt }\n\t\t\t\tif('string' == typeof tmp){ tmp = [tmp] }\n\t\t\t\tif(!Object.plain(at.opt.peers)){ at.opt.peers = {}}\n\t\t\t\tif(tmp instanceof Array){\n\t\t\t\t\topt.peers = {};\n\t\t\t\t\ttmp.forEach(function(url){\n\t\t\t\t\t\tvar p = {}; p.id = p.url = url;\n\t\t\t\t\t\topt.peers[url] = at.opt.peers[url] = at.opt.peers[url] || p;\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tobj_each(opt, function each(k){ var v = this[k];\n\t\t\t\t\tif((this && this.hasOwnProperty(k)) || 'string' == typeof v || Object.empty(v)){ this[k] = v; return }\n\t\t\t\t\tif(v && v.constructor !== Object && !(v instanceof Array)){ return }\n\t\t\t\t\tobj_each(v, each);\n\t\t\t\t});\n\t\t\t\tat.opt.from = opt;\n\t\t\t\tGun.on('opt', at);\n\t\t\t\tat.opt.uuid = at.opt.uuid || function uuid(l){ return Gun.state().toString(36).replace('.','') + String.random(l||12) }\n\t\t\t\treturn gun;\n\t\t\t}\n\t\t}());\n\n\t\tvar obj_each = function(o,f){ Object.keys(o).forEach(f,o) }, text_rand = String.random, turn = setTimeout.turn, valid = Gun.valid, state_is = Gun.state.is, state_ify = Gun.state.ify, u, empty = {}, C;\n\n\t\tGun.log = function(){ return (!Gun.log.off && C.log.apply(C, arguments)), [].slice.call(arguments).join(' ') };\n\t\tGun.log.once = function(w,s,o){ return (o = Gun.log.once)[w] = o[w] || 0, o[w]++ || Gun.log(s) };\n\n\t\tif(typeof window !== \"undefined\"){ (window.GUN = window.Gun = Gun).window = window }\n\t\ttry{ if(typeof MODULE !== \"undefined\"){ MODULE.exports = Gun } }catch(e){}\n\t\tmodule.exports = Gun;\n\t\t\n\t\t(Gun.window||{}).console = (Gun.window||{}).console || {log: function(){}};\n\t\t(C = console).only = function(i, s){ return (C.only.i && i === C.only.i && C.only.i++) && (C.log.apply(C, arguments) || s) };\n\n\t\t;\"Please do not remove welcome log unless you are paying for a monthly sponsorship, thanks!\";\n\t\tGun.log.once(\"welcome\", \"Hello wonderful person! :) Thanks for using GUN, please ask for help on http://chat.gun.eco if anything takes you longer than 5min to figure out!\");\n\t})(USE, './root');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./root');\n\t\tGun.chain.back = function(n, opt){ var tmp;\n\t\t\tn = n || 1;\n\t\t\tif(-1 === n || Infinity === n){\n\t\t\t\treturn this._.root.$;\n\t\t\t} else\n\t\t\tif(1 === n){\n\t\t\t\treturn (this._.back || this._).$;\n\t\t\t}\n\t\t\tvar gun = this, at = gun._;\n\t\t\tif(typeof n === 'string'){\n\t\t\t\tn = n.split('.');\n\t\t\t}\n\t\t\tif(n instanceof Array){\n\t\t\t\tvar i = 0, l = n.length, tmp = at;\n\t\t\t\tfor(i; i < l; i++){\n\t\t\t\t\ttmp = (tmp||empty)[n[i]];\n\t\t\t\t}\n\t\t\t\tif(u !== tmp){\n\t\t\t\t\treturn opt? gun : tmp;\n\t\t\t\t} else\n\t\t\t\tif((tmp = at.back)){\n\t\t\t\t\treturn tmp.$.back(n, opt);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif('function' == typeof n){\n\t\t\t\tvar yes, tmp = {back: at};\n\t\t\t\twhile((tmp = tmp.back)\n\t\t\t\t&& u === (yes = n(tmp, opt))){}\n\t\t\t\treturn yes;\n\t\t\t}\n\t\t\tif('number' == typeof n){\n\t\t\t\treturn (at.back || at).$.back(n - 1);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tvar empty = {}, u;\n\t})(USE, './back');\n\n\t;USE(function(module){\n\t\t// WARNING: GUN is very simple, but the JavaScript chaining API around GUN\n\t\t// is complicated and was extremely hard to build. If you port GUN to another\n\t\t// language, consider implementing an easier API to build.\n\t\tvar Gun = USE('./root');\n\t\tGun.chain.chain = function(sub){\n\t\t\tvar gun = this, at = gun._, chain = new (sub || gun).constructor(gun), cat = chain._, root;\n\t\t\tcat.root = root = at.root;\n\t\t\tcat.id = ++root.once;\n\t\t\tcat.back = gun._;\n\t\t\tcat.on = Gun.on;\n\t\t\tcat.on('in', Gun.on.in, cat); // For 'in' if I add my own listeners to each then I MUST do it before in gets called. If I listen globally for all incoming data instead though, regardless of individual listeners, I can transform the data there and then as well.\n\t\t\tcat.on('out', Gun.on.out, cat); // However for output, there isn't really the global option. I must listen by adding my own listener individually BEFORE this one is ever called.\n\t\t\treturn chain;\n\t\t}\n\n\t\tfunction output(msg){\n\t\t\tvar put, get, at = this.as, back = at.back, root = at.root, tmp;\n\t\t\tif(!msg.$){ msg.$ = at.$ }\n\t\t\tthis.to.next(msg);\n\t\t\tif(at.err){ at.on('in', {put: at.put = u, $: at.$}); return }\n\t\t\tif(get = msg.get){\n\t\t\t\t/*if(u !== at.put){\n\t\t\t\t\tat.on('in', at);\n\t\t\t\t\treturn;\n\t\t\t\t}*/\n\t\t\t\tif(root.pass){ root.pass[at.id] = at; } // will this make for buggy behavior elsewhere?\n\t\t\t\tif(at.lex){ Object.keys(at.lex).forEach(function(k){ tmp[k] = at.lex[k] }, tmp = msg.get = msg.get || {}) }\n\t\t\t\tif(get['#'] || at.soul){\n\t\t\t\t\tget['#'] = get['#'] || at.soul;\n\t\t\t\t\t//root.graph[get['#']] = root.graph[get['#']] || {_:{'#':get['#'],'>':{}}};\n\t\t\t\t\tmsg['#'] || (msg['#'] = text_rand(9)); // A3120 ?\n\t\t\t\t\tback = (root.$.get(get['#'])._);\n\t\t\t\t\tif(!(get = get['.'])){ // soul\n\t\t\t\t\t\ttmp = back.ask && back.ask['']; // check if we have already asked for the full node\n\t\t\t\t\t\t(back.ask || (back.ask = {}))[''] = back; // add a flag that we are now.\n\t\t\t\t\t\tif(u !== back.put){ // if we already have data,\n\t\t\t\t\t\t\tback.on('in', back); // send what is cached down the chain\n\t\t\t\t\t\t\tif(tmp){ return } // and don't ask for it again.\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmsg.$ = back.$;\n\t\t\t\t\t} else\n\t\t\t\t\tif(obj_has(back.put, get)){ // TODO: support #LEX !\n\t\t\t\t\t\ttmp = back.ask && back.ask[get];\n\t\t\t\t\t\t(back.ask || (back.ask = {}))[get] = back.$.get(get)._;\n\t\t\t\t\t\tback.on('in', {get: get, put: {'#': back.soul, '.': get, ':': back.put[get], '>': state_is(root.graph[back.soul], get)}});\n\t\t\t\t\t\tif(tmp){ return }\n\t\t\t\t\t}\n\t\t\t\t\t\t/*put = (back.$.get(get)._);\n\t\t\t\t\t\tif(!(tmp = put.ack)){ put.ack = -1 }\n\t\t\t\t\t\tback.on('in', {\n\t\t\t\t\t\t\t$: back.$,\n\t\t\t\t\t\t\tput: Gun.state.ify({}, get, Gun.state(back.put, get), back.put[get]),\n\t\t\t\t\t\t\tget: back.get\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif(tmp){ return }\n\t\t\t\t\t} else\n\t\t\t\t\tif('string' != typeof get){\n\t\t\t\t\t\tvar put = {}, meta = (back.put||{})._;\n\t\t\t\t\t\tGun.obj.map(back.put, function(v,k){\n\t\t\t\t\t\t\tif(!Gun.text.match(k, get)){ return }\n\t\t\t\t\t\t\tput[k] = v;\n\t\t\t\t\t\t})\n\t\t\t\t\t\tif(!Gun.obj.empty(put)){\n\t\t\t\t\t\t\tput._ = meta;\n\t\t\t\t\t\t\tback.on('in', {$: back.$, put: put, get: back.get})\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(tmp = at.lex){\n\t\t\t\t\t\t\ttmp = (tmp._) || (tmp._ = function(){});\n\t\t\t\t\t\t\tif(back.ack < tmp.ask){ tmp.ask = back.ack }\n\t\t\t\t\t\t\tif(tmp.ask){ return }\n\t\t\t\t\t\t\ttmp.ask = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\troot.ask(ack, msg); // A3120 ?\n\t\t\t\t\treturn root.on('in', msg);\n\t\t\t\t}\n\t\t\t\t//if(root.now){ root.now[at.id] = root.now[at.id] || true; at.pass = {} }\n\t\t\t\tif(get['.']){\n\t\t\t\t\tif(at.get){\n\t\t\t\t\t\tmsg = {get: {'.': at.get}, $: at.$};\n\t\t\t\t\t\t(back.ask || (back.ask = {}))[at.get] = msg.$._; // TODO: PERFORMANCE? More elegant way?\n\t\t\t\t\t\treturn back.on('out', msg);\n\t\t\t\t\t}\n\t\t\t\t\tmsg = {get: at.lex? msg.get : {}, $: at.$};\n\t\t\t\t\treturn back.on('out', msg);\n\t\t\t\t}\n\t\t\t\t(at.ask || (at.ask = {}))[''] = at;\t //at.ack = at.ack || -1;\n\t\t\t\tif(at.get){\n\t\t\t\t\tget['.'] = at.get;\n\t\t\t\t\t(back.ask || (back.ask = {}))[at.get] = msg.$._; // TODO: PERFORMANCE? More elegant way?\n\t\t\t\t\treturn back.on('out', msg);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn back.on('out', msg);\n\t\t}; Gun.on.out = output;\n\n\t\tfunction input(msg, cat){ cat = cat || this.as; // TODO: V8 may not be able to optimize functions with different parameter calls, so try to do benchmark to see if there is any actual difference.\n\t\t\tvar root = cat.root, gun = msg.$ || (msg.$ = cat.$), at = (gun||'')._ || empty, tmp = msg.put||'', soul = tmp['#'], key = tmp['.'], change = (u !== tmp['='])? tmp['='] : tmp[':'], state = tmp['>'] || -Infinity, sat; // eve = event, at = data at, cat = chain at, sat = sub at (children chains).\n\t\t\tif(u !== msg.put && (u === tmp['#'] || u === tmp['.'] || (u === tmp[':'] && u === tmp['=']) || u === tmp['>'])){ // convert from old format\n\t\t\t\tif(!valid(tmp)){\n\t\t\t\t\tif(!(soul = ((tmp||'')._||'')['#'])){ console.log(\"chain not yet supported for\", tmp, '...', msg, cat); return; }\n\t\t\t\t\tgun = cat.root.$.get(soul);\n\t\t\t\t\treturn setTimeout.each(Object.keys(tmp).sort(), function(k){ // TODO: .keys( is slow // BUG? ?Some re-in logic may depend on this being sync?\n\t\t\t\t\t\tif('_' == k || u === (state = state_is(tmp, k))){ return }\n\t\t\t\t\t\tcat.on('in', {$: gun, put: {'#': soul, '.': k, '=': tmp[k], '>': state}, VIA: msg});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcat.on('in', {$: at.back.$, put: {'#': soul = at.back.soul, '.': key = at.has || at.get, '=': tmp, '>': state_is(at.back.put, key)}, via: msg}); // TODO: This could be buggy! It assumes/approxes data, other stuff could have corrupted it.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif((msg.seen||'')[cat.id]){ return } (msg.seen || (msg.seen = function(){}))[cat.id] = cat; // help stop some infinite loops\n\n\t\t\tif(cat !== at){ // don't worry about this when first understanding the code, it handles changing contexts on a message. A soul chain will never have a different context.\n\t\t\t\tObject.keys(msg).forEach(function(k){ tmp[k] = msg[k] }, tmp = {}); // make copy of message\n\t\t\t\ttmp.get = cat.get || tmp.get;\n\t\t\t\tif(!cat.soul && !cat.has){ // if we do not recognize the chain type\n\t\t\t\t\ttmp.$$$ = tmp.$$$ || cat.$; // make a reference to wherever it came from.\n\t\t\t\t} else\n\t\t\t\tif(at.soul){ // a has (property) chain will have a different context sometimes if it is linked (to a soul chain). Anything that is not a soul or has chain, will always have different contexts.\n\t\t\t\t\ttmp.$ = cat.$;\n\t\t\t\t\ttmp.$$ = tmp.$$ || at.$;\n\t\t\t\t}\n\t\t\t\tmsg = tmp; // use the message with the new context instead;\n\t\t\t}\n\t\t\tunlink(msg, cat);\n\n\t\t\tif(((cat.soul/* && (cat.ask||'')['']*/) || msg.$$) && state >= state_is(root.graph[soul], key)){ // The root has an in-memory cache of the graph, but if our peer has asked for the data then we want a per deduplicated chain copy of the data that might have local edits on it.\n\t\t\t\t(tmp = root.$.get(soul)._).put = state_ify(tmp.put, key, state, change, soul);\n\t\t\t}\n\t\t\tif(!at.soul /*&& (at.ask||'')['']*/ && state >= state_is(root.graph[soul], key) && (sat = (root.$.get(soul)._.next||'')[key])){ // Same as above here, but for other types of chains. // TODO: Improve perf by preventing echoes recaching.\n\t\t\t\tsat.put = change; // update cache\n\t\t\t\tif('string' == typeof (tmp = valid(change))){\n\t\t\t\t\tsat.put = root.$.get(tmp)._.put || change; // share same cache as what we're linked to.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.to && this.to.next(msg); // 1st API job is to call all chain listeners.\n\t\t\t// TODO: Make input more reusable by only doing these (some?) calls if we are a chain we recognize? This means each input listener would be responsible for when listeners need to be called, which makes sense, as they might want to filter.\n\t\t\tcat.any && setTimeout.each(Object.keys(cat.any), function(any){ (any = cat.any[any]) && any(msg) },0,99); // 1st API job is to call all chain listeners. // TODO: .keys( is slow // BUG: Some re-in logic may depend on this being sync.\n\t\t\tcat.echo && setTimeout.each(Object.keys(cat.echo), function(lat){ (lat = cat.echo[lat]) && lat.on('in', msg) },0,99); // & linked at chains // TODO: .keys( is slow // BUG: Some re-in logic may depend on this being sync.\n\n\t\t\tif(((msg.$$||'')._||at).soul){ // comments are linear, but this line of code is non-linear, so if I were to comment what it does, you'd have to read 42 other comments first... but you can't read any of those comments until you first read this comment. What!? // shouldn't this match link's check?\n\t\t\t\t// is there cases where it is a $$ that we do NOT want to do the following? \n\t\t\t\tif((sat = cat.next) && (sat = sat[key])){ // TODO: possible trick? Maybe have `ionmap` code set a sat? // TODO: Maybe we should do `cat.ask` instead? I guess does not matter.\n\t\t\t\t\ttmp = {}; Object.keys(msg).forEach(function(k){ tmp[k] = msg[k] });\n\t\t\t\t\ttmp.$ = (msg.$$||msg.$).get(tmp.get = key); delete tmp.$$; delete tmp.$$$;\n\t\t\t\t\tsat.on('in', tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlink(msg, cat);\n\t\t}; Gun.on.in = input;\n\n\t\tfunction link(msg, cat){ cat = cat || this.as || msg.$._;\n\t\t\tif(msg.$$ && this !== Gun.on){ return } // $$ means we came from a link, so we are at the wrong level, thus ignore it unless overruled manually by being called directly.\n\t\t\tif(!msg.put || cat.soul){ return } // But you cannot overrule being linked to nothing, or trying to link a soul chain - that must never happen.\n\t\t\tvar put = msg.put||'', link = put['=']||put[':'], tmp;\n\t\t\tvar root = cat.root, tat = root.$.get(put['#']).get(put['.'])._;\n\t\t\tif('string' != typeof (link = valid(link))){\n\t\t\t\tif(this === Gun.on){ (tat.echo || (tat.echo = {}))[cat.id] = cat } // allow some chain to explicitly force linking to simple data.\n\t\t\t\treturn; // by default do not link to data that is not a link.\n\t\t\t}\n\t\t\tif((tat.echo || (tat.echo = {}))[cat.id] // we've already linked ourselves so we do not need to do it again. Except... (annoying implementation details)\n\t\t\t\t&& !(root.pass||'')[cat.id]){ return } // if a new event listener was added, we need to make a pass through for it. The pass will be on the chain, not always the chain passed down. \n\t\t\tif(tmp = root.pass){ if(tmp[link+cat.id]){ return } tmp[link+cat.id] = 1 } // But the above edge case may \"pass through\" on a circular graph causing infinite passes, so we hackily add a temporary check for that.\n\n\t\t\t(tat.echo||(tat.echo={}))[cat.id] = cat; // set ourself up for the echo! // TODO: BUG? Echo to self no longer causes problems? Confirm.\n\n\t\t\tif(cat.has){ cat.link = link }\n\t\t\tvar sat = root.$.get(tat.link = link)._; // grab what we're linking to.\n\t\t\t(sat.echo || (sat.echo = {}))[tat.id] = tat; // link it.\n\t\t\tvar tmp = cat.ask||''; // ask the chain for what needs to be loaded next!\n\t\t\tif(tmp[''] || cat.lex){ // we might need to load the whole thing // TODO: cat.lex probably has edge case bugs to it, need more test coverage.\n\t\t\t\tsat.on('out', {get: {'#': link}});\n\t\t\t}\n\t\t\tsetTimeout.each(Object.keys(tmp), function(get, sat){ // if sub chains are asking for data. // TODO: .keys( is slow // BUG? ?Some re-in logic may depend on this being sync?\n\t\t\t\tif(!get || !(sat = tmp[get])){ return }\n\t\t\t\tsat.on('out', {get: {'#': link, '.': get}}); // go get it.\n\t\t\t},0,99);\n\t\t}; Gun.on.link = link;\n\n\t\tfunction unlink(msg, cat){ // ugh, so much code for seemingly edge case behavior.\n\t\t\tvar put = msg.put||'', change = (u !== put['='])? put['='] : put[':'], root = cat.root, link, tmp;\n\t\t\tif(u === change){ // 1st edge case: If we have a brand new database, no data will be found.\n\t\t\t\t// TODO: BUG! because emptying cache could be async from below, make sure we are not emptying a newer cache. So maybe pass an Async ID to check against?\n\t\t\t\t// TODO: BUG! What if this is a map? // Warning! Clearing things out needs to be robust against sync/async ops, or else you'll see `map val get put` test catastrophically fail because map attempts to link when parent graph is streamed before child value gets set. Need to differentiate between lack acks and force clearing.\n\t\t\t\tif(cat.soul && u !== cat.put){ return } // data may not be found on a soul, but if a soul already has data, then nothing can clear the soul as a whole.\n\t\t\t\t//if(!cat.has){ return }\n\t\t\t\ttmp = (msg.$$||msg.$||'')._||'';\n\t\t\t\tif(msg['@'] && (u !== tmp.put || u !== cat.put)){ return } // a \"not found\" from other peers should not clear out data if we have already found it.\n\t\t\t\t//if(cat.has && u === cat.put && !(root.pass||'')[cat.id]){ return } // if we are already unlinked, do not call again, unless edge case. // TODO: BUG! This line should be deleted for \"unlink deeply nested\".\n\t\t\t\tif(link = cat.link || msg.linked){\n\t\t\t\t\tdelete (root.$.get(link)._.echo||'')[cat.id];\n\t\t\t\t}\n\t\t\t\tif(cat.has){ // TODO: Empty out links, maps, echos, acks/asks, etc.?\n\t\t\t\t\tcat.link = null;\n\t\t\t\t}\n\t\t\t\tcat.put = u; // empty out the cache if, for example, alice's car's color no longer exists (relative to alice) if alice no longer has a car.\n\t\t\t\t// TODO: BUG! For maps, proxy this so the individual sub is triggered, not all subs.\n\t\t\t\tsetTimeout.each(Object.keys(cat.next||''), function(get, sat){ // empty out all sub chains. // TODO: .keys( is slow // BUG? ?Some re-in logic may depend on this being sync? // TODO: BUG? This will trigger deeper put first, does put logic depend on nested order? // TODO: BUG! For map, this needs to be the isolated child, not all of them.\n\t\t\t\t\tif(!(sat = cat.next[get])){ return }\n\t\t\t\t\t//if(cat.has && u === sat.put && !(root.pass||'')[sat.id]){ return } // if we are already unlinked, do not call again, unless edge case. // TODO: BUG! This line should be deleted for \"unlink deeply nested\".\n\t\t\t\t\tif(link){ delete (root.$.get(link).get(get)._.echo||'')[sat.id] }\n\t\t\t\t\tsat.on('in', {get: get, put: u, $: sat.$}); // TODO: BUG? Add recursive seen check?\n\t\t\t\t},0,99);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(cat.soul){ return } // a soul cannot unlink itself.\n\t\t\tif(msg.$$){ return } // a linked chain does not do the unlinking, the sub chain does. // TODO: BUG? Will this cancel maps?\n\t\t\tlink = valid(change); // need to unlink anytime we are not the same link, though only do this once per unlink (and not on init).\n\t\t\ttmp = msg.$._||'';\n\t\t\tif(link === tmp.link || (cat.has && !tmp.link)){\n\t\t\t\tif((root.pass||'')[cat.id] && 'string' !== typeof link){\n\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete (tmp.echo||'')[cat.id];\n\t\t\tunlink({get: cat.get, put: u, $: msg.$, linked: msg.linked = msg.linked || tmp.link}, cat); // unlink our sub chains.\n\t\t}; Gun.on.unlink = unlink;\n\n\t\tfunction ack(msg, ev){\n\t\t\t//if(!msg['%'] && (this||'').off){ this.off() } // do NOT memory leak, turn off listeners! Now handled by .ask itself\n\t\t\t// manhattan:\n\t\t\tvar as = this.as, at = as.$._, root = at.root, get = as.get||'', tmp = (msg.put||'')[get['#']]||'';\n\t\t\tif(!msg.put || ('string' == typeof get['.'] && u === tmp[get['.']])){\n\t\t\t\tif(u !== at.put){ return }\n\t\t\t\tif(!at.soul && !at.has){ return } // TODO: BUG? For now, only core-chains will handle not-founds, because bugs creep in if non-core chains are used as $ but we can revisit this later for more powerful extensions.\n\t\t\t\tat.ack = (at.ack || 0) + 1;\n\t\t\t\tat.on('in', {\n\t\t\t\t\tget: at.get,\n\t\t\t\t\tput: at.put = u,\n\t\t\t\t\t$: at.$,\n\t\t\t\t\t'@': msg['@']\n\t\t\t\t});\n\t\t\t\t/*(tmp = at.Q) && setTimeout.each(Object.keys(tmp), function(id){ // TODO: Temporary testing, not integrated or being used, probably delete.\n\t\t\t\t\tObject.keys(msg).forEach(function(k){ tmp[k] = msg[k] }, tmp = {}); tmp['@'] = id; // copy message\n\t\t\t\t\troot.on('in', tmp);\n\t\t\t\t}); delete at.Q;*/\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t(msg._||{}).miss = 1;\n\t\t\tGun.on.put(msg);\n\t\t\treturn; // eom\n\t\t}\n\n\t\tvar empty = {}, u, text_rand = String.random, valid = Gun.valid, obj_has = function(o, k){ return o && Object.prototype.hasOwnProperty.call(o, k) }, state = Gun.state, state_is = state.is, state_ify = state.ify;\n\t})(USE, './chain');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./root');\n\t\tGun.chain.get = function(key, cb, as){\n\t\t\tvar gun, tmp;\n\t\t\tif(typeof key === 'string'){\n\t\t\t\tif(key.length == 0) {\t\n\t\t\t\t\t(gun = this.chain())._.err = {err: Gun.log('0 length key!', key)};\n\t\t\t\t\tif(cb){ cb.call(gun, gun._.err) }\n\t\t\t\t\treturn gun;\n\t\t\t\t}\n\t\t\t\tvar back = this, cat = back._;\n\t\t\t\tvar next = cat.next || empty;\n\t\t\t\tif(!(gun = next[key])){\n\t\t\t\t\tgun = key && cache(key, back);\n\t\t\t\t}\n\t\t\t\tgun = gun && gun.$;\n\t\t\t} else\n\t\t\tif('function' == typeof key){\n\t\t\t\tif(true === cb){ return soul(this, key, cb, as), this }\n\t\t\t\tgun = this;\n\t\t\t\tvar cat = gun._, opt = cb || {}, root = cat.root, id;\n\t\t\t\topt.at = cat;\n\t\t\t\topt.ok = key;\n\t\t\t\tvar wait = {}; // can we assign this to the at instead, like in once?\n\t\t\t\t//var path = []; cat.$.back(at => { at.get && path.push(at.get.slice(0,9))}); path = path.reverse().join('.');\n\t\t\t\tfunction any(msg, eve, f){\n\t\t\t\t\tif(any.stun){ return }\n\t\t\t\t\tif((tmp = root.pass) && !tmp[id]){ return }\n\t\t\t\t\tvar at = msg.$._, sat = (msg.$$||'')._, data = (sat||at).put, odd = (!at.has && !at.soul), test = {}, link, tmp;\n\t\t\t\t\tif(odd || u === data){ // handles non-core\n\t\t\t\t\t\tdata = (u === ((tmp = msg.put)||'')['='])? (u === (tmp||'')[':'])? tmp : tmp[':'] : tmp['='];\n\t\t\t\t\t}\n\t\t\t\t\tif(link = ('string' == typeof (tmp = Gun.valid(data)))){\n\t\t\t\t\t\tdata = (u === (tmp = root.$.get(tmp)._.put))? opt.not? u : data : tmp;\n\t\t\t\t\t}\n\t\t\t\t\tif(opt.not && u === data){ return }\n\t\t\t\t\tif(u === opt.stun){\n\t\t\t\t\t\tif((tmp = root.stun) && tmp.on){\n\t\t\t\t\t\t\tcat.$.back(function(a){ // our chain stunned?\n\t\t\t\t\t\t\t\ttmp.on(''+a.id, test = {});\n\t\t\t\t\t\t\t\tif((test.run || 0) < any.id){ return test } // if there is an earlier stun on gapless parents/self.\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t!test.run && tmp.on(''+at.id, test = {}); // this node stunned?\n\t\t\t\t\t\t\t!test.run && sat && tmp.on(''+sat.id, test = {}); // linked node stunned?\n\t\t\t\t\t\t\tif(any.id > test.run){\n\t\t\t\t\t\t\t\tif(!test.stun || test.stun.end){\n\t\t\t\t\t\t\t\t\ttest.stun = tmp.on('stun');\n\t\t\t\t\t\t\t\t\ttest.stun = test.stun && test.stun.last;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(test.stun && !test.stun.end){\n\t\t\t\t\t\t\t\t\t//if(odd && u === data){ return }\n\t\t\t\t\t\t\t\t\t//if(u === msg.put){ return } // \"not found\" acks will be found if there is stun, so ignore these.\n\t\t\t\t\t\t\t\t\t(test.stun.add || (test.stun.add = {}))[id] = function(){ any(msg,eve,1) } // add ourself to the stun callback list that is called at end of the write.\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(/*odd &&*/ u === data){ f = 0 } // if data not found, keep waiting/trying.\n\t\t\t\t\t\t/*if(f && u === data){\n\t\t\t\t\t\t\tcat.on('out', opt.out);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tif((tmp = root.hatch) && !tmp.end && u === opt.hatch && !f){ // quick hack! // What's going on here? Because data is streamed, we get things one by one, but a lot of developers would rather get a callback after each batch instead, so this does that by creating a wait list per chain id that is then called at the end of the batch by the hatch code in the root put listener.\n\t\t\t\t\t\t\tif(wait[at.$._.id]){ return } wait[at.$._.id] = 1;\n\t\t\t\t\t\t\ttmp.push(function(){any(msg,eve,1)});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}; wait = {}; // end quick hack.\n\t\t\t\t\t}\n\t\t\t\t\t// call:\n\t\t\t\t\tif(root.pass){ if(root.pass[id+at.id]){ return } root.pass[id+at.id] = 1 }\n\t\t\t\t\tif(opt.on){ opt.ok.call(at.$, data, at.get, msg, eve || any); return } // TODO: Also consider breaking `this` since a lot of people do `=>` these days and `.call(` has slower performance.\n\t\t\t\t\tif(opt.v2020){ opt.ok(msg, eve || any); return }\n\t\t\t\t\tObject.keys(msg).forEach(function(k){ tmp[k] = msg[k] }, tmp = {}); msg = tmp; msg.put = data; // 2019 COMPATIBILITY! TODO: GET RID OF THIS!\n\t\t\t\t\topt.ok.call(opt.as, msg, eve || any); // is this the right\n\t\t\t\t};\n\t\t\t\tany.at = cat;\n\t\t\t\t//(cat.any||(cat.any=function(msg){ setTimeout.each(Object.keys(cat.any||''), function(act){ (act = cat.any[act]) && act(msg) },0,99) }))[id = String.random(7)] = any; // maybe switch to this in future?\n\t\t\t\t(cat.any||(cat.any={}))[id = String.random(7)] = any;\n\t\t\t\tany.off = function(){ any.stun = 1; if(!cat.any){ return } delete cat.any[id] }\n\t\t\t\tany.rid = rid; // logic from old version, can we clean it up now?\n\t\t\t\tany.id = opt.run || ++root.once; // used in callback to check if we are earlier than a write. // will this ever cause an integer overflow?\n\t\t\t\ttmp = root.pass; (root.pass = {})[id] = 1; // Explanation: test trade-offs want to prevent recursion so we add/remove pass flag as it gets fulfilled to not repeat, however map map needs many pass flags - how do we reconcile?\n\t\t\t\topt.out = opt.out || {get: {}};\n\t\t\t\tcat.on('out', opt.out);\n\t\t\t\troot.pass = tmp;\n\t\t\t\treturn gun;\n\t\t\t} else\n\t\t\tif('number' == typeof key){\n\t\t\t\treturn this.get(''+key, cb, as);\n\t\t\t} else\n\t\t\tif('string' == typeof (tmp = valid(key))){\n\t\t\t\treturn this.get(tmp, cb, as);\n\t\t\t} else\n\t\t\tif(tmp = this.get.next){\n\t\t\t\tgun = tmp(this, key);\n\t\t\t}\n\t\t\tif(!gun){\n\t\t\t\t(gun = this.chain())._.err = {err: Gun.log('Invalid get request!', key)}; // CLEAN UP\n\t\t\t\tif(cb){ cb.call(gun, gun._.err) }\n\t\t\t\treturn gun;\n\t\t\t}\n\t\t\tif(cb && 'function' == typeof cb){\n\t\t\t\tgun.get(cb, as);\n\t\t\t}\n\t\t\treturn gun;\n\t\t}\n\t\tfunction cache(key, back){\n\t\t\tvar cat = back._, next = cat.next, gun = back.chain(), at = gun._;\n\t\t\tif(!next){ next = cat.next = {} }\n\t\t\tnext[at.get = key] = at;\n\t\t\tif(back === cat.root.$){\n\t\t\t\tat.soul = key;\n\t\t\t\t//at.put = {};\n\t\t\t} else\n\t\t\tif(cat.soul || cat.has){\n\t\t\t\tat.has = key;\n\t\t\t\t//if(obj_has(cat.put, key)){\n\t\t\t\t\t//at.put = cat.put[key];\n\t\t\t\t//}\n\t\t\t}\n\t\t\treturn at;\n\t\t}\n\t\tfunction soul(gun, cb, opt, as){\n\t\t\tvar cat = gun._, acks = 0, tmp;\n\t\t\tif(tmp = cat.soul || cat.link){ return cb(tmp, as, cat) }\n\t\t\tif(cat.jam){ return cat.jam.push([cb, as]) }\n\t\t\tcat.jam = [[cb,as]];\n\t\t\tgun.get(function go(msg, eve){\n\t\t\t\tif(u === msg.put && !cat.root.opt.super && (tmp = Object.keys(cat.root.opt.peers).length) && ++acks <= tmp){ // TODO: super should not be in core code, bring AXE up into core instead to fix? // TODO: .keys( is slow\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\teve.rid(msg);\n\t\t\t\tvar at = ((at = msg.$) && at._) || {}, i = 0, as;\n\t\t\t\ttmp = cat.jam; delete cat.jam; // tmp = cat.jam.splice(0, 100);\n\t\t\t\t//if(tmp.length){ process.nextTick(function(){ go(msg, eve) }) }\n\t\t\t\twhile(as = tmp[i++]){ //Gun.obj.map(tmp, function(as, cb){\n\t\t\t\t\tvar cb = as[0], id; as = as[1];\n\t\t\t\t\tcb && cb(id = at.link || at.soul || Gun.valid(msg.put) || ((msg.put||{})._||{})['#'], as, msg, eve);\n\t\t\t\t} //);\n\t\t\t}, {out: {get: {'.':true}}});\n\t\t\treturn gun;\n\t\t}\n\t\tfunction rid(at){\n\t\t\tvar cat = this.at || this.on;\n\t\t\tif(!at || cat.soul || cat.has){ return this.off() }\n\t\t\tif(!(at = (at = (at = at.$ || at)._ || at).id)){ return }\n\t\t\tvar map = cat.map, tmp, seen;\n\t\t\t//if(!map || !(tmp = map[at]) || !(tmp = tmp.at)){ return }\n\t\t\tif(tmp = (seen = this.seen || (this.seen = {}))[at]){ return true }\n\t\t\tseen[at] = true;\n\t\t\treturn;\n\t\t\t//tmp.echo[cat.id] = {}; // TODO: Warning: This unsubscribes ALL of this chain's listeners from this link, not just the one callback event.\n\t\t\t//obj.del(map, at); // TODO: Warning: This unsubscribes ALL of this chain's listeners from this link, not just the one callback event.\n\t\t\treturn;\n\t\t}\n\t\tvar empty = {}, valid = Gun.valid, u;\n\t})(USE, './get');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./root');\n\t\tGun.chain.put = function(data, cb, as){ // I rewrote it :)\n\t\t\tvar gun = this, at = gun._, root = at.root;\n\t\t\tas = as || {};\n\t\t\tas.root = at.root;\n\t\t\tas.run || (as.run = root.once);\n\t\t\tstun(as, at.id); // set a flag for reads to check if this chain is writing.\n\t\t\tas.ack = as.ack || cb;\n\t\t\tas.via = as.via || gun;\n\t\t\tas.data = as.data || data;\n\t\t\tas.soul || (as.soul = at.soul || ('string' == typeof cb && cb));\n\t\t\tvar s = as.state = as.state || Gun.state();\n\t\t\tif('function' == typeof data){ data(function(d){ as.data = d; gun.put(u,u,as) }); return gun }\n\t\t\tif(!as.soul){ return get(as), gun }\n\t\t\tas.$ = root.$.get(as.soul); // TODO: This may not allow user chaining and similar?\n\t\t\tas.todo = [{it: as.data, ref: as.$}];\n\t\t\tas.turn = as.turn || turn;\n\t\t\tas.ran = as.ran || ran;\n\t\t\t//var path = []; as.via.back(at => { at.get && path.push(at.get.slice(0,9)) }); path = path.reverse().join('.');\n\t\t\t// TODO: Perf! We only need to stun chains that are being modified, not necessarily written to.\n\t\t\t(function walk(){\n\t\t\t\tvar to = as.todo, at = to.pop(), d = at.it, cid = at.ref && at.ref._.id, v, k, cat, tmp, g;\n\t\t\t\tstun(as, at.ref);\n\t\t\t\tif(tmp = at.todo){\n\t\t\t\t\tk = tmp.pop(); d = d[k];\n\t\t\t\t\tif(tmp.length){ to.push(at) }\n\t\t\t\t}\n\t\t\t\tk && (to.path || (to.path = [])).push(k);\n\t\t\t\tif(!(v = valid(d)) && !(g = Gun.is(d))){\n\t\t\t\t\tif(!Object.plain(d)){ ran.err(as, \"Invalid data: \"+ check(d) +\" at \" + (as.via.back(function(at){at.get && tmp.push(at.get)}, tmp = []) || tmp.join('.'))+'.'+(to.path||[]).join('.')); return }\n\t\t\t\t\tvar seen = as.seen || (as.seen = []), i = seen.length;\n\t\t\t\t\twhile(i--){ if(d === (tmp = seen[i]).it){ v = d = tmp.link; break } }\n\t\t\t\t}\n\t\t\t\tif(k && v){ at.node = state_ify(at.node, k, s, d) } // handle soul later.\n\t\t\t\telse {\n\t\t\t\t\tif(!as.seen){ ran.err(as, \"Data at root of graph must be a node (an object).\"); return }\n\t\t\t\t\tas.seen.push(cat = {it: d, link: {}, todo: g? [] : Object.keys(d).sort().reverse(), path: (to.path||[]).slice(), up: at}); // Any perf reasons to CPU schedule this .keys( ?\n\t\t\t\t\tat.node = state_ify(at.node, k, s, cat.link);\n\t\t\t\t\t!g && cat.todo.length && to.push(cat);\n\t\t\t\t\t// ---------------\n\t\t\t\t\tvar id = as.seen.length;\n\t\t\t\t\t(as.wait || (as.wait = {}))[id] = '';\n\t\t\t\t\ttmp = (cat.ref = (g? d : k? at.ref.get(k) : at.ref))._;\n\t\t\t\t\t(tmp = (d && (d._||'')['#']) || tmp.soul || tmp.link)? resolve({soul: tmp}) : cat.ref.get(resolve, {run: as.run, /*hatch: 0,*/ v2020:1, out:{get:{'.':' '}}}); // TODO: BUG! This should be resolve ONLY soul to prevent full data from being loaded. // Fixed now?\n\t\t\t\t\t//setTimeout(function(){ if(F){ return } console.log(\"I HAVE NOT BEEN CALLED!\", path, id, cat.ref._.id, k) }, 9000); var F; // MAKE SURE TO ADD F = 1 below!\n\t\t\t\t\tfunction resolve(msg, eve){\n\t\t\t\t\t\tvar end = cat.link['#'];\n\t\t\t\t\t\tif(eve){ eve.off(); eve.rid(msg) } // TODO: Too early! Check all peers ack not found.\n\t\t\t\t\t\t// TODO: BUG maybe? Make sure this does not pick up a link change wipe, that it uses the changign link instead.\n\t\t\t\t\t\tvar soul = end || msg.soul || (tmp = (msg.$$||msg.$)._||'').soul || tmp.link || ((tmp = tmp.put||'')._||'')['#'] || tmp['#'] || (((tmp = msg.put||'') && msg.$$)? tmp['#'] : (tmp['=']||tmp[':']||'')['#']);\n\t\t\t\t\t\t!end && stun(as, msg.$);\n\t\t\t\t\t\tif(!soul && !at.link['#']){ // check soul link above us\n\t\t\t\t\t\t\t(at.wait || (at.wait = [])).push(function(){ resolve(msg, eve) }) // wait\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!soul){\n\t\t\t\t\t\t\tsoul = [];\n\t\t\t\t\t\t\t(msg.$$||msg.$).back(function(at){\n\t\t\t\t\t\t\t\tif(tmp = at.soul || at.link){ return soul.push(tmp) }\n\t\t\t\t\t\t\t\tsoul.push(at.get);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tsoul = soul.reverse().join('/');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcat.link['#'] = soul;\n\t\t\t\t\t\t!g && (((as.graph || (as.graph = {}))[soul] = (cat.node || (cat.node = {_:{}})))._['#'] = soul);\n\t\t\t\t\t\tdelete as.wait[id];\n\t\t\t\t\t\tcat.wait && setTimeout.each(cat.wait, function(cb){ cb && cb() });\n\t\t\t\t\t\tas.ran(as);\n\t\t\t\t\t};\n\t\t\t\t\t// ---------------\n\t\t\t\t}\n\t\t\t\tif(!to.length){ return as.ran(as) }\n\t\t\t\tas.turn(walk);\n\t\t\t}());\n\t\t\treturn gun;\n\t\t}\n\n\t\tfunction stun(as, id){\n\t\t\tif(!id){ return } id = (id._||'').id||id;\n\t\t\tvar run = as.root.stun || (as.root.stun = {on: Gun.on}), test = {}, tmp;\n\t\t\tas.stun || (as.stun = run.on('stun', function(){ }));\n\t\t\tif(tmp = run.on(''+id)){ tmp.the.last.next(test) }\n\t\t\tif(test.run >= as.run){ return }\n\t\t\trun.on(''+id, function(test){\n\t\t\t\tif(as.stun.end){\n\t\t\t\t\tthis.off();\n\t\t\t\t\tthis.to.next(test);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttest.run = test.run || as.run;\n\t\t\t\ttest.stun = test.stun || as.stun; return;\n\t\t\t\tif(this.to.to){\n\t\t\t\t\tthis.the.last.next(test);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttest.stun = as.stun;\n\t\t\t});\n\t\t}\n\n\t\tfunction ran(as){\n\t\t\tif(as.err){ ran.end(as.stun, as.root); return } // move log handle here.\n\t\t\tif(as.todo.length || as.end || !Object.empty(as.wait)){ return } as.end = 1;\n\t\t\t//(as.retry = function(){ as.acks = 0;\n\t\t\tvar cat = (as.$.back(-1)._), root = cat.root, ask = cat.ask(function(ack){\n\t\t\t\troot.on('ack', ack);\n\t\t\t\tif(ack.err && !ack.lack){ Gun.log(ack) }\n\t\t\t\tif(++acks > (as.acks || 0)){ this.off() } // Adjustable ACKs! Only 1 by default.\n\t\t\t\tif(!as.ack){ return }\n\t\t\t\tas.ack(ack, this);\n\t\t\t}, as.opt), acks = 0, stun = as.stun, tmp;\n\t\t\t(tmp = function(){ // this is not official yet, but quick solution to hack in for now.\n\t\t\t\tif(!stun){ return }\n\t\t\t\tran.end(stun, root);\n\t\t\t\tsetTimeout.each(Object.keys(stun = stun.add||''), function(cb){ if(cb = stun[cb]){cb()} }); // resume the stunned reads // Any perf reasons to CPU schedule this .keys( ?\n\t\t\t}).hatch = tmp; // this is not official yet ^\n\t\t\t//console.log(1, \"PUT\", as.run, as.graph);\n\t\t\tif(as.ack && !as.ok){ as.ok = as.acks || 9 } // TODO: In future! Remove this! This is just old API support.\n\t\t\t(as.via._).on('out', {put: as.out = as.graph, ok: as.ok && {'@': as.ok+1}, opt: as.opt, '#': ask, _: tmp});\n\t\t\t//})();\n\t\t}; ran.end = function(stun,root){\n\t\t\tstun.end = noop; // like with the earlier id, cheaper to make this flag a function so below callbacks do not have to do an extra type check.\n\t\t\tif(stun.the.to === stun && stun === stun.the.last){ delete root.stun }\n\t\t\tstun.off();\n\t\t}; ran.err = function(as, err){\n\t\t\t(as.ack||noop).call(as, as.out = { err: as.err = Gun.log(err) });\n\t\t\tas.ran(as);\n\t\t}\n\n\t\tfunction get(as){\n\t\t\tvar at = as.via._, tmp;\n\t\t\tas.via = as.via.back(function(at){\n\t\t\t\tif(at.soul || !at.get){ return at.$ }\n\t\t\t\ttmp = as.data; (as.data = {})[at.get] = tmp;\n\t\t\t});\n\t\t\tif(!as.via || !as.via._.soul){\n\t\t\t\tas.via = at.root.$.get(((as.data||'')._||'')['#'] || at.$.back('opt.uuid')())\n\t\t\t}\n\t\t\tas.via.put(as.data, as.ack, as);\n\t\t\t\n\n\t\t\treturn;\n\t\t\tif(at.get && at.back.soul){\n\t\t\t\ttmp = as.data;\n\t\t\t\tas.via = at.back.$;\n\t\t\t\t(as.data = {})[at.get] = tmp; \n\t\t\t\tas.via.put(as.data, as.ack, as);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfunction check(d, tmp){ return ((d && (tmp = d.constructor) && tmp.name) || typeof d) }\n\n\t\tvar u, empty = {}, noop = function(){}, turn = setTimeout.turn, valid = Gun.valid, state_ify = Gun.state.ify;\n\t\tvar iife = function(fn,as){fn.call(as||empty)}\n\t})(USE, './put');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./root');\n\t\tUSE('./chain');\n\t\tUSE('./back');\n\t\tUSE('./put');\n\t\tUSE('./get');\n\t\tmodule.exports = Gun;\n\t})(USE, './index');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./index');\n\t\tGun.chain.on = function(tag, arg, eas, as){ // don't rewrite!\n\t\t\tvar gun = this, cat = gun._, root = cat.root, act, off, id, tmp;\n\t\t\tif(typeof tag === 'string'){\n\t\t\t\tif(!arg){ return cat.on(tag) }\n\t\t\t\tact = cat.on(tag, arg, eas || cat, as);\n\t\t\t\tif(eas && eas.$){\n\t\t\t\t\t(eas.subs || (eas.subs = [])).push(act);\n\t\t\t\t}\n\t\t\t\treturn gun;\n\t\t\t}\n\t\t\tvar opt = arg;\n\t\t\t(opt = (true === opt)? {change: true} : opt || {}).not = 1; opt.on = 1;\n\t\t\t//opt.at = cat;\n\t\t\t//opt.ok = tag;\n\t\t\t//opt.last = {};\n\t\t\tvar wait = {}; // can we assign this to the at instead, like in once?\n\t\t\tgun.get(tag, opt);\n\t\t\t/*gun.get(function on(data,key,msg,eve){ var $ = this;\n\t\t\t\tif(tmp = root.hatch){ // quick hack!\n\t\t\t\t\tif(wait[$._.id]){ return } wait[$._.id] = 1;\n\t\t\t\t\ttmp.push(function(){on.call($, data,key,msg,eve)});\n\t\t\t\t\treturn;\n\t\t\t\t}; wait = {}; // end quick hack.\n\t\t\t\ttag.call($, data,key,msg,eve);\n\t\t\t}, opt); // TODO: PERF! Event listener leak!!!?*/\n\t\t\t/*\n\t\t\tfunction one(msg, eve){\n\t\t\t\tif(one.stun){ return }\n\t\t\t\tvar at = msg.$._, data = at.put, tmp;\n\t\t\t\tif(tmp = at.link){ data = root.$.get(tmp)._.put }\n\t\t\t\tif(opt.not===u && u === data){ return }\n\t\t\t\tif(opt.stun===u && (tmp = root.stun) && (tmp = tmp[at.id] || tmp[at.back.id]) && !tmp.end){ // Remember! If you port this into `.get(cb` make sure you allow stun:0 skip option for `.put(`.\n\t\t\t\t\ttmp[id] = function(){one(msg,eve)};\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//tmp = one.wait || (one.wait = {}); console.log(tmp[at.id] === ''); if(tmp[at.id] !== ''){ tmp[at.id] = tmp[at.id] || setTimeout(function(){tmp[at.id]='';one(msg,eve)},1); return } delete tmp[at.id];\n\t\t\t\t// call:\n\t\t\t\tif(opt.as){\n\t\t\t\t\topt.ok.call(opt.as, msg, eve || one);\n\t\t\t\t} else {\n\t\t\t\t\topt.ok.call(at.$, data, msg.get || at.get, msg, eve || one);\n\t\t\t\t}\n\t\t\t};\n\t\t\tone.at = cat;\n\t\t\t(cat.act||(cat.act={}))[id = String.random(7)] = one;\n\t\t\tone.off = function(){ one.stun = 1; if(!cat.act){ return } delete cat.act[id] }\n\t\t\tcat.on('out', {get: {}});*/\n\t\t\treturn gun;\n\t\t}\n\t\t// Rules:\n\t\t// 1. If cached, should be fast, but not read while write.\n\t\t// 2. Should not retrigger other listeners, should get triggered even if nothing found.\n\t\t// 3. If the same callback passed to many different once chains, each should resolve - an unsubscribe from the same callback should not effect the state of the other resolving chains, if you do want to cancel them all early you should mutate the callback itself with a flag & check for it at top of callback\n\t\tGun.chain.once = function(cb, opt){ opt = opt || {}; // avoid rewriting\n\t\t\tif(!cb){ return none(this,opt) }\n\t\t\tvar gun = this, cat = gun._, root = cat.root, data = cat.put, id = String.random(7), one, tmp;\n\t\t\tgun.get(function(data,key,msg,eve){\n\t\t\t\tvar $ = this, at = $._, one = (at.one||(at.one={}));\n\t\t\t\tif(eve.stun){ return } if('' === one[id]){ return }\n\t\t\t\tif(true === (tmp = Gun.valid(data))){ once(); return }\n\t\t\t\tif('string' == typeof tmp){ return } // TODO: BUG? Will this always load?\n\t\t\t\tclearTimeout((cat.one||'')[id]); // clear \"not found\" since they only get set on cat.\n\t\t\t\tclearTimeout(one[id]); one[id] = setTimeout(once, opt.wait||99); // TODO: Bug? This doesn't handle plural chains.\n\t\t\t\tfunction once(f){\n\t\t\t\t\tif(!at.has && !at.soul){ at = {put: data, get: key} } // handles non-core messages.\n\t\t\t\t\tif(u === (tmp = at.put)){ tmp = ((msg.$$||'')._||'').put }\n\t\t\t\t\tif('string' == typeof Gun.valid(tmp)){\n\t\t\t\t\t\ttmp = root.$.get(tmp)._.put;\n\t\t\t\t\t\tif(tmp === u && !f){\n\t\t\t\t\t\t\tone[id] = setTimeout(function(){ once(1) }, opt.wait||99); // TODO: Quick fix. Maybe use ack count for more predictable control?\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//console.log(\"AND VANISHED\", data);\n\t\t\t\t\tif(eve.stun){ return } if('' === one[id]){ return } one[id] = '';\n\t\t\t\t\tif(cat.soul || cat.has){ eve.off() } // TODO: Plural chains? // else { ?.off() } // better than one check?\n\t\t\t\t\tcb.call($, tmp, at.get);\n\t\t\t\t\tclearTimeout(one[id]); // clear \"not found\" since they only get set on cat. // TODO: This was hackily added, is it necessary or important? Probably not, in future try removing this. Was added just as a safety for the `&& !f` check.\n\t\t\t\t};\n\t\t\t}, {on: 1});\n\t\t\treturn gun;\n\t\t}\n\t\tfunction none(gun,opt,chain){\n\t\t\tGun.log.once(\"valonce\", \"Chainable val is experimental, its behavior and API may change moving forward. Please play with it and report bugs and ideas on how to improve it.\");\n\t\t\t(chain = gun.chain())._.nix = gun.once(function(data, key){ chain._.on('in', this._) });\n\t\t\tchain._.lex = gun._.lex; // TODO: Better approach in future? This is quick for now.\n\t\t\treturn chain;\n\t\t}\n\n\t\tGun.chain.off = function(){\n\t\t\t// make off more aggressive. Warning, it might backfire!\n\t\t\tvar gun = this, at = gun._, tmp;\n\t\t\tvar cat = at.back;\n\t\t\tif(!cat){ return }\n\t\t\tat.ack = 0; // so can resubscribe.\n\t\t\tif(tmp = cat.next){\n\t\t\t\tif(tmp[at.get]){\n\t\t\t\t\tdelete tmp[at.get];\n\t\t\t\t} else {\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO: delete cat.one[map.id]?\n\t\t\tif (tmp = cat.any) {\n\t\t\t\tdelete cat.any;\n\t\t\t\tcat.any = {};\n\t\t\t}\n\t\t\tif(tmp = cat.ask){\n\t\t\t\tdelete tmp[at.get];\n\t\t\t}\n\t\t\tif(tmp = cat.put){\n\t\t\t\tdelete tmp[at.get];\n\t\t\t}\n\t\t\tif(tmp = at.soul){\n\t\t\t\tdelete cat.root.graph[tmp];\n\t\t\t}\n\t\t\tif(tmp = at.map){\n\t\t\t\tObject.keys(tmp).forEach(function(i,at){ at = tmp[i]; //obj_map(tmp, function(at){\n\t\t\t\t\tif(at.link){\n\t\t\t\t\t\tcat.root.$.get(at.link).off();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif(tmp = at.next){\n\t\t\t\tObject.keys(tmp).forEach(function(i,neat){ neat = tmp[i]; //obj_map(tmp, function(neat){\n\t\t\t\t\tneat.$.off();\n\t\t\t\t});\n\t\t\t}\n\t\t\tat.on('off', {});\n\t\t\treturn gun;\n\t\t}\n\t\tvar empty = {}, noop = function(){}, u;\n\t})(USE, './on');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./index'), next = Gun.chain.get.next;\n\t\tGun.chain.get.next = function(gun, lex){ var tmp;\n\t\t\tif(!Object.plain(lex)){ return (next||noop)(gun, lex) }\n\t\t\tif(tmp = ((tmp = lex['#'])||'')['='] || tmp){ return gun.get(tmp) }\n\t\t\t(tmp = gun.chain()._).lex = lex; // LEX!\n\t\t\tgun.on('in', function(eve){\n\t\t\t\tif(String.match(eve.get|| (eve.put||'')['.'], lex['.'] || lex['#'] || lex)){\n\t\t\t\t\ttmp.on('in', eve);\n\t\t\t\t}\n\t\t\t\tthis.to.next(eve);\n\t\t\t});\n\t\t\treturn tmp.$;\n\t\t}\n\t\tGun.chain.map = function(cb, opt, t){\n\t\t\tvar gun = this, cat = gun._, lex, chain;\n\t\t\tif(Object.plain(cb)){ lex = cb['.']? cb : {'.': cb}; cb = u }\n\t\t\tif(!cb){\n\t\t\t\tif(chain = cat.each){ return chain }\n\t\t\t\t(cat.each = chain = gun.chain())._.lex = lex || chain._.lex || cat.lex;\n\t\t\t\tchain._.nix = gun.back('nix');\n\t\t\t\tgun.on('in', map, chain._);\n\t\t\t\treturn chain;\n\t\t\t}\n\t\t\tGun.log.once(\"mapfn\", \"Map functions are experimental, their behavior and API may change moving forward. Please play with it and report bugs and ideas on how to improve it.\");\n\t\t\tchain = gun.chain();\n\t\t\tgun.map().on(function(data, key, msg, eve){\n\t\t\t\tvar next = (cb||noop).call(this, data, key, msg, eve);\n\t\t\t\tif(u === next){ return }\n\t\t\t\tif(data === next){ return chain._.on('in', msg) }\n\t\t\t\tif(Gun.is(next)){ return chain._.on('in', next._) }\n\t\t\t\tvar tmp = {}; Object.keys(msg.put).forEach(function(k){ tmp[k] = msg.put[k] }, tmp); tmp['='] = next; \n\t\t\t\tchain._.on('in', {get: key, put: tmp});\n\t\t\t});\n\t\t\treturn chain;\n\t\t}\n\t\tfunction map(msg){ this.to.next(msg);\n\t\t\tvar cat = this.as, gun = msg.$, at = gun._, put = msg.put, tmp;\n\t\t\tif(!at.soul && !msg.$$){ return } // this line took hundreds of tries to figure out. It only works if core checks to filter out above chains during link tho. This says \"only bother to map on a node\" for this layer of the chain. If something is not a node, map should not work.\n\t\t\tif((tmp = cat.lex) && !String.match(msg.get|| (put||'')['.'], tmp['.'] || tmp['#'] || tmp)){ return }\n\t\t\tGun.on.link(msg, cat);\n\t\t}\n\t\tvar noop = function(){}, event = {stun: noop, off: noop}, u;\n\t})(USE, './map');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./index');\n\t\tGun.chain.set = function(item, cb, opt){\n\t\t\tvar gun = this, root = gun.back(-1), soul, tmp;\n\t\t\tcb = cb || function(){};\n\t\t\topt = opt || {}; opt.item = opt.item || item;\n\t\t\tif(soul = ((item||'')._||'')['#']){ (item = {})['#'] = soul } // check if node, make link.\n\t\t\tif('string' == typeof (tmp = Gun.valid(item))){ return gun.get(soul = tmp).put(item, cb, opt) } // check if link\n\t\t\tif(!Gun.is(item)){\n\t\t\t\tif(Object.plain(item)){\n\t\t\t\t\titem = root.get(soul = gun.back('opt.uuid')()).put(item);\n\t\t\t\t}\n\t\t\t\treturn gun.get(soul || root.back('opt.uuid')(7)).put(item, cb, opt);\n\t\t\t}\n\t\t\tgun.put(function(go){\n\t\t\t\titem.get(function(soul, o, msg){ // TODO: BUG! We no longer have this option? & go error not handled?\n\t\t\t\t\tif(!soul){ return cb.call(gun, {err: Gun.log('Only a node can be linked! Not \"' + msg.put + '\"!')}) }\n\t\t\t\t\t(tmp = {})[soul] = {'#': soul}; go(tmp);\n\t\t\t\t},true);\n\t\t\t})\n\t\t\treturn item;\n\t\t}\n\t})(USE, './set');\n\n\t;USE(function(module){\n\t\tUSE('./shim');\n\n\t\tvar noop = function(){}\n\t\tvar parse = JSON.parseAsync || function(t,cb,r){ var u, d = +new Date; try{ cb(u, JSON.parse(t,r), json.sucks(+new Date - d)) }catch(e){ cb(e) } }\n\t\tvar json = JSON.stringifyAsync || function(v,cb,r,s){ var u, d = +new Date; try{ cb(u, JSON.stringify(v,r,s), json.sucks(+new Date - d)) }catch(e){ cb(e) } }\n\t\tjson.sucks = function(d){ if(d > 99){ console.log(\"Warning: JSON blocking CPU detected. Add `gun/lib/yson.js` to fix.\"); json.sucks = noop } }\n\n\t\tfunction Mesh(root){\n\t\t\tvar mesh = function(){};\n\t\t\tvar opt = root.opt || {};\n\t\t\topt.log = opt.log || console.log;\n\t\t\topt.gap = opt.gap || opt.wait || 0;\n\t\t\topt.max = opt.max || (opt.memory? (opt.memory * 999 * 999) : 300000000) * 0.3;\n\t\t\topt.pack = opt.pack || (opt.max * 0.01 * 0.01);\n\t\t\topt.puff = opt.puff || 9; // IDEA: do a start/end benchmark, divide ops/result.\n\t\t\tvar puff = setTimeout.turn || setTimeout;\n\n\t\t\tvar dup = root.dup, dup_check = dup.check, dup_track = dup.track;\n\n\t\t\tvar ST = +new Date, LT = ST;\n\n\t\t\tvar hear = mesh.hear = function(raw, peer){\n\t\t\t\tif(!raw){ return }\n\t\t\t\tif(opt.max <= raw.length){ return mesh.say({dam: '!', err: \"Message too big!\"}, peer) }\n\t\t\t\tif(mesh === this){\n\t\t\t\t\t/*if('string' == typeof raw){ try{\n\t\t\t\t\t\tvar stat = console.STAT || {};\n\t\t\t\t\t\t//console.log('HEAR:', peer.id, (raw||'').slice(0,250), ((raw||'').length / 1024 / 1024).toFixed(4));\n\t\t\t\t\t\t\n\t\t\t\t\t\t//console.log(setTimeout.turn.s.length, 'stacks', parseFloat((-(LT - (LT = +new Date))/1000).toFixed(3)), 'sec', parseFloat(((LT-ST)/1000 / 60).toFixed(1)), 'up', stat.peers||0, 'peers', stat.has||0, 'has', stat.memhused||0, stat.memused||0, stat.memax||0, 'heap mem max');\n\t\t\t\t\t}catch(e){ console.log('DBG err', e) }}*/\n\t\t\t\t\thear.d += raw.length||0 ; ++hear.c } // STATS!\n\t\t\t\tvar S = peer.SH = +new Date;\n\t\t\t\tvar tmp = raw[0], msg;\n\t\t\t\t//raw && raw.slice && console.log(\"hear:\", ((peer.wire||'').headers||'').origin, raw.length, raw.slice && raw.slice(0,50)); //tc-iamunique-tc-package-ds1\n\t\t\t\tif('[' === tmp){\n\t\t\t\t\tparse(raw, function(err, msg){\n\t\t\t\t\t\tif(err || !msg){ return mesh.say({dam: '!', err: \"DAM JSON parse error.\"}, peer) }\n\t\t\t\t\t\tconsole.STAT && console.STAT(+new Date, msg.length, '# on hear batch');\n\t\t\t\t\t\tvar P = opt.puff;\n\t\t\t\t\t\t(function go(){\n\t\t\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\t\t\tvar i = 0, m; while(i < P && (m = msg[i++])){ mesh.hear(m, peer) }\n\t\t\t\t\t\t\tmsg = msg.slice(i); // slicing after is faster than shifting during.\n\t\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'hear loop');\n\t\t\t\t\t\t\tflush(peer); // force send all synchronously batched acks.\n\t\t\t\t\t\t\tif(!msg.length){ return }\n\t\t\t\t\t\t\tpuff(go, 0);\n\t\t\t\t\t\t}());\n\t\t\t\t\t});\n\t\t\t\t\traw = ''; // \n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif('{' === tmp || ((raw['#'] || Object.plain(raw)) && (msg = raw))){\n\t\t\t\t\tif(msg){ return hear.one(msg, peer, S) }\n\t\t\t\t\tparse(raw, function(err, msg){\n\t\t\t\t\t\tif(err || !msg){ return mesh.say({dam: '!', err: \"DAM JSON parse error.\"}, peer) }\n\t\t\t\t\t\thear.one(msg, peer, S);\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\thear.one = function(msg, peer, S){ // S here is temporary! Undo.\n\t\t\t\tvar id, hash, tmp, ash, DBG;\n\t\t\t\tif(msg.DBG){ msg.DBG = DBG = {DBG: msg.DBG} }\n\t\t\t\tDBG && (DBG.h = S);\n\t\t\t\tDBG && (DBG.hp = +new Date);\n\t\t\t\tif(!(id = msg['#'])){ id = msg['#'] = String.random(9) }\n\t\t\t\tif(tmp = dup_check(id)){ return }\n\t\t\t\t// DAM logic:\n\t\t\t\tif(!(hash = msg['##']) && false && 0){} // disable hashing for now // TODO: impose warning/penalty instead (?)\n\t\t\t\tif(hash && (tmp = msg['@'] || (msg.get && id)) && dup.check(ash = tmp+hash)){ return } // Imagine A <-> B <=> (C & D), C & D reply with same ACK but have different IDs, B can use hash to dedup. Or if a GET has a hash already, we shouldn't ACK if same.\n\t\t\t\t(msg._ = function(){}).via = mesh.leap = peer;\n\t\t\t\tif((tmp = msg['><']) && 'string' == typeof tmp){ tmp.slice(0,99).split(',').forEach(function(k){ this[k] = 1 }, (msg._).yo = {}) } // Peers already sent to, do not resend.\n\t\t\t\t// DAM ^\n\t\t\t\tif(tmp = msg.dam){\n\t\t\t\t\tif(tmp = mesh.hear[tmp]){\n\t\t\t\t\t\ttmp(msg, peer, root);\n\t\t\t\t\t}\n\t\t\t\t\tdup_track(id);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(tmp = msg.ok){ msg._.near = tmp['/'] }\n\t\t\t\tvar S = +new Date;\n\t\t\t\tDBG && (DBG.is = S); peer.SI = id;\n\t\t\t\tdup_track.ed = function(d){\n\t\t\t\t\tif(id !== d){ return }\n\t\t\t\t\tdup_track.ed = 0;\n\t\t\t\t\tif(!(d = dup.s[id])){ return }\n\t\t\t\t\td.via = peer;\n\t\t\t\t\tif(msg.get){ d.it = msg }\n\t\t\t\t}\n\t\t\t\troot.on('in', mesh.last = msg);\n\t\t\t\tDBG && (DBG.hd = +new Date);\n\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, msg.get? 'msg get' : msg.put? 'msg put' : 'msg');\n\t\t\t\tdup_track(id); // in case 'in' does not call track.\n\t\t\t\tif(ash){ dup_track(ash) } //dup.track(tmp+hash, true).it = it(msg);\n\t\t\t\tmesh.leap = mesh.last = null; // warning! mesh.leap could be buggy.\n\t\t\t}\n\t\t\tvar tomap = function(k,i,m){m(k,true)};\n\t\t\thear.c = hear.d = 0;\n\n\t\t\t;(function(){\n\t\t\t\tvar SMIA = 0;\n\t\t\t\tvar loop;\n\t\t\t\tmesh.hash = function(msg, peer){ var h, s, t;\n\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\tjson(msg.put, function hash(err, text){\n\t\t\t\t\t\tvar ss = (s || (s = t = text||'')).slice(0, 32768); // 1024 * 32\n\t\t\t\t\t  h = String.hash(ss, h); s = s.slice(32768);\n\t\t\t\t\t  if(s){ puff(hash, 0); return }\n\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'say json+hash');\n\t\t\t\t\t  msg._.$put = t;\n\t\t\t\t\t  msg['##'] = h;\n\t\t\t\t\t  mesh.say(msg, peer);\n\t\t\t\t\t  delete msg._.$put;\n\t\t\t\t\t}, sort);\n\t\t\t\t}\n\t\t\t\tfunction sort(k, v){ var tmp;\n\t\t\t\t\tif(!(v instanceof Object)){ return v }\n\t\t\t\t\tObject.keys(v).sort().forEach(sorta, {to: tmp = {}, on: v});\n\t\t\t\t\treturn tmp;\n\t\t\t\t} function sorta(k){ this.to[k] = this.on[k] }\n\n\t\t\t\tvar say = mesh.say = function(msg, peer){ var tmp;\n\t\t\t\t\tif((tmp = this) && (tmp = tmp.to) && tmp.next){ tmp.next(msg) } // compatible with middleware adapters.\n\t\t\t\t\tif(!msg){ return false }\n\t\t\t\t\tvar id, hash, raw, ack = msg['@'];\n//if(opt.super && (!ack || !msg.put)){ return } // TODO: MANHATTAN STUB //OBVIOUSLY BUG! But squelch relay. // :( get only is 100%+ CPU usage :(\n\t\t\t\t\tvar meta = msg._||(msg._=function(){});\n\t\t\t\t\tvar DBG = msg.DBG, S = +new Date; meta.y = meta.y || S; if(!peer){ DBG && (DBG.y = S) }\n\t\t\t\t\tif(!(id = msg['#'])){ id = msg['#'] = String.random(9) }\n\t\t\t\t\t!loop && dup_track(id);//.it = it(msg); // track for 9 seconds, default. Earth<->Mars would need more! // always track, maybe move this to the 'after' logic if we split function.\n\t\t\t\t\t//if(msg.put && (msg.err || (dup.s[id]||'').err)){ return false } // TODO: in theory we should not be able to stun a message, but for now going to check if it can help network performance preventing invalid data to relay.\n\t\t\t\t\tif(!(hash = msg['##']) && u !== msg.put && !meta.via && ack){ mesh.hash(msg, peer); return } // TODO: Should broadcasts be hashed?\n\t\t\t\t\tif(!peer && ack){ peer = ((tmp = dup.s[ack]) && (tmp.via || ((tmp = tmp.it) && (tmp = tmp._) && tmp.via))) || ((tmp = mesh.last) && ack === tmp['#'] && mesh.leap) } // warning! mesh.leap could be buggy! mesh last check reduces this. // TODO: CLEAN UP THIS LINE NOW? `.it` should be reliable.\n\t\t\t\t\tif(!peer && ack){ // still no peer, then ack daisy chain 'tunnel' got lost.\n\t\t\t\t\t\tif(dup.s[ack]){ return } // in dups but no peer hints that this was ack to ourself, ignore.\n\t\t\t\t\t\tconsole.STAT && console.STAT(+new Date, ++SMIA, 'total no peer to ack to'); // TODO: Delete this now. Dropping lost ACKs is protocol fine now.\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} // TODO: Temporary? If ack via trace has been lost, acks will go to all peers, which trashes browser bandwidth. Not relaying the ack will force sender to ask for ack again. Note, this is technically wrong for mesh behavior.\n\t\t\t\t\tif(ack && !msg.put && !hash && ((dup.s[ack]||'').it||'')['##']){ return false } // If we're saying 'not found' but a relay had data, do not bother sending our not found. // Is this correct, return false? // NOTE: ADD PANIC TEST FOR THIS!\n\t\t\t\t\tif(!peer && mesh.way){ return mesh.way(msg) }\n\t\t\t\t\tDBG && (DBG.yh = +new Date);\n\t\t\t\t\tif(!(raw = meta.raw)){ mesh.raw(msg, peer); return }\n\t\t\t\t\tDBG && (DBG.yr = +new Date);\n\t\t\t\t\tif(!peer || !peer.id){\n\t\t\t\t\t\tif(!Object.plain(peer || opt.peers)){ return false }\n\t\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\t\tvar P = opt.puff, ps = opt.peers, pl = Object.keys(peer || opt.peers || {}); // TODO: .keys( is slow\n\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'peer keys');\n\t\t\t\t\t\t;(function go(){\n\t\t\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\t\t\t//Type.obj.map(peer || opt.peers, each); // in case peer is a peer list.\n\t\t\t\t\t\t\tloop = 1; var wr = meta.raw; meta.raw = raw; // quick perf hack\n\t\t\t\t\t\t\tvar i = 0, p; while(i < 9 && (p = (pl||'')[i++])){\n\t\t\t\t\t\t\t\tif(!(p = ps[p] || (peer||'')[p])){ continue }\n\t\t\t\t\t\t\t\tmesh.say(msg, p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmeta.raw = wr; loop = 0;\n\t\t\t\t\t\t\tpl = pl.slice(i); // slicing after is faster than shifting during.\n\t\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'say loop');\n\t\t\t\t\t\t\tif(!pl.length){ return }\n\t\t\t\t\t\t\tpuff(go, 0);\n\t\t\t\t\t\t\tack && dup_track(ack); // keep for later\n\t\t\t\t\t\t}());\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: PERF: consider splitting function here, so say loops do less work.\n\t\t\t\t\tif(!peer.wire && mesh.wire){ mesh.wire(peer) }\n\t\t\t\t\tif(id === peer.last){ return } peer.last = id;  // was it just sent?\n\t\t\t\t\tif(peer === meta.via){ return false } // don't send back to self.\n\t\t\t\t\tif((tmp = meta.yo) && (tmp[peer.url] || tmp[peer.pid] || tmp[peer.id]) /*&& !o*/){ return false }\n\t\t\t\t\tconsole.STAT && console.STAT(S, ((DBG||meta).yp = +new Date) - (meta.y || S), 'say prep');\n\t\t\t\t\t!loop && ack && dup_track(ack); // streaming long responses needs to keep alive the ack.\n\t\t\t\t\tif(peer.batch){\n\t\t\t\t\t\tpeer.tail = (tmp = peer.tail || 0) + raw.length;\n\t\t\t\t\t\tif(peer.tail <= opt.pack){\n\t\t\t\t\t\t\tpeer.batch += (tmp?',':'')+raw;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflush(peer);\n\t\t\t\t\t}\n\t\t\t\t\tpeer.batch = '['; // Prevents double JSON!\n\t\t\t\t\tvar ST = +new Date;\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\tconsole.STAT && console.STAT(ST, +new Date - ST, '0ms TO');\n\t\t\t\t\t\tflush(peer);\n\t\t\t\t\t}, opt.gap); // TODO: queuing/batching might be bad for low-latency video game performance! Allow opt out?\n\t\t\t\t\tsend(raw, peer);\n\t\t\t\t\tconsole.STAT && (ack === peer.SI) && console.STAT(S, +new Date - peer.SH, 'say ack');\n\t\t\t\t}\n\t\t\t\tmesh.say.c = mesh.say.d = 0;\n\t\t\t\t// TODO: this caused a out-of-memory crash!\n\t\t\t\tmesh.raw = function(msg, peer){ // TODO: Clean this up / delete it / move logic out!\n\t\t\t\t\tif(!msg){ return '' }\n\t\t\t\t\tvar meta = (msg._) || {}, put, tmp;\n\t\t\t\t\tif(tmp = meta.raw){ return tmp }\n\t\t\t\t\tif('string' == typeof msg){ return msg }\n\t\t\t\t\tvar hash = msg['##'], ack = msg['@'];\n\t\t\t\t\tif(hash && ack){\n\t\t\t\t\t\tif(!meta.via && dup_check(ack+hash)){ return false } // for our own out messages, memory & storage may ack the same thing, so dedup that. Tho if via another peer, we already tracked it upon hearing, so this will always trigger false positives, so don't do that!\n\t\t\t\t\t\tif(tmp = (dup.s[ack]||'').it){\n\t\t\t\t\t\t\tif(hash === tmp['##']){ return false } // if ask has a matching hash, acking is optional.\n\t\t\t\t\t\t\tif(!tmp['##']){ tmp['##'] = hash } // if none, add our hash to ask so anyone we relay to can dedup. // NOTE: May only check against 1st ack chunk, 2nd+ won't know and still stream back to relaying peers which may then dedup. Any way to fix this wasted bandwidth? I guess force rate limiting breaking change, that asking peer has to ask for next lexical chunk.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!msg.dam && !msg['@']){\n\t\t\t\t\t\tvar i = 0, to = []; tmp = opt.peers;\n\t\t\t\t\t\tfor(var k in tmp){ var p = tmp[k]; // TODO: Make it up peers instead!\n\t\t\t\t\t\t\tto.push(p.url || p.pid || p.id);\n\t\t\t\t\t\t\tif(++i > 6){ break }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i > 1){ msg['><'] = to.join() } // TODO: BUG! This gets set regardless of peers sent to! Detect?\n\t\t\t\t\t}\n\t\t\t\t\tif(msg.put && (tmp = msg.ok)){ msg.ok = {'@':(tmp['@']||1)-1, '/': (tmp['/']==msg._.near)? mesh.near : tmp['/']}; }\n\t\t\t\t\tif(put = meta.$put){\n\t\t\t\t\t\ttmp = {}; Object.keys(msg).forEach(function(k){ tmp[k] = msg[k] });\n\t\t\t\t\t\ttmp.put = ':])([:';\n\t\t\t\t\t\tjson(tmp, function(err, raw){\n\t\t\t\t\t\t\tif(err){ return } // TODO: Handle!!\n\t\t\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\t\t\ttmp = raw.indexOf('\"put\":\":])([:\"');\n\t\t\t\t\t\t\tres(u, raw = raw.slice(0, tmp+6) + put + raw.slice(tmp + 14));\n\t\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'say slice');\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tjson(msg, res);\n\t\t\t\t\tfunction res(err, raw){\n\t\t\t\t\t\tif(err){ return } // TODO: Handle!!\n\t\t\t\t\t\tmeta.raw = raw; //if(meta && (raw||'').length < (999 * 99)){ meta.raw = raw } // HNPERF: If string too big, don't keep in memory.\n\t\t\t\t\t\tmesh.say(msg, peer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}());\n\n\t\t\tfunction flush(peer){\n\t\t\t\tvar tmp = peer.batch, t = 'string' == typeof tmp, l;\n\t\t\t\tif(t){ tmp += ']' }// TODO: Prevent double JSON!\n\t\t\t\tpeer.batch = peer.tail = null;\n\t\t\t\tif(!tmp){ return }\n\t\t\t\tif(t? 3 > tmp.length : !tmp.length){ return } // TODO: ^\n\t\t\t\tif(!t){try{tmp = (1 === tmp.length? tmp[0] : JSON.stringify(tmp));\n\t\t\t\t}catch(e){return opt.log('DAM JSON stringify error', e)}}\n\t\t\t\tif(!tmp){ return }\n\t\t\t\tsend(tmp, peer);\n\t\t\t}\n\t\t\t// for now - find better place later.\n\t\t\tfunction send(raw, peer){ try{\n\t\t\t\tvar wire = peer.wire;\n\t\t\t\tif(peer.say){\n\t\t\t\t\tpeer.say(raw);\n\t\t\t\t} else\n\t\t\t\tif(wire.send){\n\t\t\t\t\twire.send(raw);\n\t\t\t\t}\n\t\t\t\tmesh.say.d += raw.length||0; ++mesh.say.c; // STATS!\n\t\t\t}catch(e){\n\t\t\t\t(peer.queue = peer.queue || []).push(raw);\n\t\t\t}}\n\n\t\t\tmesh.near = 0;\n\t\t\tmesh.hi = function(peer){\n\t\t\t\tvar wire = peer.wire, tmp;\n\t\t\t\tif(!wire){ mesh.wire((peer.length && {url: peer, id: peer}) || peer); return }\n\t\t\t\tif(peer.id){\n\t\t\t\t\topt.peers[peer.url || peer.id] = peer;\n\t\t\t\t} else {\n\t\t\t\t\ttmp = peer.id = peer.id || peer.url || String.random(9);\n\t\t\t\t\tmesh.say({dam: '?', pid: root.opt.pid}, opt.peers[tmp] = peer);\n\t\t\t\t\tdelete dup.s[peer.last]; // IMPORTANT: see https://gun.eco/docs/DAM#self\n\t\t\t\t}\n\t\t\t\tif(!peer.met){\n\t\t\t\t\tmesh.near++;\n\t\t\t\t\tpeer.met = +(new Date);\n\t\t\t\t\troot.on('hi', peer)\n\t\t\t\t}\n\t\t\t\t// @rogowski I need this here by default for now to fix go1dfish's bug\n\t\t\t\ttmp = peer.queue; peer.queue = [];\n\t\t\t\tsetTimeout.each(tmp||[],function(msg){\n\t\t\t\t\tsend(msg, peer);\n\t\t\t\t},0,9);\n\t\t\t\t//Type.obj.native && Type.obj.native(); // dirty place to check if other JS polluted.\n\t\t\t}\n\t\t\tmesh.bye = function(peer){\n\t\t\t\tpeer.met && --mesh.near;\n\t\t\t\tdelete peer.met;\n\t\t\t\troot.on('bye', peer);\n\t\t\t\tvar tmp = +(new Date); tmp = (tmp - (peer.met||tmp));\n\t\t\t\tmesh.bye.time = ((mesh.bye.time || tmp) + tmp) / 2;\n\t\t\t}\n\t\t\tmesh.hear['!'] = function(msg, peer){ opt.log('Error:', msg.err) }\n\t\t\tmesh.hear['?'] = function(msg, peer){\n\t\t\t\tif(msg.pid){\n\t\t\t\t\tif(!peer.pid){ peer.pid = msg.pid }\n\t\t\t\t\tif(msg['@']){ return }\n\t\t\t\t}\n\t\t\t\tmesh.say({dam: '?', pid: opt.pid, '@': msg['#']}, peer);\n\t\t\t\tdelete dup.s[peer.last]; // IMPORTANT: see https://gun.eco/docs/DAM#self\n\t\t\t}\n\t\t\tmesh.hear['mob'] = function(msg, peer){ // NOTE: AXE will overload this with better logic.\n\t\t\t\tif(!msg.peers){ return }\n\t\t\t\tvar peers = Object.keys(msg.peers), one = peers[(Math.random()*peers.length) >> 0];\n\t\t\t\tif(!one){ return }\n\t\t\t\tmesh.bye(peer);\n\t\t\t\tmesh.hi(one);\n\t\t\t}\n\n\t\t\troot.on('create', function(root){\n\t\t\t\troot.opt.pid = root.opt.pid || String.random(9);\n\t\t\t\tthis.to.next(root);\n\t\t\t\troot.on('out', mesh.say);\n\t\t\t});\n\n\t\t\troot.on('bye', function(peer, tmp){\n\t\t\t\tpeer = opt.peers[peer.id || peer] || peer;\n\t\t\t\tthis.to.next(peer);\n\t\t\t\tpeer.bye? peer.bye() : (tmp = peer.wire) && tmp.close && tmp.close();\n\t\t\t\tdelete opt.peers[peer.id];\n\t\t\t\tpeer.wire = null;\n\t\t\t});\n\n\t\t\tvar gets = {};\n\t\t\troot.on('bye', function(peer, tmp){ this.to.next(peer);\n\t\t\t\tif(tmp = console.STAT){ tmp.peers = mesh.near; }\n\t\t\t\tif(!(tmp = peer.url)){ return } gets[tmp] = true;\n\t\t\t\tsetTimeout(function(){ delete gets[tmp] },opt.lack || 9000);\n\t\t\t});\n\t\t\troot.on('hi', function(peer, tmp){ this.to.next(peer);\n\t\t\t\tif(tmp = console.STAT){ tmp.peers = mesh.near }\n\t\t\t\tif(opt.super){ return } // temporary (?) until we have better fix/solution?\n\t\t\t\tvar souls = Object.keys(root.next||''); // TODO: .keys( is slow\n\t\t\t\tif(souls.length > 9999 && !console.SUBS){ console.log(console.SUBS = \"Warning: You have more than 10K live GETs, which might use more bandwidth than your screen can show - consider `.off()`.\") }\n\t\t\t\tsetTimeout.each(souls, function(soul){ var node = root.next[soul];\n\t\t\t\t\tif(opt.super || (node.ask||'')['']){ mesh.say({get: {'#': soul}}, peer); return }\n\t\t\t\t\tsetTimeout.each(Object.keys(node.ask||''), function(key){ if(!key){ return }\n\t\t\t\t\t\t// is the lack of ## a !onion hint?\n\t\t\t\t\t\tmesh.say({'##': String.hash((root.graph[soul]||'')[key]), get: {'#': soul, '.': key}}, peer);\n\t\t\t\t\t\t// TODO: Switch this so Book could route?\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn mesh;\n\t\t}\n\t  var empty = {}, ok = true, u;\n\n\t  try{ module.exports = Mesh }catch(e){}\n\n\t})(USE, './mesh');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./index');\n\t\tGun.Mesh = USE('./mesh');\n\n\t\t// TODO: resync upon reconnect online/offline\n\t\t//window.ononline = window.onoffline = function(){ console.log('online?', navigator.onLine) }\n\n\t\tGun.on('opt', function(root){\n\t\t\tthis.to.next(root);\n\t\t\tif(root.once){ return }\n\t\t\tvar opt = root.opt;\n\t\t\tif(false === opt.WebSocket){ return }\n\n\t\t\tvar env = Gun.window || {};\n\t\t\tvar websocket = opt.WebSocket || env.WebSocket || env.webkitWebSocket || env.mozWebSocket;\n\t\t\tif(!websocket){ return }\n\t\t\topt.WebSocket = websocket;\n\n\t\t\tvar mesh = opt.mesh = opt.mesh || Gun.Mesh(root);\n\n\t\t\tvar wire = mesh.wire || opt.wire;\n\t\t\tmesh.wire = opt.wire = open;\n\t\t\tfunction open(peer){ try{\n\t\t\t\tif(!peer || !peer.url){ return wire && wire(peer) }\n\t\t\t\tvar url = peer.url.replace(/^http/, 'ws');\n\t\t\t\tvar wire = peer.wire = new opt.WebSocket(url);\n\t\t\t\twire.onclose = function(){\n\t\t\t\t\treconnect(peer);\n\t\t\t\t\topt.mesh.bye(peer);\n\t\t\t\t};\n\t\t\t\twire.onerror = function(err){\n\t\t\t\t\treconnect(peer);\n\t\t\t\t};\n\t\t\t\twire.onopen = function(){\n\t\t\t\t\topt.mesh.hi(peer);\n\t\t\t\t}\n\t\t\t\twire.onmessage = function(msg){\n\t\t\t\t\tif(!msg){ return }\n\t\t\t\t\topt.mesh.hear(msg.data || msg, peer);\n\t\t\t\t};\n\t\t\t\treturn wire;\n\t\t\t}catch(e){ opt.mesh.bye(peer) }}\n\n\t\t\tsetTimeout(function(){ !opt.super && root.on('out', {dam:'hi'}) },1); // it can take a while to open a socket, so maybe no longer lazy load for perf reasons?\n\n\t\t\tvar wait = 2 * 999;\n\t\t\tfunction reconnect(peer){\n\t\t\t\tclearTimeout(peer.defer);\n\t\t\t\tif(!opt.peers[peer.url]){ return }\n\t\t\t\tif(doc && peer.retry <= 0){ return }\n\t\t\t\tpeer.retry = (peer.retry || opt.retry+1 || 60) - ((-peer.tried + (peer.tried = +new Date) < wait*4)?1:0);\n\t\t\t\tpeer.defer = setTimeout(function to(){\n\t\t\t\t\tif(doc && doc.hidden){ return setTimeout(to,wait) }\n\t\t\t\t\topen(peer);\n\t\t\t\t}, wait);\n\t\t\t}\n\t\t\tvar doc = (''+u !== typeof document) && document;\n\t\t});\n\t\tvar noop = function(){}, u;\n\t})(USE, './websocket');\n\n\t;USE(function(module){\n\t\tif(typeof Gun === 'undefined'){ return }\n\n\t\tvar noop = function(){}, store, u;\n\t\ttry{store = (Gun.window||noop).localStorage}catch(e){}\n\t\tif(!store){\n\t\t\tGun.log(\"Warning: No localStorage exists to persist data to!\");\n\t\t\tstore = {setItem: function(k,v){this[k]=v}, removeItem: function(k){delete this[k]}, getItem: function(k){return this[k]}};\n\t\t}\n\n\t\tvar parse = JSON.parseAsync || function(t,cb,r){ var u; try{ cb(u, JSON.parse(t,r)) }catch(e){ cb(e) } }\n\t\tvar json = JSON.stringifyAsync || function(v,cb,r,s){ var u; try{ cb(u, JSON.stringify(v,r,s)) }catch(e){ cb(e) } }\n\n\t\tGun.on('create', function lg(root){\n\t\t\tthis.to.next(root);\n\t\t\tvar opt = root.opt, graph = root.graph, acks = [], disk, to, size, stop;\n\t\t\tif(false === opt.localStorage){ return }\n\t\t\topt.prefix = opt.file || 'gun/';\n\t\t\ttry{ disk = lg[opt.prefix] = lg[opt.prefix] || JSON.parse(size = store.getItem(opt.prefix)) || {}; // TODO: Perf! This will block, should we care, since limited to 5MB anyways?\n\t\t\t}catch(e){ disk = lg[opt.prefix] = {}; }\n\t\t\tsize = (size||'').length;\n\n\t\t\troot.on('get', function(msg){\n\t\t\t\tthis.to.next(msg);\n\t\t\t\tvar lex = msg.get, soul, data, tmp, u;\n\t\t\t\tif(!lex || !(soul = lex['#'])){ return }\n\t\t\t\tdata = disk[soul] || u;\n\t\t\t\tif(data && (tmp = lex['.']) && !Object.plain(tmp)){ // pluck!\n\t\t\t\t\tdata = Gun.state.ify({}, tmp, Gun.state.is(data, tmp), data[tmp], soul);\n\t\t\t\t}\n\t\t\t\t//if(data){ (tmp = {})[soul] = data } // back into a graph.\n\t\t\t\t//setTimeout(function(){\n\t\t\t\tGun.on.get.ack(msg, data); //root.on('in', {'@': msg['#'], put: tmp, lS:1});// || root.$});\n\t\t\t\t//}, Math.random() * 10); // FOR TESTING PURPOSES!\n\t\t\t});\n\n\t\t\troot.on('put', function(msg){\n\t\t\t\tthis.to.next(msg); // remember to call next middleware adapter\n\t\t\t\tvar put = msg.put, soul = put['#'], key = put['.'], id = msg['#'], ok = msg.ok||'', tmp; // pull data off wire envelope\n\t\t\t\tdisk[soul] = Gun.state.ify(disk[soul], key, put['>'], put[':'], soul); // merge into disk object\n\t\t\t\tif(stop && size > (4999880)){ root.on('in', {'@': id, err: \"localStorage max!\"}); return; }\n\t\t\t\t//if(!msg['@']){ acks.push(id) } // then ack any non-ack write. // TODO: use batch id.\n\t\t\t\tif(!msg['@'] && (!msg._.via || Math.random() < (ok['@'] / ok['/']))){ acks.push(id) } // then ack any non-ack write. // TODO: use batch id.\n\t\t\t\tif(to){ return }\n\t\t\t\tto = setTimeout(flush, 9+(size / 333)); // 0.1MB = 0.3s, 5MB = 15s \n\t\t\t});\n\t\t\tfunction flush(){\n\t\t\t\tif(!acks.length && ((setTimeout.turn||'').s||'').length){ setTimeout(flush,99); return; } // defer if \"busy\" && no saves.\n\t\t\t\tvar err, ack = acks; clearTimeout(to); to = false; acks = [];\n\t\t\t\tjson(disk, function(err, tmp){\n\t\t\t\t\ttry{!err && store.setItem(opt.prefix, tmp);\n\t\t\t\t\t}catch(e){ err = stop = e || \"localStorage failure\" }\n\t\t\t\t\tif(err){\n\t\t\t\t\t\tGun.log(err + \" Consider using GUN's IndexedDB plugin for RAD for more storage space, https://gun.eco/docs/RAD#install\");\n\t\t\t\t\t\troot.on('localStorage:error', {err: err, get: opt.prefix, put: disk});\n\t\t\t\t\t}\n\t\t\t\t\tsize = tmp.length;\n\n\t\t\t\t\t//if(!err && !Object.empty(opt.peers)){ return } // only ack if there are no peers. // Switch this to probabilistic mode\n\t\t\t\t\tsetTimeout.each(ack, function(id){\n\t\t\t\t\t\troot.on('in', {'@': id, err: err, ok: 0}); // localStorage isn't reliable, so make its `ok` code be a low number.\n\t\t\t\t\t},0,99);\n\t\t\t\t})\n\t\t\t}\n\t\t\n\t\t});\n\t})(USE, './localStorage');\n\n}());\n\n/* BELOW IS TEMPORARY FOR OLD INTERNAL COMPATIBILITY, THEY ARE IMMEDIATELY DEPRECATED AND WILL BE REMOVED IN NEXT VERSION */\n;(function(){\n\tvar u;\n\tif(''+u == typeof Gun){ return }\n\tvar DEP = function(n){ console.warn(\"Warning! Deprecated internal utility will break in next version:\", n) }\n\t// Generic javascript utilities.\n\tvar Type = Gun;\n\t//Type.fns = Type.fn = {is: function(fn){ return (!!fn && fn instanceof Function) }}\n\tType.fn = Type.fn || {is: function(fn){ DEP('fn'); return (!!fn && 'function' == typeof fn) }}\n\tType.bi = Type.bi || {is: function(b){ DEP('bi');return (b instanceof Boolean || typeof b == 'boolean') }}\n\tType.num = Type.num || {is: function(n){ DEP('num'); return !list_is(n) && ((n - parseFloat(n) + 1) >= 0 || Infinity === n || -Infinity === n) }}\n\tType.text = Type.text || {is: function(t){ DEP('text'); return (typeof t == 'string') }}\n\tType.text.ify = Type.text.ify || function(t){ DEP('text.ify');\n\t\tif(Type.text.is(t)){ return t }\n\t\tif(typeof JSON !== \"undefined\"){ return JSON.stringify(t) }\n\t\treturn (t && t.toString)? t.toString() : t;\n\t}\n\tType.text.random = Type.text.random || function(l, c){ DEP('text.random');\n\t\tvar s = '';\n\t\tl = l || 24; // you are not going to make a 0 length random number, so no need to check type\n\t\tc = c || '0123456789ABCDEFGHIJKLMNOPQRSTUVWXZabcdefghijklmnopqrstuvwxyz';\n\t\twhile(l > 0){ s += c.charAt(Math.floor(Math.random() * c.length)); l-- }\n\t\treturn s;\n\t}\n\tType.text.match = Type.text.match || function(t, o){ var tmp, u; DEP('text.match');\n\t\tif('string' !== typeof t){ return false }\n\t\tif('string' == typeof o){ o = {'=': o} }\n\t\to = o || {};\n\t\ttmp = (o['='] || o['*'] || o['>'] || o['<']);\n\t\tif(t === tmp){ return true }\n\t\tif(u !== o['=']){ return false }\n\t\ttmp = (o['*'] || o['>'] || o['<']);\n\t\tif(t.slice(0, (tmp||'').length) === tmp){ return true }\n\t\tif(u !== o['*']){ return false }\n\t\tif(u !== o['>'] && u !== o['<']){\n\t\t\treturn (t >= o['>'] && t <= o['<'])? true : false;\n\t\t}\n\t\tif(u !== o['>'] && t >= o['>']){ return true }\n\t\tif(u !== o['<'] && t <= o['<']){ return true }\n\t\treturn false;\n\t}\n\tType.text.hash = Type.text.hash || function(s, c){ // via SO\n\t\tDEP('text.hash');\n\t\tif(typeof s !== 'string'){ return }\n\t  c = c || 0;\n\t  if(!s.length){ return c }\n\t  for(var i=0,l=s.length,n; i<l; ++i){\n\t    n = s.charCodeAt(i);\n\t    c = ((c<<5)-c)+n;\n\t    c |= 0;\n\t  }\n\t  return c;\n\t}\n\tType.list = Type.list || {is: function(l){ DEP('list'); return (l instanceof Array) }}\n\tType.list.slit = Type.list.slit || Array.prototype.slice;\n\tType.list.sort = Type.list.sort || function(k){ // creates a new sort function based off some key\n\t\tDEP('list.sort');\n\t\treturn function(A,B){\n\t\t\tif(!A || !B){ return 0 } A = A[k]; B = B[k];\n\t\t\tif(A < B){ return -1 }else if(A > B){ return 1 }\n\t\t\telse { return 0 }\n\t\t}\n\t}\n\tType.list.map = Type.list.map || function(l, c, _){ DEP('list.map'); return obj_map(l, c, _) }\n\tType.list.index = 1; // change this to 0 if you want non-logical, non-mathematical, non-matrix, non-convenient array notation\n\tType.obj = Type.boj || {is: function(o){ DEP('obj'); return o? (o instanceof Object && o.constructor === Object) || Object.prototype.toString.call(o).match(/^\\[object (\\w+)\\]$/)[1] === 'Object' : false }}\n\tType.obj.put = Type.obj.put || function(o, k, v){ DEP('obj.put'); return (o||{})[k] = v, o }\n\tType.obj.has = Type.obj.has || function(o, k){ DEP('obj.has'); return o && Object.prototype.hasOwnProperty.call(o, k) }\n\tType.obj.del = Type.obj.del || function(o, k){ DEP('obj.del'); \n\t\tif(!o){ return }\n\t\to[k] = null;\n\t\tdelete o[k];\n\t\treturn o;\n\t}\n\tType.obj.as = Type.obj.as || function(o, k, v, u){ DEP('obj.as'); return o[k] = o[k] || (u === v? {} : v) }\n\tType.obj.ify = Type.obj.ify || function(o){ DEP('obj.ify'); \n\t\tif(obj_is(o)){ return o }\n\t\ttry{o = JSON.parse(o);\n\t\t}catch(e){o={}};\n\t\treturn o;\n\t}\n\t;(function(){ var u;\n\t\tfunction map(v,k){\n\t\t\tif(obj_has(this,k) && u !== this[k]){ return }\n\t\t\tthis[k] = v;\n\t\t}\n\t\tType.obj.to = Type.obj.to || function(from, to){ DEP('obj.to'); \n\t\t\tto = to || {};\n\t\t\tobj_map(from, map, to);\n\t\t\treturn to;\n\t\t}\n\t}());\n\tType.obj.copy = Type.obj.copy || function(o){ DEP('obj.copy'); // because http://web.archive.org/web/20140328224025/http://jsperf.com/cloning-an-object/2\n\t\treturn !o? o : JSON.parse(JSON.stringify(o)); // is shockingly faster than anything else, and our data has to be a subset of JSON anyways!\n\t}\n\t;(function(){\n\t\tfunction empty(v,i){ var n = this.n, u;\n\t\t\tif(n && (i === n || (obj_is(n) && obj_has(n, i)))){ return }\n\t\t\tif(u !== i){ return true }\n\t\t}\n\t\tType.obj.empty = Type.obj.empty || function(o, n){ DEP('obj.empty'); \n\t\t\tif(!o){ return true }\n\t\t\treturn obj_map(o,empty,{n:n})? false : true;\n\t\t}\n\t}());\n\t;(function(){\n\t\tfunction t(k,v){\n\t\t\tif(2 === arguments.length){\n\t\t\t\tt.r = t.r || {};\n\t\t\t\tt.r[k] = v;\n\t\t\t\treturn;\n\t\t\t} t.r = t.r || [];\n\t\t\tt.r.push(k);\n\t\t};\n\t\tvar keys = Object.keys, map, u;\n\t\tObject.keys = Object.keys || function(o){ return map(o, function(v,k,t){t(k)}) }\n\t\tType.obj.map = map = Type.obj.map || function(l, c, _){ DEP('obj.map'); \n\t\t\tvar u, i = 0, x, r, ll, lle, f = 'function' == typeof c;\n\t\t\tt.r = u;\n\t\t\tif(keys && obj_is(l)){\n\t\t\t\tll = keys(l); lle = true;\n\t\t\t}\n\t\t\t_ = _ || {};\n\t\t\tif(list_is(l) || ll){\n\t\t\t\tx = (ll || l).length;\n\t\t\t\tfor(;i < x; i++){\n\t\t\t\t\tvar ii = (i + Type.list.index);\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tr = lle? c.call(_, l[ll[i]], ll[i], t) : c.call(_, l[i], ii, t);\n\t\t\t\t\t\tif(r !== u){ return r }\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//if(Type.test.is(c,l[i])){ return ii } // should implement deep equality testing!\n\t\t\t\t\t\tif(c === l[lle? ll[i] : i]){ return ll? ll[i] : ii } // use this for now\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(i in l){\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif(obj_has(l,i)){\n\t\t\t\t\t\t\tr = _? c.call(_, l[i], i, t) : c(l[i], i, t);\n\t\t\t\t\t\t\tif(r !== u){ return r }\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//if(a.test.is(c,l[i])){ return i } // should implement deep equality testing!\n\t\t\t\t\t\tif(c === l[i]){ return i } // use this for now\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn f? t.r : Type.list.index? 0 : -1;\n\t\t}\n\t}());\n\tType.time = Type.time || {};\n\tType.time.is = Type.time.is || function(t){ DEP('time'); return t? t instanceof Date : (+new Date().getTime()) }\n\n\tvar fn_is = Type.fn.is;\n\tvar list_is = Type.list.is;\n\tvar obj = Type.obj, obj_is = obj.is, obj_has = obj.has, obj_map = obj.map;\n\n\tvar Val = {};\n\tVal.is = function(v){ DEP('val.is'); // Valid values are a subset of JSON: null, binary, number (!Infinity), text, or a soul relation. Arrays need special algorithms to handle concurrency, so they are not supported directly. Use an extension that supports them if needed but research their problems first.\n\t\tif(v === u){ return false }\n\t\tif(v === null){ return true } // \"deletes\", nulling out keys.\n\t\tif(v === Infinity){ return false } // we want this to be, but JSON does not support it, sad face.\n\t\tif(text_is(v) // by \"text\" we mean strings.\n\t\t|| bi_is(v) // by \"binary\" we mean boolean.\n\t\t|| num_is(v)){ // by \"number\" we mean integers or decimals.\n\t\t\treturn true; // simple values are valid.\n\t\t}\n\t\treturn Val.link.is(v) || false; // is the value a soul relation? Then it is valid and return it. If not, everything else remaining is an invalid data type. Custom extensions can be built on top of these primitives to support other types.\n\t}\n\tVal.link = Val.rel = {_: '#'};\n\t;(function(){\n\t\tVal.link.is = function(v){ DEP('val.link.is'); // this defines whether an object is a soul relation or not, they look like this: {'#': 'UUID'}\n\t\t\tif(v && v[rel_] && !v._ && obj_is(v)){ // must be an object.\n\t\t\t\tvar o = {};\n\t\t\t\tobj_map(v, map, o);\n\t\t\t\tif(o.id){ // a valid id was found.\n\t\t\t\t\treturn o.id; // yay! Return it.\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false; // the value was not a valid soul relation.\n\t\t}\n\t\tfunction map(s, k){ var o = this; // map over the object...\n\t\t\tif(o.id){ return o.id = false } // if ID is already defined AND we're still looping through the object, it is considered invalid.\n\t\t\tif(k == rel_ && text_is(s)){ // the key should be '#' and have a text value.\n\t\t\t\to.id = s; // we found the soul!\n\t\t\t} else {\n\t\t\t\treturn o.id = false; // if there exists anything else on the object that isn't the soul, then it is considered invalid.\n\t\t\t}\n\t\t}\n\t}());\n\tVal.link.ify = function(t){ DEP('val.link.ify'); return obj_put({}, rel_, t) } // convert a soul into a relation and return it.\n\tType.obj.has._ = '.';\n\tvar rel_ = Val.link._, u;\n\tvar bi_is = Type.bi.is;\n\tvar num_is = Type.num.is;\n\tvar text_is = Type.text.is;\n\tvar obj = Type.obj, obj_is = obj.is, obj_put = obj.put, obj_map = obj.map;\n\n\tType.val = Type.val || Val;\n\n\tvar Node = {_: '_'};\n\tNode.soul = function(n, o){ DEP('node.soul'); return (n && n._ && n._[o || soul_]) } // convenience function to check to see if there is a soul on a node and return it.\n\tNode.soul.ify = function(n, o){ DEP('node.soul.ify'); // put a soul on an object.\n\t\to = (typeof o === 'string')? {soul: o} : o || {};\n\t\tn = n || {}; // make sure it exists.\n\t\tn._ = n._ || {}; // make sure meta exists.\n\t\tn._[soul_] = o.soul || n._[soul_] || text_random(); // put the soul on it.\n\t\treturn n;\n\t}\n\tNode.soul._ = Val.link._;\n\t;(function(){\n\t\tNode.is = function(n, cb, as){ DEP('node.is'); var s; // checks to see if an object is a valid node.\n\t\t\tif(!obj_is(n)){ return false } // must be an object.\n\t\t\tif(s = Node.soul(n)){ // must have a soul on it.\n\t\t\t\treturn !obj_map(n, map, {as:as,cb:cb,s:s,n:n});\n\t\t\t}\n\t\t\treturn false; // nope! This was not a valid node.\n\t\t}\n\t\tfunction map(v, k){ // we invert this because the way we check for this is via a negation.\n\t\t\tif(k === Node._){ return } // skip over the metadata.\n\t\t\tif(!Val.is(v)){ return true } // it is true that this is an invalid node.\n\t\t\tif(this.cb){ this.cb.call(this.as, v, k, this.n, this.s) } // optionally callback each key/value.\n\t\t}\n\t}());\n\t;(function(){\n\t\tNode.ify = function(obj, o, as){ DEP('node.ify'); // returns a node from a shallow object.\n\t\t\tif(!o){ o = {} }\n\t\t\telse if(typeof o === 'string'){ o = {soul: o} }\n\t\t\telse if('function' == typeof o){ o = {map: o} }\n\t\t\tif(o.map){ o.node = o.map.call(as, obj, u, o.node || {}) }\n\t\t\tif(o.node = Node.soul.ify(o.node || {}, o)){\n\t\t\t\tobj_map(obj, map, {o:o,as:as});\n\t\t\t}\n\t\t\treturn o.node; // This will only be a valid node if the object wasn't already deep!\n\t\t}\n\t\tfunction map(v, k){ var o = this.o, tmp, u; // iterate over each key/value.\n\t\t\tif(o.map){\n\t\t\t\ttmp = o.map.call(this.as, v, ''+k, o.node);\n\t\t\t\tif(u === tmp){\n\t\t\t\t\tobj_del(o.node, k);\n\t\t\t\t} else\n\t\t\t\tif(o.node){ o.node[k] = tmp }\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(Val.is(v)){\n\t\t\t\to.node[k] = v;\n\t\t\t}\n\t\t}\n\t}());\n\tvar obj = Type.obj, obj_is = obj.is, obj_del = obj.del, obj_map = obj.map;\n\tvar text = Type.text, text_random = text.random;\n\tvar soul_ = Node.soul._;\n\tvar u;\n\tType.node = Type.node || Node;\n\n\tvar State = Type.state;\n\tState.lex = function(){ DEP('state.lex'); return State().toString(36).replace('.','') }\n\tState.to = function(from, k, to){ DEP('state.to'); \n\t\tvar val = (from||{})[k];\n\t\tif(obj_is(val)){\n\t\t\tval = obj_copy(val);\n\t\t}\n\t\treturn State.ify(to, k, State.is(from, k), val, Node.soul(from));\n\t}\n\t;(function(){\n\t\tState.map = function(cb, s, as){ DEP('state.map'); var u; // for use with Node.ify\n\t\t\tvar o = obj_is(o = cb || s)? o : null;\n\t\t\tcb = fn_is(cb = cb || s)? cb : null;\n\t\t\tif(o && !cb){\n\t\t\t\ts = num_is(s)? s : State();\n\t\t\t\to[N_] = o[N_] || {};\n\t\t\t\tobj_map(o, map, {o:o,s:s});\n\t\t\t\treturn o;\n\t\t\t}\n\t\t\tas = as || obj_is(s)? s : u;\n\t\t\ts = num_is(s)? s : State();\n\t\t\treturn function(v, k, o, opt){\n\t\t\t\tif(!cb){\n\t\t\t\t\tmap.call({o: o, s: s}, v,k);\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tcb.call(as || this || {}, v, k, o, opt);\n\t\t\t\tif(obj_has(o,k) && u === o[k]){ return }\n\t\t\t\tmap.call({o: o, s: s}, v,k);\n\t\t\t}\n\t\t}\n\t\tfunction map(v,k){\n\t\t\tif(N_ === k){ return }\n\t\t\tState.ify(this.o, k, this.s) ;\n\t\t}\n\t}());\n\tvar obj = Type.obj, obj_as = obj.as, obj_has = obj.has, obj_is = obj.is, obj_map = obj.map, obj_copy = obj.copy;\n\tvar num = Type.num, num_is = num.is;\n\tvar fn = Type.fn, fn_is = fn.is;\n\tvar N_ = Node._, u;\n\n\tvar Graph = {};\n\t;(function(){\n\t\tGraph.is = function(g, cb, fn, as){ DEP('graph.is'); // checks to see if an object is a valid graph.\n\t\t\tif(!g || !obj_is(g) || obj_empty(g)){ return false } // must be an object.\n\t\t\treturn !obj_map(g, map, {cb:cb,fn:fn,as:as}); // makes sure it wasn't an empty object.\n\t\t}\n\t\tfunction map(n, s){ // we invert this because the way'? we check for this is via a negation.\n\t\t\tif(!n || s !== Node.soul(n) || !Node.is(n, this.fn, this.as)){ return true } // it is true that this is an invalid graph.\n\t\t\tif(!this.cb){ return }\n\t\t\tnf.n = n; nf.as = this.as; // sequential race conditions aren't races.\n\t\t\tthis.cb.call(nf.as, n, s, nf);\n\t\t}\n\t\tfunction nf(fn){ // optional callback for each node.\n\t\t\tif(fn){ Node.is(nf.n, fn, nf.as) } // where we then have an optional callback for each key/value.\n\t\t}\n\t}());\n\t;(function(){\n\t\tGraph.ify = function(obj, env, as){ DEP('graph.ify'); \n\t\t\tvar at = {path: [], obj: obj};\n\t\t\tif(!env){\n\t\t\t\tenv = {};\n\t\t\t} else\n\t\t\tif(typeof env === 'string'){\n\t\t\t\tenv = {soul: env};\n\t\t\t} else\n\t\t\tif('function' == typeof env){\n\t\t\t\tenv.map = env;\n\t\t\t}\n\t\t\tif(typeof as === 'string'){\n\t\t\t\tenv.soul = env.soul || as;\n\t\t\t\tas = u;\n\t\t\t}\n\t\t\tif(env.soul){\n\t\t\t\tat.link = Val.link.ify(env.soul);\n\t\t\t}\n\t\t\tenv.shell = (as||{}).shell;\n\t\t\tenv.graph = env.graph || {};\n\t\t\tenv.seen = env.seen || [];\n\t\t\tenv.as = env.as || as;\n\t\t\tnode(env, at);\n\t\t\tenv.root = at.node;\n\t\t\treturn env.graph;\n\t\t}\n\t\tfunction node(env, at){ var tmp;\n\t\t\tif(tmp = seen(env, at)){ return tmp }\n\t\t\tat.env = env;\n\t\t\tat.soul = soul;\n\t\t\tif(Node.ify(at.obj, map, at)){\n\t\t\t\tat.link = at.link || Val.link.ify(Node.soul(at.node));\n\t\t\t\tif(at.obj !== env.shell){\n\t\t\t\t\tenv.graph[Val.link.is(at.link)] = at.node;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn at;\n\t\t}\n\t\tfunction map(v,k,n){\n\t\t\tvar at = this, env = at.env, is, tmp;\n\t\t\tif(Node._ === k && obj_has(v,Val.link._)){\n\t\t\t\treturn n._; // TODO: Bug?\n\t\t\t}\n\t\t\tif(!(is = valid(v,k,n, at,env))){ return }\n\t\t\tif(!k){\n\t\t\t\tat.node = at.node || n || {};\n\t\t\t\tif(obj_has(v, Node._) && Node.soul(v)){ // ? for safety ?\n\t\t\t\t\tat.node._ = obj_copy(v._);\n\t\t\t\t}\n\t\t\t\tat.node = Node.soul.ify(at.node, Val.link.is(at.link));\n\t\t\t\tat.link = at.link || Val.link.ify(Node.soul(at.node));\n\t\t\t}\n\t\t\tif(tmp = env.map){\n\t\t\t\ttmp.call(env.as || {}, v,k,n, at);\n\t\t\t\tif(obj_has(n,k)){\n\t\t\t\t\tv = n[k];\n\t\t\t\t\tif(u === v){\n\t\t\t\t\t\tobj_del(n, k);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(!(is = valid(v,k,n, at,env))){ return }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!k){ return at.node }\n\t\t\tif(true === is){\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\ttmp = node(env, {obj: v, path: at.path.concat(k)});\n\t\t\tif(!tmp.node){ return }\n\t\t\treturn tmp.link; //{'#': Node.soul(tmp.node)};\n\t\t}\n\t\tfunction soul(id){ var at = this;\n\t\t\tvar prev = Val.link.is(at.link), graph = at.env.graph;\n\t\t\tat.link = at.link || Val.link.ify(id);\n\t\t\tat.link[Val.link._] = id;\n\t\t\tif(at.node && at.node[Node._]){\n\t\t\t\tat.node[Node._][Val.link._] = id;\n\t\t\t}\n\t\t\tif(obj_has(graph, prev)){\n\t\t\t\tgraph[id] = graph[prev];\n\t\t\t\tobj_del(graph, prev);\n\t\t\t}\n\t\t}\n\t\tfunction valid(v,k,n, at,env){ var tmp;\n\t\t\tif(Val.is(v)){ return true }\n\t\t\tif(obj_is(v)){ return 1 }\n\t\t\tif(tmp = env.invalid){\n\t\t\t\tv = tmp.call(env.as || {}, v,k,n);\n\t\t\t\treturn valid(v,k,n, at,env);\n\t\t\t}\n\t\t\tenv.err = \"Invalid value at '\" + at.path.concat(k).join('.') + \"'!\";\n\t\t\tif(Type.list.is(v)){ env.err += \" Use `.set(item)` instead of an Array.\" }\n\t\t}\n\t\tfunction seen(env, at){\n\t\t\tvar arr = env.seen, i = arr.length, has;\n\t\t\twhile(i--){ has = arr[i];\n\t\t\t\tif(at.obj === has.obj){ return has }\n\t\t\t}\n\t\t\tarr.push(at);\n\t\t}\n\t}());\n\tGraph.node = function(node){ DEP('graph.node'); \n\t\tvar soul = Node.soul(node);\n\t\tif(!soul){ return }\n\t\treturn obj_put({}, soul, node);\n\t}\n\t;(function(){\n\t\tGraph.to = function(graph, root, opt){ DEP('graph.to'); \n\t\t\tif(!graph){ return }\n\t\t\tvar obj = {};\n\t\t\topt = opt || {seen: {}};\n\t\t\tobj_map(graph[root], map, {obj:obj, graph: graph, opt: opt});\n\t\t\treturn obj;\n\t\t}\n\t\tfunction map(v,k){ var tmp, obj;\n\t\t\tif(Node._ === k){\n\t\t\t\tif(obj_empty(v, Val.link._)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.obj[k] = obj_copy(v);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!(tmp = Val.link.is(v))){\n\t\t\t\tthis.obj[k] = v;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(obj = this.opt.seen[tmp]){\n\t\t\t\tthis.obj[k] = obj;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.obj[k] = this.opt.seen[tmp] = Graph.to(this.graph, tmp, this.opt);\n\t\t}\n\t}());\n\tvar fn_is = Type.fn.is;\n\tvar obj = Type.obj, obj_is = obj.is, obj_del = obj.del, obj_has = obj.has, obj_empty = obj.empty, obj_put = obj.put, obj_map = obj.map, obj_copy = obj.copy;\n\tvar u;\n\tType.graph = Type.graph || Graph;\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BELGtCQUFrQjtBQUNsQixvQkFBb0IsR0FBRztBQUN2QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLDhCQUE4QjtBQUM5QjtBQUNBLGFBQWE7QUFDYixtQkFBbUI7QUFDbkI7QUFDQSxFQUFFO0FBQ0YseUNBQXlDO0FBQ3pDLGVBQWU7QUFDZjtBQUNBLGlCQUFpQjtBQUNqQiw4QkFBOEIsZ0NBQWdDO0FBQzlEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIzLWNoYXQvLi9ub2RlX21vZHVsZXMvZ3VuL2d1bi5qcz80NDYzIl0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24oKXtcblxuICAvKiBVTkJVSUxEICovXG4gIGZ1bmN0aW9uIFVTRShhcmcsIHJlcSl7XG4gICAgcmV0dXJuIHJlcT8gcmVxdWlyZShhcmcpIDogYXJnLnNsaWNlPyBVU0VbUihhcmcpXSA6IGZ1bmN0aW9uKG1vZCwgcGF0aCl7XG4gICAgICBhcmcobW9kID0ge2V4cG9ydHM6IHt9fSk7XG4gICAgICBVU0VbUihwYXRoKV0gPSBtb2QuZXhwb3J0cztcbiAgICB9XG4gICAgZnVuY3Rpb24gUihwKXtcbiAgICAgIHJldHVybiBwLnNwbGl0KCcvJykuc2xpY2UoLTEpLnRvU3RyaW5nKCkucmVwbGFjZSgnLmpzJywnJyk7XG4gICAgfVxuICB9XG4gIGlmKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpeyB2YXIgTU9EVUxFID0gbW9kdWxlIH1cbiAgLyogVU5CVUlMRCAqL1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHQvLyBTaGltIGZvciBnZW5lcmljIGphdmFzY3JpcHQgdXRpbGl0aWVzLlxuXHRcdFN0cmluZy5yYW5kb20gPSBmdW5jdGlvbihsLCBjKXtcblx0XHRcdHZhciBzID0gJyc7XG5cdFx0XHRsID0gbCB8fCAyNDsgLy8geW91IGFyZSBub3QgZ29pbmcgdG8gbWFrZSBhIDAgbGVuZ3RoIHJhbmRvbSBudW1iZXIsIHNvIG5vIG5lZWQgdG8gY2hlY2sgdHlwZVxuXHRcdFx0YyA9IGMgfHwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1haYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xuXHRcdFx0d2hpbGUobC0tID4gMCl7IHMgKz0gYy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYy5sZW5ndGgpKSB9XG5cdFx0XHRyZXR1cm4gcztcblx0XHR9XG5cdFx0U3RyaW5nLm1hdGNoID0gZnVuY3Rpb24odCwgbyl7IHZhciB0bXAsIHU7XG5cdFx0XHRpZignc3RyaW5nJyAhPT0gdHlwZW9mIHQpeyByZXR1cm4gZmFsc2UgfVxuXHRcdFx0aWYoJ3N0cmluZycgPT0gdHlwZW9mIG8peyBvID0geyc9Jzogb30gfVxuXHRcdFx0byA9IG8gfHwge307XG5cdFx0XHR0bXAgPSAob1snPSddIHx8IG9bJyonXSB8fCBvWyc+J10gfHwgb1snPCddKTtcblx0XHRcdGlmKHQgPT09IHRtcCl7IHJldHVybiB0cnVlIH1cblx0XHRcdGlmKHUgIT09IG9bJz0nXSl7IHJldHVybiBmYWxzZSB9XG5cdFx0XHR0bXAgPSAob1snKiddIHx8IG9bJz4nXSk7XG5cdFx0XHRpZih0LnNsaWNlKDAsICh0bXB8fCcnKS5sZW5ndGgpID09PSB0bXApeyByZXR1cm4gdHJ1ZSB9XG5cdFx0XHRpZih1ICE9PSBvWycqJ10peyByZXR1cm4gZmFsc2UgfVxuXHRcdFx0aWYodSAhPT0gb1snPiddICYmIHUgIT09IG9bJzwnXSl7XG5cdFx0XHRcdHJldHVybiAodCA+PSBvWyc+J10gJiYgdCA8PSBvWyc8J10pPyB0cnVlIDogZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZih1ICE9PSBvWyc+J10gJiYgdCA+PSBvWyc+J10peyByZXR1cm4gdHJ1ZSB9XG5cdFx0XHRpZih1ICE9PSBvWyc8J10gJiYgdCA8PSBvWyc8J10peyByZXR1cm4gdHJ1ZSB9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFN0cmluZy5oYXNoID0gZnVuY3Rpb24ocywgYyl7IC8vIHZpYSBTT1xuXHRcdFx0aWYodHlwZW9mIHMgIT09ICdzdHJpbmcnKXsgcmV0dXJuIH1cblx0ICAgIGMgPSBjIHx8IDA7IC8vIENQVSBzY2hlZHVsZSBoYXNoaW5nIGJ5XG5cdCAgICBpZighcy5sZW5ndGgpeyByZXR1cm4gYyB9XG5cdCAgICBmb3IodmFyIGk9MCxsPXMubGVuZ3RoLG47IGk8bDsgKytpKXtcblx0ICAgICAgbiA9IHMuY2hhckNvZGVBdChpKTtcblx0ICAgICAgYyA9ICgoYzw8NSktYykrbjtcblx0ICAgICAgYyB8PSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGM7XG5cdCAgfVxuXHRcdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHRcdE9iamVjdC5wbGFpbiA9IGZ1bmN0aW9uKG8peyByZXR1cm4gbz8gKG8gaW5zdGFuY2VvZiBPYmplY3QgJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykubWF0Y2goL15cXFtvYmplY3QgKFxcdyspXFxdJC8pWzFdID09PSAnT2JqZWN0JyA6IGZhbHNlIH1cblx0XHRPYmplY3QuZW1wdHkgPSBmdW5jdGlvbihvLCBuKXtcblx0XHRcdGZvcih2YXIgayBpbiBvKXsgaWYoaGFzLmNhbGwobywgaykgJiYgKCFuIHx8IC0xPT1uLmluZGV4T2YoaykpKXsgcmV0dXJuIGZhbHNlIH0gfVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdE9iamVjdC5rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24obyl7XG5cdFx0XHR2YXIgbCA9IFtdO1xuXHRcdFx0Zm9yKHZhciBrIGluIG8peyBpZihoYXMuY2FsbChvLCBrKSl7IGwucHVzaChrKSB9IH1cblx0XHRcdHJldHVybiBsO1xuXHRcdH1cblx0XHQ7KGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgdSwgc1QgPSBzZXRUaW1lb3V0LCBsID0gMCwgYyA9IDBcblx0XHRcdCwgc0kgPSAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJycrdSAmJiBzZXRJbW1lZGlhdGUpIHx8IChmdW5jdGlvbihjLGYpe1xuXHRcdFx0XHRpZih0eXBlb2YgTWVzc2FnZUNoYW5uZWwgPT0gJycrdSl7IHJldHVybiBzVCB9XG5cdFx0XHRcdChjID0gbmV3IE1lc3NhZ2VDaGFubmVsKCkpLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpeyAnJz09ZS5kYXRhICYmIGYoKSB9XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihxKXsgZj1xO2MucG9ydDIucG9zdE1lc3NhZ2UoJycpIH1cblx0XHRcdH0oKSksIGNoZWNrID0gc1QuY2hlY2sgPSBzVC5jaGVjayB8fCAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAnJyt1ICYmIHBlcmZvcm1hbmNlKVxuXHRcdFx0fHwge25vdzogZnVuY3Rpb24oKXsgcmV0dXJuICtuZXcgRGF0ZSB9fTtcblx0XHRcdHNULmhvbGQgPSBzVC5ob2xkIHx8IDk7IC8vIGhhbGYgYSBmcmFtZSBiZW5jaG1hcmtzIGZhc3RlciB0aGFuIDwgMW1zP1xuXHRcdFx0c1QucG9sbCA9IHNULnBvbGwgfHwgZnVuY3Rpb24oZil7XG5cdFx0XHRcdGlmKChzVC5ob2xkID49IChjaGVjay5ub3coKSAtIGwpKSAmJiBjKysgPCAzMzMzKXsgZigpOyByZXR1cm4gfVxuXHRcdFx0XHRzSShmdW5jdGlvbigpeyBsID0gY2hlY2subm93KCk7IGYoKSB9LGM9MClcblx0XHRcdH1cblx0XHR9KCkpO1xuXHRcdDsoZnVuY3Rpb24oKXsgLy8gVG9vIG1hbnkgcG9sbHMgYmxvY2ssIHRoaXMgXCJ0aHJlYWRzXCIgdGhlbSBpbiB0dXJucyBvdmVyIGEgc2luZ2xlIHRocmVhZCBpbiB0aW1lLlxuXHRcdFx0dmFyIHNUID0gc2V0VGltZW91dCwgdCA9IHNULnR1cm4gPSBzVC50dXJuIHx8IGZ1bmN0aW9uKGYpeyAxID09IHMucHVzaChmKSAmJiBwKFQpIH1cblx0XHRcdCwgcyA9IHQucyA9IFtdLCBwID0gc1QucG9sbCwgaSA9IDAsIGYsIFQgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRpZihmID0gc1tpKytdKXsgZigpIH1cblx0XHRcdFx0aWYoaSA9PSBzLmxlbmd0aCB8fCA5OSA9PSBpKXtcblx0XHRcdFx0XHRzID0gdC5zID0gcy5zbGljZShpKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihzLmxlbmd0aCl7IHAoVCkgfVxuXHRcdFx0fVxuXHRcdH0oKSk7XG5cdFx0OyhmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHUsIHNUID0gc2V0VGltZW91dCwgVCA9IHNULnR1cm47XG5cdFx0XHQoc1QuZWFjaCA9IHNULmVhY2ggfHwgZnVuY3Rpb24obCxmLGUsUyl7IFMgPSBTIHx8IDk7IChmdW5jdGlvbiB0KHMsTCxyKXtcblx0XHRcdCAgaWYoTCA9IChzID0gKGx8fFtdKS5zcGxpY2UoMCxTKSkubGVuZ3RoKXtcblx0XHRcdCAgXHRmb3IodmFyIGkgPSAwOyBpIDwgTDsgaSsrKXtcblx0XHRcdCAgXHRcdGlmKHUgIT09IChyID0gZihzW2ldKSkpeyBicmVhayB9XG5cdFx0XHQgIFx0fVxuXHRcdFx0ICBcdGlmKHUgPT09IHIpeyBUKHQpOyByZXR1cm4gfVxuXHRcdFx0ICB9IGUgJiYgZShyKTtcblx0XHRcdH0oKSl9KSgpO1xuXHRcdH0oKSk7XG5cdH0pKFVTRSwgJy4vc2hpbScpO1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHQvLyBPbiBldmVudCBlbWl0dGVyIGdlbmVyaWMgamF2YXNjcmlwdCB1dGlsaXR5LlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb250byh0YWcsIGFyZywgYXMpe1xuXHRcdFx0aWYoIXRhZyl7IHJldHVybiB7dG86IG9udG99IH1cblx0XHRcdHZhciB1LCBmID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnLCB0YWcgPSAodGhpcy50YWcgfHwgKHRoaXMudGFnID0ge30pKVt0YWddIHx8IGYgJiYgKFxuXHRcdFx0XHR0aGlzLnRhZ1t0YWddID0ge3RhZzogdGFnLCB0bzogb250by5fID0geyBuZXh0OiBmdW5jdGlvbihhcmcpeyB2YXIgdG1wO1xuXHRcdFx0XHRcdGlmKHRtcCA9IHRoaXMudG8peyB0bXAubmV4dChhcmcpIH1cblx0XHRcdH19fSk7XG5cdFx0XHRpZihmKXtcblx0XHRcdFx0dmFyIGJlID0ge1xuXHRcdFx0XHRcdG9mZjogb250by5vZmYgfHxcblx0XHRcdFx0XHQob250by5vZmYgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0aWYodGhpcy5uZXh0ID09PSBvbnRvLl8ubmV4dCl7IHJldHVybiAhMCB9XG5cdFx0XHRcdFx0XHRpZih0aGlzID09PSB0aGlzLnRoZS5sYXN0KXtcblx0XHRcdFx0XHRcdFx0dGhpcy50aGUubGFzdCA9IHRoaXMuYmFjaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMudG8uYmFjayA9IHRoaXMuYmFjaztcblx0XHRcdFx0XHRcdHRoaXMubmV4dCA9IG9udG8uXy5uZXh0O1xuXHRcdFx0XHRcdFx0dGhpcy5iYWNrLnRvID0gdGhpcy50bztcblx0XHRcdFx0XHRcdGlmKHRoaXMudGhlLmxhc3QgPT09IHRoaXMudGhlKXtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMub24udGFnW3RoaXMudGhlLnRhZ107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0dG86IG9udG8uXyxcblx0XHRcdFx0XHRuZXh0OiBhcmcsXG5cdFx0XHRcdFx0dGhlOiB0YWcsXG5cdFx0XHRcdFx0b246IHRoaXMsXG5cdFx0XHRcdFx0YXM6IGFzLFxuXHRcdFx0XHR9O1xuXHRcdFx0XHQoYmUuYmFjayA9IHRhZy5sYXN0IHx8IHRhZykudG8gPSBiZTtcblx0XHRcdFx0cmV0dXJuIHRhZy5sYXN0ID0gYmU7XG5cdFx0XHR9XG5cdFx0XHRpZigodGFnID0gdGFnLnRvKSAmJiB1ICE9PSBhcmcpeyB0YWcubmV4dChhcmcpIH1cblx0XHRcdHJldHVybiB0YWc7XG5cdFx0fTtcblx0fSkoVVNFLCAnLi9vbnRvJyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdC8vIFZhbGlkIHZhbHVlcyBhcmUgYSBzdWJzZXQgb2YgSlNPTjogbnVsbCwgYmluYXJ5LCBudW1iZXIgKCFJbmZpbml0eSksIHRleHQsXG5cdFx0Ly8gb3IgYSBzb3VsIHJlbGF0aW9uLiBBcnJheXMgbmVlZCBzcGVjaWFsIGFsZ29yaXRobXMgdG8gaGFuZGxlIGNvbmN1cnJlbmN5LFxuXHRcdC8vIHNvIHRoZXkgYXJlIG5vdCBzdXBwb3J0ZWQgZGlyZWN0bHkuIFVzZSBhbiBleHRlbnNpb24gdGhhdCBzdXBwb3J0cyB0aGVtIGlmXG5cdFx0Ly8gbmVlZGVkIGJ1dCByZXNlYXJjaCB0aGVpciBwcm9ibGVtcyBmaXJzdC5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2KSB7XG5cdFx0ICAvLyBcImRlbGV0ZXNcIiwgbnVsbGluZyBvdXQga2V5cy5cblx0XHQgIHJldHVybiB2ID09PSBudWxsIHx8XG5cdFx0XHRcInN0cmluZ1wiID09PSB0eXBlb2YgdiB8fFxuXHRcdFx0XCJib29sZWFuXCIgPT09IHR5cGVvZiB2IHx8XG5cdFx0XHQvLyB3ZSB3YW50ICsvLSBJbmZpbml0eSB0byBiZSwgYnV0IEpTT04gZG9lcyBub3Qgc3VwcG9ydCBpdCwgc2FkIGZhY2UuXG5cdFx0XHQvLyBjYW4geW91IGd1ZXNzIHdoYXQgdiA9PT0gdiBjaGVja3MgZm9yPyA7KVxuXHRcdFx0KFwibnVtYmVyXCIgPT09IHR5cGVvZiB2ICYmIHYgIT0gSW5maW5pdHkgJiYgdiAhPSAtSW5maW5pdHkgJiYgdiA9PT0gdikgfHxcblx0XHRcdCghIXYgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdltcIiNcIl0gJiYgT2JqZWN0LmtleXModikubGVuZ3RoID09PSAxICYmIHZbXCIjXCJdKTtcblx0XHR9XG5cdH0pKFVTRSwgJy4vdmFsaWQnKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0VVNFKCcuL3NoaW0nKTtcblx0XHRmdW5jdGlvbiBTdGF0ZSgpe1xuXHRcdFx0dmFyIHQgPSArbmV3IERhdGU7XG5cdFx0XHRpZihsYXN0IDwgdCl7XG5cdFx0XHRcdHJldHVybiBOID0gMCwgbGFzdCA9IHQgKyBTdGF0ZS5kcmlmdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsYXN0ID0gdCArICgoTiArPSAxKSAvIEQpICsgU3RhdGUuZHJpZnQ7XG5cdFx0fVxuXHRcdFN0YXRlLmRyaWZ0ID0gMDtcblx0XHR2YXIgTkkgPSAtSW5maW5pdHksIE4gPSAwLCBEID0gOTk5LCBsYXN0ID0gTkksIHU7IC8vIFdBUk5JTkchIEluIHRoZSBmdXR1cmUsIG9uIG1hY2hpbmVzIHRoYXQgYXJlIEQgdGltZXMgZmFzdGVyIHRoYW4gMjAxNkFEIG1hY2hpbmVzLCB5b3Ugd2lsbCB3YW50IHRvIGluY3JlYXNlIEQgYnkgYW5vdGhlciBzZXZlcmFsIG9yZGVycyBvZiBtYWduaXR1ZGUgc28gdGhlIHByb2Nlc3Npbmcgc3BlZWQgbmV2ZXIgb3V0IHBhY2VzIHRoZSBkZWNpbWFsIHJlc29sdXRpb24gKGluY3JlYXNpbmcgYW4gaW50ZWdlciBlZmZlY3RzIHRoZSBzdGF0ZSBhY2N1cmFjeSkuXG5cdFx0U3RhdGUuaXMgPSBmdW5jdGlvbihuLCBrLCBvKXsgLy8gY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzdGF0ZSBvbiBhIGtleSBvbiBhIG5vZGUgYW5kIHJldHVybiBpdC5cblx0XHRcdHZhciB0bXAgPSAoayAmJiBuICYmIG4uXyAmJiBuLl9bJz4nXSkgfHwgbztcblx0XHRcdGlmKCF0bXApeyByZXR1cm4gfVxuXHRcdFx0cmV0dXJuICgnbnVtYmVyJyA9PSB0eXBlb2YgKHRtcCA9IHRtcFtrXSkpPyB0bXAgOiBOSTtcblx0XHR9XG5cdFx0U3RhdGUuaWZ5ID0gZnVuY3Rpb24obiwgaywgcywgdiwgc291bCl7IC8vIHB1dCBhIGtleSdzIHN0YXRlIG9uIGEgbm9kZS5cblx0XHRcdChuID0gbiB8fCB7fSkuXyA9IG4uXyB8fCB7fTsgLy8gc2FmZXR5IGNoZWNrIG9yIGluaXQuXG5cdFx0XHRpZihzb3VsKXsgbi5fWycjJ10gPSBzb3VsIH0gLy8gc2V0IGEgc291bCBpZiBzcGVjaWZpZWQuXG5cdFx0XHR2YXIgdG1wID0gbi5fWyc+J10gfHwgKG4uX1snPiddID0ge30pOyAvLyBncmFiIHRoZSBzdGF0ZXMgZGF0YS5cblx0XHRcdGlmKHUgIT09IGsgJiYgayAhPT0gJ18nKXtcblx0XHRcdFx0aWYoJ251bWJlcicgPT0gdHlwZW9mIHMpeyB0bXBba10gPSBzIH0gLy8gYWRkIHRoZSB2YWxpZCBzdGF0ZS5cblx0XHRcdFx0aWYodSAhPT0gdil7IG5ba10gPSB2IH0gLy8gTm90ZTogTm90IGl0cyBqb2IgdG8gY2hlY2sgZm9yIHZhbGlkIHZhbHVlcyFcblx0XHRcdH1cblx0XHRcdHJldHVybiBuO1xuXHRcdH1cblx0XHRtb2R1bGUuZXhwb3J0cyA9IFN0YXRlO1xuXHR9KShVU0UsICcuL3N0YXRlJyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFVTRSgnLi9zaGltJyk7XG5cdFx0ZnVuY3Rpb24gRHVwKG9wdCl7XG5cdFx0XHR2YXIgZHVwID0ge3M6e319LCBzID0gZHVwLnM7XG5cdFx0XHRvcHQgPSBvcHQgfHwge21heDogOTk5LCBhZ2U6IDEwMDAgKiA5fTsvLyovIDEwMDAgKiA5ICogM307XG5cdFx0XHRkdXAuY2hlY2sgPSBmdW5jdGlvbihpZCl7XG5cdFx0XHRcdGlmKCFzW2lkXSl7IHJldHVybiBmYWxzZSB9XG5cdFx0XHRcdHJldHVybiBkdChpZCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZHQgPSBkdXAudHJhY2sgPSBmdW5jdGlvbihpZCl7XG5cdFx0XHRcdHZhciBpdCA9IHNbaWRdIHx8IChzW2lkXSA9IHt9KTtcblx0XHRcdFx0aXQud2FzID0gZHVwLm5vdyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0aWYoIWR1cC50byl7IGR1cC50byA9IHNldFRpbWVvdXQoZHVwLmRyb3AsIG9wdC5hZ2UgKyA5KSB9XG5cdFx0XHRcdGlmKGR0LmVkKXsgZHQuZWQoaWQpIH1cblx0XHRcdFx0cmV0dXJuIGl0O1xuXHRcdFx0fVxuXHRcdFx0ZHVwLmRyb3AgPSBmdW5jdGlvbihhZ2Upe1xuXHRcdFx0XHRkdXAudG8gPSBudWxsO1xuXHRcdFx0XHRkdXAubm93ID0gK25ldyBEYXRlO1xuXHRcdFx0XHR2YXIgbCA9IE9iamVjdC5rZXlzKHMpO1xuXHRcdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKGR1cC5ub3csICtuZXcgRGF0ZSAtIGR1cC5ub3csICdkdXAgZHJvcCBrZXlzJyk7IC8vIHByZXYgfjIwJSBDUFUgNyUgUkFNIDMwME1CIC8vIG5vdyB+MjUlIENQVSA3JSBSQU0gNTAwTUJcblx0XHRcdFx0c2V0VGltZW91dC5lYWNoKGwsIGZ1bmN0aW9uKGlkKXsgdmFyIGl0ID0gc1tpZF07IC8vIFRPRE86IC5rZXlzKCBpcyBzbG93P1xuXHRcdFx0XHRcdGlmKGl0ICYmIChhZ2UgfHwgb3B0LmFnZSkgPiAoZHVwLm5vdyAtIGl0LndhcykpeyByZXR1cm4gfVxuXHRcdFx0XHRcdGRlbGV0ZSBzW2lkXTtcblx0XHRcdFx0fSwwLDk5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkdXA7XG5cdFx0fVxuXHRcdG1vZHVsZS5leHBvcnRzID0gRHVwO1xuXHR9KShVU0UsICcuL2R1cCcpO1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHQvLyByZXF1ZXN0IC8gcmVzcG9uc2UgbW9kdWxlLCBmb3IgYXNraW5nIGFuZCBhY2tpbmcgbWVzc2FnZXMuXG5cdFx0VVNFKCcuL29udG8nKTsgLy8gZGVwZW5kcyB1cG9uIG9udG8hXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc2soY2IsIGFzKXtcblx0XHRcdGlmKCF0aGlzLm9uKXsgcmV0dXJuIH1cblx0XHRcdHZhciBsYWNrID0gKHRoaXMub3B0fHx7fSkubGFjayB8fCA5MDAwO1xuXHRcdFx0aWYoISgnZnVuY3Rpb24nID09IHR5cGVvZiBjYikpe1xuXHRcdFx0XHRpZighY2IpeyByZXR1cm4gfVxuXHRcdFx0XHR2YXIgaWQgPSBjYlsnIyddIHx8IGNiLCB0bXAgPSAodGhpcy50YWd8fCcnKVtpZF07XG5cdFx0XHRcdGlmKCF0bXApeyByZXR1cm4gfVxuXHRcdFx0XHRpZihhcyl7XG5cdFx0XHRcdFx0dG1wID0gdGhpcy5vbihpZCwgYXMpO1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCh0bXAuZXJyKTtcblx0XHRcdFx0XHR0bXAuZXJyID0gc2V0VGltZW91dChmdW5jdGlvbigpeyB0bXAub2ZmKCkgfSwgbGFjayk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgaWQgPSAoYXMgJiYgYXNbJyMnXSkgfHwgcmFuZG9tKDkpO1xuXHRcdFx0aWYoIWNiKXsgcmV0dXJuIGlkIH1cblx0XHRcdHZhciB0byA9IHRoaXMub24oaWQsIGNiLCBhcyk7XG5cdFx0XHR0by5lcnIgPSB0by5lcnIgfHwgc2V0VGltZW91dChmdW5jdGlvbigpeyB0by5vZmYoKTtcblx0XHRcdFx0dG8ubmV4dCh7ZXJyOiBcIkVycm9yOiBObyBBQ0sgeWV0LlwiLCBsYWNrOiB0cnVlfSk7XG5cdFx0XHR9LCBsYWNrKTtcblx0XHRcdHJldHVybiBpZDtcblx0XHR9XG5cdFx0dmFyIHJhbmRvbSA9IFN0cmluZy5yYW5kb20gfHwgZnVuY3Rpb24oKXsgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpIH1cblx0fSkoVVNFLCAnLi9hc2snKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cblx0XHRmdW5jdGlvbiBHdW4obyl7XG5cdFx0XHRpZihvIGluc3RhbmNlb2YgR3VuKXsgcmV0dXJuICh0aGlzLl8gPSB7JDogdGhpc30pLiQgfVxuXHRcdFx0aWYoISh0aGlzIGluc3RhbmNlb2YgR3VuKSl7IHJldHVybiBuZXcgR3VuKG8pIH1cblx0XHRcdHJldHVybiBHdW4uY3JlYXRlKHRoaXMuXyA9IHskOiB0aGlzLCBvcHQ6IG99KTtcblx0XHR9XG5cblx0XHRHdW4uaXMgPSBmdW5jdGlvbigkKXsgcmV0dXJuICgkIGluc3RhbmNlb2YgR3VuKSB8fCAoJCAmJiAkLl8gJiYgKCQgPT09ICQuXy4kKSkgfHwgZmFsc2UgfVxuXG5cdFx0R3VuLnZlcnNpb24gPSAwLjIwMjA7XG5cblx0XHRHdW4uY2hhaW4gPSBHdW4ucHJvdG90eXBlO1xuXHRcdEd1bi5jaGFpbi50b0pTT04gPSBmdW5jdGlvbigpe307XG5cblx0XHRVU0UoJy4vc2hpbScpO1xuXHRcdEd1bi52YWxpZCA9IFVTRSgnLi92YWxpZCcpO1xuXHRcdEd1bi5zdGF0ZSA9IFVTRSgnLi9zdGF0ZScpO1xuXHRcdEd1bi5vbiA9IFVTRSgnLi9vbnRvJyk7XG5cdFx0R3VuLmR1cCA9IFVTRSgnLi9kdXAnKTtcblx0XHRHdW4uYXNrID0gVVNFKCcuL2FzaycpO1xuXG5cdFx0OyhmdW5jdGlvbigpe1xuXHRcdFx0R3VuLmNyZWF0ZSA9IGZ1bmN0aW9uKGF0KXtcblx0XHRcdFx0YXQucm9vdCA9IGF0LnJvb3QgfHwgYXQ7XG5cdFx0XHRcdGF0LmdyYXBoID0gYXQuZ3JhcGggfHwge307XG5cdFx0XHRcdGF0Lm9uID0gYXQub24gfHwgR3VuLm9uO1xuXHRcdFx0XHRhdC5hc2sgPSBhdC5hc2sgfHwgR3VuLmFzaztcblx0XHRcdFx0YXQuZHVwID0gYXQuZHVwIHx8IEd1bi5kdXAoKTtcblx0XHRcdFx0dmFyIGd1biA9IGF0LiQub3B0KGF0Lm9wdCk7XG5cdFx0XHRcdGlmKCFhdC5vbmNlKXtcblx0XHRcdFx0XHRhdC5vbignaW4nLCB1bml2ZXJzZSwgYXQpO1xuXHRcdFx0XHRcdGF0Lm9uKCdvdXQnLCB1bml2ZXJzZSwgYXQpO1xuXHRcdFx0XHRcdGF0Lm9uKCdwdXQnLCBtYXAsIGF0KTtcblx0XHRcdFx0XHRHdW4ub24oJ2NyZWF0ZScsIGF0KTtcblx0XHRcdFx0XHRhdC5vbignY3JlYXRlJywgYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF0Lm9uY2UgPSAxO1xuXHRcdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gdW5pdmVyc2UobXNnKXtcblx0XHRcdFx0Ly8gVE9ETzogQlVHISBtc2cub3V0ID0gbnVsbCBiZWluZyBzZXQhXG5cdFx0XHRcdC8vaWYoIUYpeyB2YXIgZXZlID0gdGhpczsgc2V0VGltZW91dChmdW5jdGlvbigpeyB1bml2ZXJzZS5jYWxsKGV2ZSwgbXNnLDEpIH0sTWF0aC5yYW5kb20oKSAqIDEwMCk7cmV0dXJuOyB9IC8vIEFERCBGIFRPIFBBUkFNUyFcblx0XHRcdFx0aWYoIW1zZyl7IHJldHVybiB9XG5cdFx0XHRcdGlmKG1zZy5vdXQgPT09IHVuaXZlcnNlKXsgdGhpcy50by5uZXh0KG1zZyk7IHJldHVybiB9XG5cdFx0XHRcdHZhciBldmUgPSB0aGlzLCBhcyA9IGV2ZS5hcywgYXQgPSBhcy5hdCB8fCBhcywgZ3VuID0gYXQuJCwgZHVwID0gYXQuZHVwLCB0bXAsIERCRyA9IG1zZy5EQkc7XG5cdFx0XHRcdCh0bXAgPSBtc2dbJyMnXSkgfHwgKHRtcCA9IG1zZ1snIyddID0gdGV4dF9yYW5kKDkpKTtcblx0XHRcdFx0aWYoZHVwLmNoZWNrKHRtcCkpeyByZXR1cm4gfSBkdXAudHJhY2sodG1wKTtcblx0XHRcdFx0dG1wID0gbXNnLl87IG1zZy5fID0gKCdmdW5jdGlvbicgPT0gdHlwZW9mIHRtcCk/IHRtcCA6IGZ1bmN0aW9uKCl7fTtcblx0XHRcdFx0KG1zZy4kICYmIChtc2cuJCA9PT0gKG1zZy4kLl98fCcnKS4kKSkgfHwgKG1zZy4kID0gZ3VuKTtcblx0XHRcdFx0aWYobXNnWydAJ10gJiYgIW1zZy5wdXQpeyBhY2sobXNnKSB9XG5cdFx0XHRcdGlmKCFhdC5hc2sobXNnWydAJ10sIG1zZykpeyAvLyBpcyB0aGlzIG1hY2hpbmUgbGlzdGVuaW5nIGZvciBhbiBhY2s/XG5cdFx0XHRcdFx0REJHICYmIChEQkcudSA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdFx0aWYobXNnLnB1dCl7IHB1dChtc2cpOyByZXR1cm4gfSBlbHNlXG5cdFx0XHRcdFx0aWYobXNnLmdldCl7IEd1bi5vbi5nZXQobXNnLCBndW4pIH1cblx0XHRcdFx0fVxuXHRcdFx0XHREQkcgJiYgKERCRy51YyA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdGV2ZS50by5uZXh0KG1zZyk7XG5cdFx0XHRcdERCRyAmJiAoREJHLnVhID0gK25ldyBEYXRlKTtcblx0XHRcdFx0aWYobXNnLm50cyB8fCBtc2cuTlRTKXsgcmV0dXJuIH0gLy8gVE9ETzogVGhpcyBzaG91bGRuJ3QgYmUgaW4gY29yZSwgYnV0IGZhc3Qgd2F5IHRvIHByZXZlbnQgTlRTIHNwcmVhZC4gRGVsZXRlIHRoaXMgbGluZSBhZnRlciBhbGwgcGVlcnMgaGF2ZSB1cGdyYWRlZCB0byBuZXdlciB2ZXJzaW9ucy5cblx0XHRcdFx0bXNnLm91dCA9IHVuaXZlcnNlOyBhdC5vbignb3V0JywgbXNnKTtcblx0XHRcdFx0REJHICYmIChEQkcudWUgPSArbmV3IERhdGUpO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gcHV0KG1zZyl7XG5cdFx0XHRcdGlmKCFtc2cpeyByZXR1cm4gfVxuXHRcdFx0XHR2YXIgY3R4ID0gbXNnLl98fCcnLCByb290ID0gY3R4LnJvb3QgPSAoKGN0eC4kID0gbXNnLiR8fCcnKS5ffHwnJykucm9vdDtcblx0XHRcdFx0aWYobXNnWydAJ10gJiYgY3R4LmZhaXRoICYmICFjdHgubWlzcyl7IC8vIFRPRE86IEFYRSBtYXkgc3BsaXQvcm91dGUgYmFzZWQgb24gJ3B1dCcgd2hhdCBzaG91bGQgd2UgZG8gaGVyZT8gRGV0ZWN0IEAgaW4gQVhFPyBJIHRoaW5rIHdlIGRvbid0IGhhdmUgdG8gd29ycnksIGFzIERBTSB3aWxsIHJvdXRlIGl0IG9uIEAuXG5cdFx0XHRcdFx0bXNnLm91dCA9IHVuaXZlcnNlO1xuXHRcdFx0XHRcdHJvb3Qub24oJ291dCcsIG1zZyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5sYXRjaCA9IHJvb3QuaGF0Y2g7IGN0eC5tYXRjaCA9IHJvb3QuaGF0Y2ggPSBbXTtcblx0XHRcdFx0dmFyIHB1dCA9IG1zZy5wdXQ7XG5cdFx0XHRcdHZhciBEQkcgPSBjdHguREJHID0gbXNnLkRCRywgUyA9ICtuZXcgRGF0ZTsgQ1QgPSBDVCB8fCBTO1xuXHRcdFx0XHRpZihwdXRbJyMnXSAmJiBwdXRbJy4nXSl7IC8qcm9vdCAmJiByb290Lm9uKCdwdXQnLCBtc2cpOyovIHJldHVybiB9IC8vIFRPRE86IEJVRyEgVGhpcyBuZWVkcyB0byBjYWxsIEhBTSBpbnN0ZWFkLlxuXHRcdFx0XHREQkcgJiYgKERCRy5wID0gUyk7XG5cdFx0XHRcdGN0eFsnIyddID0gbXNnWycjJ107XG5cdFx0XHRcdGN0eC5tc2cgPSBtc2c7XG5cdFx0XHRcdGN0eC5hbGwgPSAwO1xuXHRcdFx0XHRjdHguc3R1biA9IDE7XG5cdFx0XHRcdHZhciBubCA9IE9iamVjdC5rZXlzKHB1dCk7Ly8uc29ydCgpOyAvLyBUT0RPOiBUaGlzIGlzIHVuYm91bmRlZCBvcGVyYXRpb24sIGxhcmdlIGdyYXBocyB3aWxsIGJlIHNsb3dlci4gV3JpdGUgb3VyIG93biBDUFUgc2NoZWR1bGVkIHNvcnQ/IE9yIHNvbWVob3cgZG8gaXQgaW4gYmVsb3c/IEtleXMgaXRzZWxmIGlzIG5vdCBPKDEpIGVpdGhlciwgY3JlYXRlIEVTNSBzaGltIG92ZXIgP3dlYWsgbWFwPyBvciBjdXN0b20gd2hpY2ggaXMgY29uc3RhbnQuXG5cdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgKChEQkd8fGN0eCkucGsgPSArbmV3IERhdGUpIC0gUywgJ3B1dCBzb3J0Jyk7XG5cdFx0XHRcdHZhciBuaSA9IDAsIG5qLCBrbCwgc291bCwgbm9kZSwgc3RhdGVzLCBlcnIsIHRtcDtcblx0XHRcdFx0KGZ1bmN0aW9uIHBvcChvKXtcblx0XHRcdFx0XHRpZihuaiAhPSBuaSl7IG5qID0gbmk7XG5cdFx0XHRcdFx0XHRpZighKHNvdWwgPSBubFtuaV0pKXtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCAoKERCR3x8Y3R4KS5wZCA9ICtuZXcgRGF0ZSkgLSBTLCAncHV0Jyk7XG5cdFx0XHRcdFx0XHRcdGZpcmUoY3R4KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoIShub2RlID0gcHV0W3NvdWxdKSl7IGVyciA9IEVSUitjdXQoc291bCkrXCJubyBub2RlLlwiIH0gZWxzZVxuXHRcdFx0XHRcdFx0aWYoISh0bXAgPSBub2RlLl8pKXsgZXJyID0gRVJSK2N1dChzb3VsKStcIm5vIG1ldGEuXCIgfSBlbHNlXG5cdFx0XHRcdFx0XHRpZihzb3VsICE9PSB0bXBbJyMnXSl7IGVyciA9IEVSUitjdXQoc291bCkrXCJzb3VsIG5vdCBzYW1lLlwiIH0gZWxzZVxuXHRcdFx0XHRcdFx0aWYoIShzdGF0ZXMgPSB0bXBbJz4nXSkpeyBlcnIgPSBFUlIrY3V0KHNvdWwpK1wibm8gc3RhdGUuXCIgfVxuXHRcdFx0XHRcdFx0a2wgPSBPYmplY3Qua2V5cyhub2RlfHx7fSk7IC8vIFRPRE86IC5rZXlzKCBpcyBzbG93XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGVycil7XG5cdFx0XHRcdFx0XHRtc2cuZXJyID0gY3R4LmVyciA9IGVycjsgLy8gaW52YWxpZCBkYXRhIHNob3VsZCBlcnJvciBhbmQgc3R1biB0aGUgbWVzc2FnZS5cblx0XHRcdFx0XHRcdGZpcmUoY3R4KTtcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJoYW5kbGUgZXJyb3IhXCIsIGVycikgLy8gaGFuZGxlIVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgaSA9IDAsIGtleTsgbyA9IG8gfHwgMDtcblx0XHRcdFx0XHR3aGlsZShvKysgPCA5ICYmIChrZXkgPSBrbFtpKytdKSl7XG5cdFx0XHRcdFx0XHRpZignXycgPT09IGtleSl7IGNvbnRpbnVlIH1cblx0XHRcdFx0XHRcdHZhciB2YWwgPSBub2RlW2tleV0sIHN0YXRlID0gc3RhdGVzW2tleV07XG5cdFx0XHRcdFx0XHRpZih1ID09PSBzdGF0ZSl7IGVyciA9IEVSUitjdXQoa2V5KStcIm9uXCIrY3V0KHNvdWwpK1wibm8gc3RhdGUuXCI7IGJyZWFrIH1cblx0XHRcdFx0XHRcdGlmKCF2YWxpZCh2YWwpKXsgZXJyID0gRVJSK2N1dChrZXkpK1wib25cIitjdXQoc291bCkrXCJiYWQgXCIrKHR5cGVvZiB2YWwpK2N1dCh2YWwpOyBicmVhayB9XG5cdFx0XHRcdFx0XHQvL2N0eC5hbGwrKzsgLy9jdHguYWNrW3NvdWwra2V5XSA9ICcnO1xuXHRcdFx0XHRcdFx0aGFtKHZhbCwga2V5LCBzb3VsLCBzdGF0ZSwgbXNnKTtcblx0XHRcdFx0XHRcdCsrQzsgLy8gY291cnRlc3kgY291bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKChrbCA9IGtsLnNsaWNlKGkpKS5sZW5ndGgpeyB0dXJuKHBvcCk7IHJldHVybiB9XG5cdFx0XHRcdFx0KytuaTsga2wgPSBudWxsOyBwb3Aobyk7XG5cdFx0XHRcdH0oKSk7XG5cdFx0XHR9IEd1bi5vbi5wdXQgPSBwdXQ7XG5cdFx0XHQvLyBUT0RPOiBNQVJLISEhIGNsb2NrIGJlbG93LCByZWNvbm5lY3Qgc3luYywgU0VBIGNlcnRpZnkgd2lyZSBtZXJnZSwgVXNlci5hdXRoIHRha2luZyBtdWx0aXBsZSB0aW1lcywgLy8gbXNnIHB1dCwgcHV0LCBzYXkgYWNrLCBoZWFyIGxvb3AuLi5cblx0XHRcdC8vIFdBU0lTIEJVRyEgbG9jYWwgcGVlciBub3QgYWNrLiAub2ZmIG90aGVyIHBlb3BsZTogLm9wZW5cblx0XHRcdGZ1bmN0aW9uIGhhbSh2YWwsIGtleSwgc291bCwgc3RhdGUsIG1zZyl7XG5cdFx0XHRcdHZhciBjdHggPSBtc2cuX3x8JycsIHJvb3QgPSBjdHgucm9vdCwgZ3JhcGggPSByb290LmdyYXBoLCBsb3QsIHRtcDtcblx0XHRcdFx0dmFyIHZlcnRleCA9IGdyYXBoW3NvdWxdIHx8IGVtcHR5LCB3YXMgPSBzdGF0ZV9pcyh2ZXJ0ZXgsIGtleSwgMSksIGtub3duID0gdmVydGV4W2tleV07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgREJHID0gY3R4LkRCRzsgaWYodG1wID0gY29uc29sZS5TVEFUKXsgaWYoIWdyYXBoW3NvdWxdIHx8ICFrbm93bil7IHRtcC5oYXMgPSAodG1wLmhhcyB8fCAwKSArIDEgfSB9XG5cblx0XHRcdFx0dmFyIG5vdyA9IFN0YXRlKCksIHU7XG5cdFx0XHRcdGlmKHN0YXRlID4gbm93KXtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IGhhbSh2YWwsIGtleSwgc291bCwgc3RhdGUsIG1zZykgfSwgKHRtcCA9IHN0YXRlIC0gbm93KSA+IE1EPyBNRCA6IHRtcCk7IC8vIE1heCBEZWZlciAzMmJpdC4gOihcblx0XHRcdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKCgoREJHfHxjdHgpLkhmID0gK25ldyBEYXRlKSwgdG1wLCAnZnV0dXJlJyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHN0YXRlIDwgd2FzKXsgLypvbGQ7Ki8gaWYodHJ1ZSB8fCAhY3R4Lm1pc3MpeyByZXR1cm4gfSB9IC8vIGJ1dCBzb21lIGNoYWlucyBoYXZlIGEgY2FjaGUgbWlzcyB0aGF0IG5lZWQgdG8gcmUtZmlyZS4gLy8gVE9ETzogSW1wcm92ZSBpbiBmdXR1cmUuIC8vIGZvciBBWEUgdGhpcyB3b3VsZCByZWR1Y2UgcmVicm9hZGNhc3QsIGJ1dCBHVU4gZG9lcyBpdCBvbiBtZXNzYWdlIGZvcndhcmRpbmcuIC8vIFRVUk5TIE9VVCBDQUNIRSBNSVNTIFdBUyBOT1QgTkVFREVEIEZPUiBORVcgQ0hBSU5TIEFOWU1PUkUhISEgREFOR0VSIERBTkdFUiBEQU5HRVIsIEFMV0FZUyBSRVRVUk4hIChvciBhbSBJIG1pc3Npbmcgc29tZXRoaW5nPylcblx0XHRcdFx0aWYoIWN0eC5mYWl0aCl7IC8vIFRPRE86IEJVRz8gQ2FuIHRoaXMgYmUgdXNlZCBmb3IgY2FjaGUgbWlzcyBhcyB3ZWxsPyAvLyBZZXMgdGhpcyB3YXMgYSBidWcsIG5lZWQgdG8gY2hlY2sgY2FjaGUgbWlzcyBmb3IgUkFEIHRlc3RzLCBidXQgc2hvdWxkIHdlIGNhcmUgYWJvdXQgdGhlIGZhaXRoIGNoZWNrIG5vdz8gUHJvYmFibHkgbm90LlxuXHRcdFx0XHRcdGlmKHN0YXRlID09PSB3YXMgJiYgKHZhbCA9PT0ga25vd24gfHwgTCh2YWwpIDw9IEwoa25vd24pKSl7IC8qY29uc29sZS5sb2coXCJzYW1lXCIpOyovIC8qc2FtZTsqLyBpZighY3R4Lm1pc3MpeyByZXR1cm4gfSB9IC8vIHNhbWVcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguc3R1bisrOyAvLyBUT0RPOiAnZm9yZ2V0JyBmZWF0dXJlIGluIFNFQSB0aWVkIHRvIHRoaXMsIGJhZCBhcHByb2FjaCwgYnV0IGhhY2tlZCBpbiBmb3Igbm93LiBBbnkgY2hhbmdlcyBoZXJlIG11c3QgdXBkYXRlIHRoZXJlLlxuXHRcdFx0XHR2YXIgYWlkID0gbXNnWycjJ10rY3R4LmFsbCsrLCBpZCA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXsgcmV0dXJuIGFpZCB9LCBfOiBjdHh9OyBpZC50b0pTT04gPSBpZC50b1N0cmluZzsgLy8gdGhpcyAqdHJpY2sqIG1ha2VzIGl0IGNvbXBhdGlibGUgYmV0d2VlbiBvbGQgJiBuZXcgdmVyc2lvbnMuXG5cdFx0XHRcdHJvb3QuZHVwLnRyYWNrKGlkKVsnIyddID0gbXNnWycjJ107IC8vIGZpeGVzIG5ldyBPSyBhY2tzIGZvciBSUEMgbGlrZSBSVEMuXG5cdFx0XHRcdERCRyAmJiAoREJHLnBoID0gREJHLnBoIHx8ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdHJvb3Qub24oJ3B1dCcsIHsnIyc6IGlkLCAnQCc6IG1zZ1snQCddLCBwdXQ6IHsnIyc6IHNvdWwsICcuJzoga2V5LCAnOic6IHZhbCwgJz4nOiBzdGF0ZX0sIG9rOiBtc2cub2ssIF86IGN0eH0pO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gbWFwKG1zZyl7XG5cdFx0XHRcdHZhciBEQkc7IGlmKERCRyA9IChtc2cuX3x8JycpLkRCRyl7IERCRy5wYSA9ICtuZXcgRGF0ZTsgREJHLnBtID0gREJHLnBtIHx8ICtuZXcgRGF0ZX1cbiAgICAgIFx0dmFyIGV2ZSA9IHRoaXMsIHJvb3QgPSBldmUuYXMsIGdyYXBoID0gcm9vdC5ncmFwaCwgY3R4ID0gbXNnLl8sIHB1dCA9IG1zZy5wdXQsIHNvdWwgPSBwdXRbJyMnXSwga2V5ID0gcHV0WycuJ10sIHZhbCA9IHB1dFsnOiddLCBzdGF0ZSA9IHB1dFsnPiddLCBpZCA9IG1zZ1snIyddLCB0bXA7XG4gICAgICBcdGlmKCh0bXAgPSBjdHgubXNnKSAmJiAodG1wID0gdG1wLnB1dCkgJiYgKHRtcCA9IHRtcFtzb3VsXSkpeyBzdGF0ZV9pZnkodG1wLCBrZXksIHN0YXRlLCB2YWwsIHNvdWwpIH0gLy8gbmVjZXNzYXJ5ISBvciBlbHNlIG91dCBtZXNzYWdlcyBkbyBub3QgZ2V0IFNFQSB0cmFuc2Zvcm1zLlxuICAgICAgXHQvL3ZhciBieXRlcyA9ICgoZ3JhcGhbc291bF18fCcnKVtrZXldfHwnJykubGVuZ3RofHwxO1xuXHRcdFx0XHRncmFwaFtzb3VsXSA9IHN0YXRlX2lmeShncmFwaFtzb3VsXSwga2V5LCBzdGF0ZSwgdmFsLCBzb3VsKTtcblx0XHRcdFx0aWYodG1wID0gKHJvb3QubmV4dHx8JycpW3NvdWxdKXtcblx0XHRcdFx0XHQvL3RtcC5ieXRlcyA9ICh0bXAuYnl0ZXN8fDApICsgKCh2YWx8fCcnKS5sZW5ndGh8fDEpIC0gYnl0ZXM7XG5cdFx0XHRcdFx0Ly9pZih0bXAuYnl0ZXMgPiAyKioxMyl7IEd1bi5sb2cub25jZSgnYnl0ZS1saW1pdCcsIFwiTm90ZTogSW4gdGhlIGZ1dHVyZSwgR1VOIHBlZXJzIHdpbGwgZW5mb3JjZSBhIH40S0IgcXVlcnkgbGltaXQuIFBsZWFzZSBzZWUgaHR0cHM6Ly9ndW4uZWNvL2RvY3MvUGFnZVwiKSB9XG5cdFx0XHRcdFx0dG1wLm9uKCdpbicsIG1zZylcblx0XHRcdFx0fVxuXHRcdFx0XHRmaXJlKGN0eCk7XG5cdFx0XHRcdGV2ZS50by5uZXh0KG1zZyk7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBmaXJlKGN0eCwgbXNnKXsgdmFyIHJvb3Q7XG5cdFx0XHRcdGlmKGN0eC5zdG9wKXsgcmV0dXJuIH1cblx0XHRcdFx0aWYoIWN0eC5lcnIgJiYgMCA8IC0tY3R4LnN0dW4peyByZXR1cm4gfSAvLyBUT0RPOiAnZm9yZ2V0JyBmZWF0dXJlIGluIFNFQSB0aWVkIHRvIHRoaXMsIGJhZCBhcHByb2FjaCwgYnV0IGhhY2tlZCBpbiBmb3Igbm93LiBBbnkgY2hhbmdlcyBoZXJlIG11c3QgdXBkYXRlIHRoZXJlLlxuXHRcdFx0XHRjdHguc3RvcCA9IDE7XG5cdFx0XHRcdGlmKCEocm9vdCA9IGN0eC5yb290KSl7IHJldHVybiB9XG5cdFx0XHRcdHZhciB0bXAgPSBjdHgubWF0Y2g7IHRtcC5lbmQgPSAxO1xuXHRcdFx0XHRpZih0bXAgPT09IHJvb3QuaGF0Y2gpeyBpZighKHRtcCA9IGN0eC5sYXRjaCkgfHwgdG1wLmVuZCl7IGRlbGV0ZSByb290LmhhdGNoIH0gZWxzZSB7IHJvb3QuaGF0Y2ggPSB0bXAgfSB9XG5cdFx0XHRcdGN0eC5oYXRjaCAmJiBjdHguaGF0Y2goKTsgLy8gVE9ETzogcmVuYW1lL3Jld29yayBob3cgcHV0ICYgdGhpcyBpbnRlcmFjdC5cblx0XHRcdFx0c2V0VGltZW91dC5lYWNoKGN0eC5tYXRjaCwgZnVuY3Rpb24oY2Ipe2NiICYmIGNiKCl9KTsgXG5cdFx0XHRcdGlmKCEobXNnID0gY3R4Lm1zZykgfHwgY3R4LmVyciB8fCBtc2cuZXJyKXsgcmV0dXJuIH1cblx0XHRcdFx0bXNnLm91dCA9IHVuaXZlcnNlO1xuXHRcdFx0XHRjdHgucm9vdC5vbignb3V0JywgbXNnKTtcblxuXHRcdFx0XHRDRigpOyAvLyBjb3VydGVzeSBjaGVjaztcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIGFjayhtc2cpeyAvLyBhZ2dyZWdhdGUgQUNLcy5cblx0XHRcdFx0dmFyIGlkID0gbXNnWydAJ10gfHwgJycsIGN0eCwgb2ssIHRtcDtcblx0XHRcdFx0aWYoIShjdHggPSBpZC5fKSl7XG5cdFx0XHRcdFx0dmFyIGR1cCA9IChkdXAgPSBtc2cuJCkgJiYgKGR1cCA9IGR1cC5fKSAmJiAoZHVwID0gZHVwLnJvb3QpICYmIChkdXAgPSBkdXAuZHVwKTtcblx0XHRcdFx0XHRpZighKGR1cCA9IGR1cC5jaGVjayhpZCkpKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRtc2dbJ0AnXSA9IGR1cFsnIyddIHx8IG1zZ1snQCddOyAvLyBUaGlzIGRvZXNuJ3QgZG8gYW55dGhpbmcgYW55bW9yZSwgYmFja3RyYWNrIGl0IHRvIHNvbWV0aGluZyBlbHNlP1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguYWNrcyA9IChjdHguYWNrc3x8MCkgKyAxO1xuXHRcdFx0XHRpZihjdHguZXJyID0gbXNnLmVycil7XG5cdFx0XHRcdFx0bXNnWydAJ10gPSBjdHhbJyMnXTtcblx0XHRcdFx0XHRmaXJlKGN0eCk7IC8vIFRPRE86IEJVRz8gSG93IGl0IHNraXBzL3N0b3BzIHByb3BhZ2F0aW9uIG9mIG1zZyBpZiBhbnkgMSBpdGVtIGlzIGVycm9yLCB0aGlzIHdvdWxkIGFzc3VtZSBhIHdob2xlIGJhdGNoL3Jlc3luYyBoYXMgc2FtZSBtYWxpY2lvdXMgaW50ZW50LlxuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5vayA9IG1zZy5vayB8fCBjdHgub2s7XG5cdFx0XHRcdGlmKCFjdHguc3RvcCAmJiAhY3R4LmNyYWNrKXsgY3R4LmNyYWNrID0gY3R4Lm1hdGNoICYmIGN0eC5tYXRjaC5wdXNoKGZ1bmN0aW9uKCl7YmFjayhjdHgpfSkgfSAvLyBoYW5kbGUgc3luY2hyb25vdXMgYWNrcy4gTk9URTogSWYgYSBzdG9yYWdlIHBlZXIgQUNLcyBzeW5jaHJvbm91c2x5IHRoZW4gdGhlIFBVVCBsb29wIGhhcyBub3QgZXZlbiBjb3VudGVkIHVwIGhvdyBtYW55IGl0ZW1zIG5lZWQgdG8gYmUgcHJvY2Vzc2VkLCBzbyBjdHguU1RPUCBmbGFncyB0aGlzIGFuZCBhZGRzIG9ubHkgMSBjYWxsYmFjayB0byB0aGUgZW5kIG9mIHRoZSBQVVQgbG9vcC5cblx0XHRcdFx0YmFjayhjdHgpO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gYmFjayhjdHgpe1xuXHRcdFx0XHRpZighY3R4IHx8ICFjdHgucm9vdCl7IHJldHVybiB9XG5cdFx0XHRcdGlmKGN0eC5zdHVuIHx8IGN0eC5hY2tzICE9PSBjdHguYWxsKXsgcmV0dXJuIH1cblx0XHRcdFx0Y3R4LnJvb3Qub24oJ2luJywgeydAJzogY3R4WycjJ10sIGVycjogY3R4LmVyciwgb2s6IGN0eC5lcnI/IHUgOiBjdHgub2sgfHwgeycnOjF9fSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBFUlIgPSBcIkVycm9yOiBJbnZhbGlkIGdyYXBoIVwiO1xuXHRcdFx0dmFyIGN1dCA9IGZ1bmN0aW9uKHMpeyByZXR1cm4gXCIgJ1wiKygnJytzKS5zbGljZSgwLDkpK1wiLi4uJyBcIiB9XG5cdFx0XHR2YXIgTCA9IEpTT04uc3RyaW5naWZ5LCBNRCA9IDIxNDc0ODM2NDcsIFN0YXRlID0gR3VuLnN0YXRlO1xuXHRcdFx0dmFyIEMgPSAwLCBDVCwgQ0YgPSBmdW5jdGlvbigpe2lmKEM+OTk5ICYmIChDLy0oQ1QgLSAoQ1QgPSArbmV3IERhdGUpKT4xKSl7R3VuLndpbmRvdyAmJiBjb25zb2xlLmxvZyhcIldhcm5pbmc6IFlvdSdyZSBzeW5jaW5nIDFLKyByZWNvcmRzIGEgc2Vjb25kLCBmYXN0ZXIgdGhhbiBET00gY2FuIHVwZGF0ZSAtIGNvbnNpZGVyIGxpbWl0aW5nIHF1ZXJ5LlwiKTtDRj1mdW5jdGlvbigpe0M9MH19fTtcblxuXHRcdH0oKSk7XG5cblx0XHQ7KGZ1bmN0aW9uKCl7XG5cdFx0XHRHdW4ub24uZ2V0ID0gZnVuY3Rpb24obXNnLCBndW4pe1xuXHRcdFx0XHR2YXIgcm9vdCA9IGd1bi5fLCBnZXQgPSBtc2cuZ2V0LCBzb3VsID0gZ2V0WycjJ10sIG5vZGUgPSByb290LmdyYXBoW3NvdWxdLCBoYXMgPSBnZXRbJy4nXTtcblx0XHRcdFx0dmFyIG5leHQgPSByb290Lm5leHQgfHwgKHJvb3QubmV4dCA9IHt9KSwgYXQgPSBuZXh0W3NvdWxdO1xuXG5cdFx0XHRcdC8vIFRPRE86IEF6YXJhdHR1bSBidWcsIHdoYXQgaXMgaW4gZ3JhcGggaXMgbm90IHNhbWUgYXMgd2hhdCBpcyBpbiBuZXh0LiBGaXghXG5cblx0XHRcdFx0Ly8gcXVldWUgY29uY3VycmVudCBHRVRzP1xuXHRcdFx0XHQvLyBUT0RPOiBjb25zaWRlciB0YWdnaW5nIG9yaWdpbmFsIG1lc3NhZ2UgaW50byBkdXAgZm9yIERBTS5cblx0XHRcdFx0Ly8gVE9ETzogXiBhYm92ZT8gSW4gY2hhdCBhcHAsIDEyIG1lc3NhZ2VzIHJlc3VsdGVkIGluIHNhbWUgcGVlciBhc2tpbmcgZm9yIGAjdXNlci5wdWJgIDEyIHRpbWVzLiAoc2FtZSB3aXRoICN1c2VyIEdFVCB0b28sIHlpcGVzISkgLy8gREFNIG5vdGU6IFRoaXMgYWxzbyByZXN1bHRlZCBpbiAxMiByZXBsaWVzIGZyb20gMSBwZWVyIHdoaWNoIGFsbCBoYWQgc2FtZSAjI2hhc2ggYnV0IG5vbmUgb2YgdGhlbSBkZWR1cGVkIGJlY2F1c2UgZWFjaCBnZXQgd2FzIGRpZmZlcmVudC5cblx0XHRcdFx0Ly8gVE9ETzogTW92aW5nIHF1aWNrIGhhY2tzIGZpeGluZyB0aGVzZSB0aGluZ3MgdG8gYXhlIGZvciBub3cuXG5cdFx0XHRcdC8vIFRPRE86IGEgbG90IG9mIEdFVCAjZm9vIHRoZW4gR0VUICNmb28uXCJcIiBoYXBwZW5pbmcsIHdoeT9cblx0XHRcdFx0Ly8gVE9ETzogREFNJ3MgIyMgaGFzaCBjaGVjaywgb24gc2FtZSBnZXQgQUNLLCBwcm9kdWNpbmcgbXVsdGlwbGUgcmVwbGllcyBzdGlsbCwgbWF5YmUgSlNPTiB2cyBZU09OP1xuXHRcdFx0XHQvLyBUTVAgbm90ZSBmb3Igbm93OiB2aU1acTFzbEcgd2FzIGNoYXQgTEVYIHF1ZXJ5ICMuXG5cdFx0XHRcdC8qaWYoZ3VuICE9PSAodG1wID0gbXNnLiQpICYmICh0bXAgPSAodG1wfHwnJykuXykpe1xuXHRcdFx0XHRcdGlmKHRtcC5RKXsgdG1wLlFbbXNnWycjJ11dID0gJyc7IHJldHVybiB9IC8vIGNoYWluIGRvZXMgbm90IG5lZWQgdG8gYXNrIGZvciBpdCBhZ2Fpbi5cblx0XHRcdFx0XHR0bXAuUSA9IHt9O1xuXHRcdFx0XHR9Ki9cblx0XHRcdFx0LyppZih1ID09PSBoYXMpe1xuXHRcdFx0XHRcdGlmKGF0LlEpe1xuXHRcdFx0XHRcdFx0Ly9hdC5RW21zZ1snIyddXSA9ICcnO1xuXHRcdFx0XHRcdFx0Ly9yZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGF0LlEgPSB7fTtcblx0XHRcdFx0fSovXG5cdFx0XHRcdHZhciBjdHggPSBtc2cuX3x8e30sIERCRyA9IGN0eC5EQkcgPSBtc2cuREJHO1xuXHRcdFx0XHREQkcgJiYgKERCRy5nID0gK25ldyBEYXRlKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIkdFVDpcIiwgZ2V0LCBub2RlLCBoYXMsIGF0KTtcblx0XHRcdFx0Ly9pZighbm9kZSAmJiAhYXQpeyByZXR1cm4gcm9vdC5vbignZ2V0JywgbXNnKSB9XG5cdFx0XHRcdC8vaWYoaGFzICYmIG5vZGUpeyAvLyByZXBsYWNlIDIgYmVsb3cgbGluZXMgdG8gY29udGludWUgZGV2P1xuXHRcdFx0XHRpZighbm9kZSl7IHJldHVybiByb290Lm9uKCdnZXQnLCBtc2cpIH1cblx0XHRcdFx0aWYoaGFzKXtcblx0XHRcdFx0XHRpZignc3RyaW5nJyAhPSB0eXBlb2YgaGFzIHx8IHUgPT09IG5vZGVbaGFzXSl7XG5cdFx0XHRcdFx0XHRpZighKChhdHx8JycpLm5leHR8fCcnKVtoYXNdKXsgcm9vdC5vbignZ2V0JywgbXNnKTsgcmV0dXJuIH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZSA9IHN0YXRlX2lmeSh7fSwgaGFzLCBzdGF0ZV9pcyhub2RlLCBoYXMpLCBub2RlW2hhc10sIHNvdWwpO1xuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBrZXkgaW4tbWVtb3J5LCBkbyB3ZSByZWFsbHkgbmVlZCB0byBmZXRjaD9cblx0XHRcdFx0XHQvLyBNYXliZS4uLiBpbiBjYXNlIHRoZSBpbi1tZW1vcnkga2V5IHdlIGhhdmUgaXMgYSBsb2NhbCB3cml0ZVxuXHRcdFx0XHRcdC8vIHdlIHN0aWxsIG5lZWQgdG8gdHJpZ2dlciBhIHB1bGwvbWVyZ2UgZnJvbSBwZWVycy5cblx0XHRcdFx0fVxuXHRcdFx0XHQvL0d1bi53aW5kb3c/IEd1bi5vYmouY29weShub2RlKSA6IG5vZGU7IC8vIEhOUEVSRjogSWYgIWJyb3dzZXIgYnVtcCBQZXJmb3JtYW5jZT8gSXMgdGhpcyB0b28gZGFuZ2Vyb3VzIHRvIHJlZmVyZW5jZSByb290IGdyYXBoPyBDb3B5IC8gc2hhbGxvdyBjb3B5IHRvbyBleHBlbnNpdmUgZm9yIGJpZyBub2Rlcy4gR3VuLm9iai50byhub2RlKTsgLy8gMSBsYXllciBkZWVwIGNvcHkgLy8gR3VuLm9iai5jb3B5KG5vZGUpOyAvLyB0b28gc2xvdyBvbiBiaWcgbm9kZXNcblx0XHRcdFx0bm9kZSAmJiBhY2sobXNnLCBub2RlKTtcblx0XHRcdFx0cm9vdC5vbignZ2V0JywgbXNnKTsgLy8gc2VuZCBHRVQgdG8gc3RvcmFnZSBhZGFwdGVycy5cblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIGFjayhtc2csIG5vZGUpe1xuXHRcdFx0XHR2YXIgUyA9ICtuZXcgRGF0ZSwgY3R4ID0gbXNnLl98fHt9LCBEQkcgPSBjdHguREJHID0gbXNnLkRCRztcblx0XHRcdFx0dmFyIHRvID0gbXNnWycjJ10sIGlkID0gdGV4dF9yYW5kKDkpLCBrZXlzID0gT2JqZWN0LmtleXMobm9kZXx8JycpLnNvcnQoKSwgc291bCA9ICgobm9kZXx8JycpLl98fCcnKVsnIyddLCBrbCA9IGtleXMubGVuZ3RoLCBqID0gMCwgcm9vdCA9IG1zZy4kLl8ucm9vdCwgRiA9IChub2RlID09PSByb290LmdyYXBoW3NvdWxdKTtcblx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCAoKERCR3x8Y3R4KS5nayA9ICtuZXcgRGF0ZSkgLSBTLCAnZ290IGtleXMnKTtcblx0XHRcdFx0Ly8gUEVSRjogQ29uc2lkZXIgY29tbWVudGluZyB0aGlzIG91dCB0byBmb3JjZSBkaXNrLW9ubHkgcmVhZHMgZm9yIHBlcmYgdGVzdGluZz8gLy8gVE9ETzogLmtleXMoIGlzIHNsb3dcblx0XHRcdFx0bm9kZSAmJiAoZnVuY3Rpb24gZ28oKXtcblx0XHRcdFx0XHRTID0gK25ldyBEYXRlO1xuXHRcdFx0XHRcdHZhciBpID0gMCwgaywgcHV0ID0ge30sIHRtcDtcblx0XHRcdFx0XHR3aGlsZShpIDwgOSAmJiAoayA9IGtleXNbaSsrXSkpe1xuXHRcdFx0XHRcdFx0c3RhdGVfaWZ5KHB1dCwgaywgc3RhdGVfaXMobm9kZSwgayksIG5vZGVba10sIHNvdWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRrZXlzID0ga2V5cy5zbGljZShpKTtcblx0XHRcdFx0XHQodG1wID0ge30pW3NvdWxdID0gcHV0OyBwdXQgPSB0bXA7XG5cdFx0XHRcdFx0dmFyIGZhaXRoOyBpZihGKXsgZmFpdGggPSBmdW5jdGlvbigpe307IGZhaXRoLnJhbSA9IGZhaXRoLmZhaXRoID0gdHJ1ZTsgfSAvLyBITlBFUkY6IFdlJ3JlIHRlc3RpbmcgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQgYnkgc2tpcHBpbmcgZ29pbmcgdGhyb3VnaCBzZWN1cml0eSBhZ2FpbiwgYnV0IHRoaXMgc2hvdWxkIGJlIGF1ZGl0ZWQuXG5cdFx0XHRcdFx0dG1wID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCAtKFMgLSAoUyA9ICtuZXcgRGF0ZSkpLCAnZ290IGNvcGllZCBzb21lJyk7XG5cdFx0XHRcdFx0REJHICYmIChEQkcuZ2EgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRcdHJvb3Qub24oJ2luJywgeydAJzogdG8sICcjJzogaWQsIHB1dDogcHV0LCAnJSc6ICh0bXA/IChpZCA9IHRleHRfcmFuZCg5KSkgOiB1KSwgJDogcm9vdC4kLCBfOiBmYWl0aCwgREJHOiBEQkcsIEZPTzogMX0pO1xuXHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgK25ldyBEYXRlIC0gUywgJ2dvdCBpbicpO1xuXHRcdFx0XHRcdGlmKCF0bXApeyByZXR1cm4gfVxuXHRcdFx0XHRcdHNldFRpbWVvdXQudHVybihnbyk7XG5cdFx0XHRcdH0oKSk7XG5cdFx0XHRcdGlmKCFub2RlKXsgcm9vdC5vbignaW4nLCB7J0AnOiBtc2dbJyMnXX0pIH0gLy8gVE9ETzogSSBkb24ndCB0aGluayBJIGxpa2UgdGhpcywgdGhlIGRlZmF1bHQgbFMgYWRhcHRlciB1c2VzIHRoaXMgYnV0IFwibm90IGZvdW5kXCIgaXMgYSBzZW5zaXRpdmUgaXNzdWUsIHNvIHNob3VsZCBwcm9iYWJseSBiZSBoYW5kbGVkIG1vcmUgY2FyZWZ1bGx5L2luZGl2aWR1YWxseS5cblx0XHRcdH0gR3VuLm9uLmdldC5hY2sgPSBhY2s7XG5cdFx0fSgpKTtcblxuXHRcdDsoZnVuY3Rpb24oKXtcblx0XHRcdEd1bi5jaGFpbi5vcHQgPSBmdW5jdGlvbihvcHQpe1xuXHRcdFx0XHRvcHQgPSBvcHQgfHwge307XG5cdFx0XHRcdHZhciBndW4gPSB0aGlzLCBhdCA9IGd1bi5fLCB0bXAgPSBvcHQucGVlcnMgfHwgb3B0O1xuXHRcdFx0XHRpZighT2JqZWN0LnBsYWluKG9wdCkpeyBvcHQgPSB7fSB9XG5cdFx0XHRcdGlmKCFPYmplY3QucGxhaW4oYXQub3B0KSl7IGF0Lm9wdCA9IG9wdCB9XG5cdFx0XHRcdGlmKCdzdHJpbmcnID09IHR5cGVvZiB0bXApeyB0bXAgPSBbdG1wXSB9XG5cdFx0XHRcdGlmKCFPYmplY3QucGxhaW4oYXQub3B0LnBlZXJzKSl7IGF0Lm9wdC5wZWVycyA9IHt9fVxuXHRcdFx0XHRpZih0bXAgaW5zdGFuY2VvZiBBcnJheSl7XG5cdFx0XHRcdFx0b3B0LnBlZXJzID0ge307XG5cdFx0XHRcdFx0dG1wLmZvckVhY2goZnVuY3Rpb24odXJsKXtcblx0XHRcdFx0XHRcdHZhciBwID0ge307IHAuaWQgPSBwLnVybCA9IHVybDtcblx0XHRcdFx0XHRcdG9wdC5wZWVyc1t1cmxdID0gYXQub3B0LnBlZXJzW3VybF0gPSBhdC5vcHQucGVlcnNbdXJsXSB8fCBwO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdFx0b2JqX2VhY2gob3B0LCBmdW5jdGlvbiBlYWNoKGspeyB2YXIgdiA9IHRoaXNba107XG5cdFx0XHRcdFx0aWYoKHRoaXMgJiYgdGhpcy5oYXNPd25Qcm9wZXJ0eShrKSkgfHwgJ3N0cmluZycgPT0gdHlwZW9mIHYgfHwgT2JqZWN0LmVtcHR5KHYpKXsgdGhpc1trXSA9IHY7IHJldHVybiB9XG5cdFx0XHRcdFx0aWYodiAmJiB2LmNvbnN0cnVjdG9yICE9PSBPYmplY3QgJiYgISh2IGluc3RhbmNlb2YgQXJyYXkpKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRvYmpfZWFjaCh2LCBlYWNoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGF0Lm9wdC5mcm9tID0gb3B0O1xuXHRcdFx0XHRHdW4ub24oJ29wdCcsIGF0KTtcblx0XHRcdFx0YXQub3B0LnV1aWQgPSBhdC5vcHQudXVpZCB8fCBmdW5jdGlvbiB1dWlkKGwpeyByZXR1cm4gR3VuLnN0YXRlKCkudG9TdHJpbmcoMzYpLnJlcGxhY2UoJy4nLCcnKSArIFN0cmluZy5yYW5kb20obHx8MTIpIH1cblx0XHRcdFx0cmV0dXJuIGd1bjtcblx0XHRcdH1cblx0XHR9KCkpO1xuXG5cdFx0dmFyIG9ial9lYWNoID0gZnVuY3Rpb24obyxmKXsgT2JqZWN0LmtleXMobykuZm9yRWFjaChmLG8pIH0sIHRleHRfcmFuZCA9IFN0cmluZy5yYW5kb20sIHR1cm4gPSBzZXRUaW1lb3V0LnR1cm4sIHZhbGlkID0gR3VuLnZhbGlkLCBzdGF0ZV9pcyA9IEd1bi5zdGF0ZS5pcywgc3RhdGVfaWZ5ID0gR3VuLnN0YXRlLmlmeSwgdSwgZW1wdHkgPSB7fSwgQztcblxuXHRcdEd1bi5sb2cgPSBmdW5jdGlvbigpeyByZXR1cm4gKCFHdW4ubG9nLm9mZiAmJiBDLmxvZy5hcHBseShDLCBhcmd1bWVudHMpKSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKSB9O1xuXHRcdEd1bi5sb2cub25jZSA9IGZ1bmN0aW9uKHcscyxvKXsgcmV0dXJuIChvID0gR3VuLmxvZy5vbmNlKVt3XSA9IG9bd10gfHwgMCwgb1t3XSsrIHx8IEd1bi5sb2cocykgfTtcblxuXHRcdGlmKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpeyAod2luZG93LkdVTiA9IHdpbmRvdy5HdW4gPSBHdW4pLndpbmRvdyA9IHdpbmRvdyB9XG5cdFx0dHJ5eyBpZih0eXBlb2YgTU9EVUxFICE9PSBcInVuZGVmaW5lZFwiKXsgTU9EVUxFLmV4cG9ydHMgPSBHdW4gfSB9Y2F0Y2goZSl7fVxuXHRcdG1vZHVsZS5leHBvcnRzID0gR3VuO1xuXHRcdFxuXHRcdChHdW4ud2luZG93fHx7fSkuY29uc29sZSA9IChHdW4ud2luZG93fHx7fSkuY29uc29sZSB8fCB7bG9nOiBmdW5jdGlvbigpe319O1xuXHRcdChDID0gY29uc29sZSkub25seSA9IGZ1bmN0aW9uKGksIHMpeyByZXR1cm4gKEMub25seS5pICYmIGkgPT09IEMub25seS5pICYmIEMub25seS5pKyspICYmIChDLmxvZy5hcHBseShDLCBhcmd1bWVudHMpIHx8IHMpIH07XG5cblx0XHQ7XCJQbGVhc2UgZG8gbm90IHJlbW92ZSB3ZWxjb21lIGxvZyB1bmxlc3MgeW91IGFyZSBwYXlpbmcgZm9yIGEgbW9udGhseSBzcG9uc29yc2hpcCwgdGhhbmtzIVwiO1xuXHRcdEd1bi5sb2cub25jZShcIndlbGNvbWVcIiwgXCJIZWxsbyB3b25kZXJmdWwgcGVyc29uISA6KSBUaGFua3MgZm9yIHVzaW5nIEdVTiwgcGxlYXNlIGFzayBmb3IgaGVscCBvbiBodHRwOi8vY2hhdC5ndW4uZWNvIGlmIGFueXRoaW5nIHRha2VzIHlvdSBsb25nZXIgdGhhbiA1bWluIHRvIGZpZ3VyZSBvdXQhXCIpO1xuXHR9KShVU0UsICcuL3Jvb3QnKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0dmFyIEd1biA9IFVTRSgnLi9yb290Jyk7XG5cdFx0R3VuLmNoYWluLmJhY2sgPSBmdW5jdGlvbihuLCBvcHQpeyB2YXIgdG1wO1xuXHRcdFx0biA9IG4gfHwgMTtcblx0XHRcdGlmKC0xID09PSBuIHx8IEluZmluaXR5ID09PSBuKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuXy5yb290LiQ7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmKDEgPT09IG4pe1xuXHRcdFx0XHRyZXR1cm4gKHRoaXMuXy5iYWNrIHx8IHRoaXMuXykuJDtcblx0XHRcdH1cblx0XHRcdHZhciBndW4gPSB0aGlzLCBhdCA9IGd1bi5fO1xuXHRcdFx0aWYodHlwZW9mIG4gPT09ICdzdHJpbmcnKXtcblx0XHRcdFx0biA9IG4uc3BsaXQoJy4nKTtcblx0XHRcdH1cblx0XHRcdGlmKG4gaW5zdGFuY2VvZiBBcnJheSl7XG5cdFx0XHRcdHZhciBpID0gMCwgbCA9IG4ubGVuZ3RoLCB0bXAgPSBhdDtcblx0XHRcdFx0Zm9yKGk7IGkgPCBsOyBpKyspe1xuXHRcdFx0XHRcdHRtcCA9ICh0bXB8fGVtcHR5KVtuW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih1ICE9PSB0bXApe1xuXHRcdFx0XHRcdHJldHVybiBvcHQ/IGd1biA6IHRtcDtcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdGlmKCh0bXAgPSBhdC5iYWNrKSl7XG5cdFx0XHRcdFx0cmV0dXJuIHRtcC4kLmJhY2sobiwgb3B0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZignZnVuY3Rpb24nID09IHR5cGVvZiBuKXtcblx0XHRcdFx0dmFyIHllcywgdG1wID0ge2JhY2s6IGF0fTtcblx0XHRcdFx0d2hpbGUoKHRtcCA9IHRtcC5iYWNrKVxuXHRcdFx0XHQmJiB1ID09PSAoeWVzID0gbih0bXAsIG9wdCkpKXt9XG5cdFx0XHRcdHJldHVybiB5ZXM7XG5cdFx0XHR9XG5cdFx0XHRpZignbnVtYmVyJyA9PSB0eXBlb2Ygbil7XG5cdFx0XHRcdHJldHVybiAoYXQuYmFjayB8fCBhdCkuJC5iYWNrKG4gLSAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR2YXIgZW1wdHkgPSB7fSwgdTtcblx0fSkoVVNFLCAnLi9iYWNrJyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdC8vIFdBUk5JTkc6IEdVTiBpcyB2ZXJ5IHNpbXBsZSwgYnV0IHRoZSBKYXZhU2NyaXB0IGNoYWluaW5nIEFQSSBhcm91bmQgR1VOXG5cdFx0Ly8gaXMgY29tcGxpY2F0ZWQgYW5kIHdhcyBleHRyZW1lbHkgaGFyZCB0byBidWlsZC4gSWYgeW91IHBvcnQgR1VOIHRvIGFub3RoZXJcblx0XHQvLyBsYW5ndWFnZSwgY29uc2lkZXIgaW1wbGVtZW50aW5nIGFuIGVhc2llciBBUEkgdG8gYnVpbGQuXG5cdFx0dmFyIEd1biA9IFVTRSgnLi9yb290Jyk7XG5cdFx0R3VuLmNoYWluLmNoYWluID0gZnVuY3Rpb24oc3ViKXtcblx0XHRcdHZhciBndW4gPSB0aGlzLCBhdCA9IGd1bi5fLCBjaGFpbiA9IG5ldyAoc3ViIHx8IGd1bikuY29uc3RydWN0b3IoZ3VuKSwgY2F0ID0gY2hhaW4uXywgcm9vdDtcblx0XHRcdGNhdC5yb290ID0gcm9vdCA9IGF0LnJvb3Q7XG5cdFx0XHRjYXQuaWQgPSArK3Jvb3Qub25jZTtcblx0XHRcdGNhdC5iYWNrID0gZ3VuLl87XG5cdFx0XHRjYXQub24gPSBHdW4ub247XG5cdFx0XHRjYXQub24oJ2luJywgR3VuLm9uLmluLCBjYXQpOyAvLyBGb3IgJ2luJyBpZiBJIGFkZCBteSBvd24gbGlzdGVuZXJzIHRvIGVhY2ggdGhlbiBJIE1VU1QgZG8gaXQgYmVmb3JlIGluIGdldHMgY2FsbGVkLiBJZiBJIGxpc3RlbiBnbG9iYWxseSBmb3IgYWxsIGluY29taW5nIGRhdGEgaW5zdGVhZCB0aG91Z2gsIHJlZ2FyZGxlc3Mgb2YgaW5kaXZpZHVhbCBsaXN0ZW5lcnMsIEkgY2FuIHRyYW5zZm9ybSB0aGUgZGF0YSB0aGVyZSBhbmQgdGhlbiBhcyB3ZWxsLlxuXHRcdFx0Y2F0Lm9uKCdvdXQnLCBHdW4ub24ub3V0LCBjYXQpOyAvLyBIb3dldmVyIGZvciBvdXRwdXQsIHRoZXJlIGlzbid0IHJlYWxseSB0aGUgZ2xvYmFsIG9wdGlvbi4gSSBtdXN0IGxpc3RlbiBieSBhZGRpbmcgbXkgb3duIGxpc3RlbmVyIGluZGl2aWR1YWxseSBCRUZPUkUgdGhpcyBvbmUgaXMgZXZlciBjYWxsZWQuXG5cdFx0XHRyZXR1cm4gY2hhaW47XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb3V0cHV0KG1zZyl7XG5cdFx0XHR2YXIgcHV0LCBnZXQsIGF0ID0gdGhpcy5hcywgYmFjayA9IGF0LmJhY2ssIHJvb3QgPSBhdC5yb290LCB0bXA7XG5cdFx0XHRpZighbXNnLiQpeyBtc2cuJCA9IGF0LiQgfVxuXHRcdFx0dGhpcy50by5uZXh0KG1zZyk7XG5cdFx0XHRpZihhdC5lcnIpeyBhdC5vbignaW4nLCB7cHV0OiBhdC5wdXQgPSB1LCAkOiBhdC4kfSk7IHJldHVybiB9XG5cdFx0XHRpZihnZXQgPSBtc2cuZ2V0KXtcblx0XHRcdFx0LyppZih1ICE9PSBhdC5wdXQpe1xuXHRcdFx0XHRcdGF0Lm9uKCdpbicsIGF0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0qL1xuXHRcdFx0XHRpZihyb290LnBhc3MpeyByb290LnBhc3NbYXQuaWRdID0gYXQ7IH0gLy8gd2lsbCB0aGlzIG1ha2UgZm9yIGJ1Z2d5IGJlaGF2aW9yIGVsc2V3aGVyZT9cblx0XHRcdFx0aWYoYXQubGV4KXsgT2JqZWN0LmtleXMoYXQubGV4KS5mb3JFYWNoKGZ1bmN0aW9uKGspeyB0bXBba10gPSBhdC5sZXhba10gfSwgdG1wID0gbXNnLmdldCA9IG1zZy5nZXQgfHwge30pIH1cblx0XHRcdFx0aWYoZ2V0WycjJ10gfHwgYXQuc291bCl7XG5cdFx0XHRcdFx0Z2V0WycjJ10gPSBnZXRbJyMnXSB8fCBhdC5zb3VsO1xuXHRcdFx0XHRcdC8vcm9vdC5ncmFwaFtnZXRbJyMnXV0gPSByb290LmdyYXBoW2dldFsnIyddXSB8fCB7Xzp7JyMnOmdldFsnIyddLCc+Jzp7fX19O1xuXHRcdFx0XHRcdG1zZ1snIyddIHx8IChtc2dbJyMnXSA9IHRleHRfcmFuZCg5KSk7IC8vIEEzMTIwID9cblx0XHRcdFx0XHRiYWNrID0gKHJvb3QuJC5nZXQoZ2V0WycjJ10pLl8pO1xuXHRcdFx0XHRcdGlmKCEoZ2V0ID0gZ2V0WycuJ10pKXsgLy8gc291bFxuXHRcdFx0XHRcdFx0dG1wID0gYmFjay5hc2sgJiYgYmFjay5hc2tbJyddOyAvLyBjaGVjayBpZiB3ZSBoYXZlIGFscmVhZHkgYXNrZWQgZm9yIHRoZSBmdWxsIG5vZGVcblx0XHRcdFx0XHRcdChiYWNrLmFzayB8fCAoYmFjay5hc2sgPSB7fSkpWycnXSA9IGJhY2s7IC8vIGFkZCBhIGZsYWcgdGhhdCB3ZSBhcmUgbm93LlxuXHRcdFx0XHRcdFx0aWYodSAhPT0gYmFjay5wdXQpeyAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgZGF0YSxcblx0XHRcdFx0XHRcdFx0YmFjay5vbignaW4nLCBiYWNrKTsgLy8gc2VuZCB3aGF0IGlzIGNhY2hlZCBkb3duIHRoZSBjaGFpblxuXHRcdFx0XHRcdFx0XHRpZih0bXApeyByZXR1cm4gfSAvLyBhbmQgZG9uJ3QgYXNrIGZvciBpdCBhZ2Fpbi5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1zZy4kID0gYmFjay4kO1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdGlmKG9ial9oYXMoYmFjay5wdXQsIGdldCkpeyAvLyBUT0RPOiBzdXBwb3J0ICNMRVggIVxuXHRcdFx0XHRcdFx0dG1wID0gYmFjay5hc2sgJiYgYmFjay5hc2tbZ2V0XTtcblx0XHRcdFx0XHRcdChiYWNrLmFzayB8fCAoYmFjay5hc2sgPSB7fSkpW2dldF0gPSBiYWNrLiQuZ2V0KGdldCkuXztcblx0XHRcdFx0XHRcdGJhY2sub24oJ2luJywge2dldDogZ2V0LCBwdXQ6IHsnIyc6IGJhY2suc291bCwgJy4nOiBnZXQsICc6JzogYmFjay5wdXRbZ2V0XSwgJz4nOiBzdGF0ZV9pcyhyb290LmdyYXBoW2JhY2suc291bF0sIGdldCl9fSk7XG5cdFx0XHRcdFx0XHRpZih0bXApeyByZXR1cm4gfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8qcHV0ID0gKGJhY2suJC5nZXQoZ2V0KS5fKTtcblx0XHRcdFx0XHRcdGlmKCEodG1wID0gcHV0LmFjaykpeyBwdXQuYWNrID0gLTEgfVxuXHRcdFx0XHRcdFx0YmFjay5vbignaW4nLCB7XG5cdFx0XHRcdFx0XHRcdCQ6IGJhY2suJCxcblx0XHRcdFx0XHRcdFx0cHV0OiBHdW4uc3RhdGUuaWZ5KHt9LCBnZXQsIEd1bi5zdGF0ZShiYWNrLnB1dCwgZ2V0KSwgYmFjay5wdXRbZ2V0XSksXG5cdFx0XHRcdFx0XHRcdGdldDogYmFjay5nZXRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0aWYodG1wKXsgcmV0dXJuIH1cblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRpZignc3RyaW5nJyAhPSB0eXBlb2YgZ2V0KXtcblx0XHRcdFx0XHRcdHZhciBwdXQgPSB7fSwgbWV0YSA9IChiYWNrLnB1dHx8e30pLl87XG5cdFx0XHRcdFx0XHRHdW4ub2JqLm1hcChiYWNrLnB1dCwgZnVuY3Rpb24odixrKXtcblx0XHRcdFx0XHRcdFx0aWYoIUd1bi50ZXh0Lm1hdGNoKGssIGdldCkpeyByZXR1cm4gfVxuXHRcdFx0XHRcdFx0XHRwdXRba10gPSB2O1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdGlmKCFHdW4ub2JqLmVtcHR5KHB1dCkpe1xuXHRcdFx0XHRcdFx0XHRwdXQuXyA9IG1ldGE7XG5cdFx0XHRcdFx0XHRcdGJhY2sub24oJ2luJywgeyQ6IGJhY2suJCwgcHV0OiBwdXQsIGdldDogYmFjay5nZXR9KVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYodG1wID0gYXQubGV4KXtcblx0XHRcdFx0XHRcdFx0dG1wID0gKHRtcC5fKSB8fCAodG1wLl8gPSBmdW5jdGlvbigpe30pO1xuXHRcdFx0XHRcdFx0XHRpZihiYWNrLmFjayA8IHRtcC5hc2speyB0bXAuYXNrID0gYmFjay5hY2sgfVxuXHRcdFx0XHRcdFx0XHRpZih0bXAuYXNrKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRcdFx0dG1wLmFzayA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0cm9vdC5hc2soYWNrLCBtc2cpOyAvLyBBMzEyMCA/XG5cdFx0XHRcdFx0cmV0dXJuIHJvb3Qub24oJ2luJywgbXNnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2lmKHJvb3Qubm93KXsgcm9vdC5ub3dbYXQuaWRdID0gcm9vdC5ub3dbYXQuaWRdIHx8IHRydWU7IGF0LnBhc3MgPSB7fSB9XG5cdFx0XHRcdGlmKGdldFsnLiddKXtcblx0XHRcdFx0XHRpZihhdC5nZXQpe1xuXHRcdFx0XHRcdFx0bXNnID0ge2dldDogeycuJzogYXQuZ2V0fSwgJDogYXQuJH07XG5cdFx0XHRcdFx0XHQoYmFjay5hc2sgfHwgKGJhY2suYXNrID0ge30pKVthdC5nZXRdID0gbXNnLiQuXzsgLy8gVE9ETzogUEVSRk9STUFOQ0U/IE1vcmUgZWxlZ2FudCB3YXk/XG5cdFx0XHRcdFx0XHRyZXR1cm4gYmFjay5vbignb3V0JywgbXNnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bXNnID0ge2dldDogYXQubGV4PyBtc2cuZ2V0IDoge30sICQ6IGF0LiR9O1xuXHRcdFx0XHRcdHJldHVybiBiYWNrLm9uKCdvdXQnLCBtc2cpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdChhdC5hc2sgfHwgKGF0LmFzayA9IHt9KSlbJyddID0gYXQ7XHQgLy9hdC5hY2sgPSBhdC5hY2sgfHwgLTE7XG5cdFx0XHRcdGlmKGF0LmdldCl7XG5cdFx0XHRcdFx0Z2V0WycuJ10gPSBhdC5nZXQ7XG5cdFx0XHRcdFx0KGJhY2suYXNrIHx8IChiYWNrLmFzayA9IHt9KSlbYXQuZ2V0XSA9IG1zZy4kLl87IC8vIFRPRE86IFBFUkZPUk1BTkNFPyBNb3JlIGVsZWdhbnQgd2F5P1xuXHRcdFx0XHRcdHJldHVybiBiYWNrLm9uKCdvdXQnLCBtc2cpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYmFjay5vbignb3V0JywgbXNnKTtcblx0XHR9OyBHdW4ub24ub3V0ID0gb3V0cHV0O1xuXG5cdFx0ZnVuY3Rpb24gaW5wdXQobXNnLCBjYXQpeyBjYXQgPSBjYXQgfHwgdGhpcy5hczsgLy8gVE9ETzogVjggbWF5IG5vdCBiZSBhYmxlIHRvIG9wdGltaXplIGZ1bmN0aW9ucyB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXIgY2FsbHMsIHNvIHRyeSB0byBkbyBiZW5jaG1hcmsgdG8gc2VlIGlmIHRoZXJlIGlzIGFueSBhY3R1YWwgZGlmZmVyZW5jZS5cblx0XHRcdHZhciByb290ID0gY2F0LnJvb3QsIGd1biA9IG1zZy4kIHx8IChtc2cuJCA9IGNhdC4kKSwgYXQgPSAoZ3VufHwnJykuXyB8fCBlbXB0eSwgdG1wID0gbXNnLnB1dHx8JycsIHNvdWwgPSB0bXBbJyMnXSwga2V5ID0gdG1wWycuJ10sIGNoYW5nZSA9ICh1ICE9PSB0bXBbJz0nXSk/IHRtcFsnPSddIDogdG1wWyc6J10sIHN0YXRlID0gdG1wWyc+J10gfHwgLUluZmluaXR5LCBzYXQ7IC8vIGV2ZSA9IGV2ZW50LCBhdCA9IGRhdGEgYXQsIGNhdCA9IGNoYWluIGF0LCBzYXQgPSBzdWIgYXQgKGNoaWxkcmVuIGNoYWlucykuXG5cdFx0XHRpZih1ICE9PSBtc2cucHV0ICYmICh1ID09PSB0bXBbJyMnXSB8fCB1ID09PSB0bXBbJy4nXSB8fCAodSA9PT0gdG1wWyc6J10gJiYgdSA9PT0gdG1wWyc9J10pIHx8IHUgPT09IHRtcFsnPiddKSl7IC8vIGNvbnZlcnQgZnJvbSBvbGQgZm9ybWF0XG5cdFx0XHRcdGlmKCF2YWxpZCh0bXApKXtcblx0XHRcdFx0XHRpZighKHNvdWwgPSAoKHRtcHx8JycpLl98fCcnKVsnIyddKSl7IGNvbnNvbGUubG9nKFwiY2hhaW4gbm90IHlldCBzdXBwb3J0ZWQgZm9yXCIsIHRtcCwgJy4uLicsIG1zZywgY2F0KTsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0Z3VuID0gY2F0LnJvb3QuJC5nZXQoc291bCk7XG5cdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQuZWFjaChPYmplY3Qua2V5cyh0bXApLnNvcnQoKSwgZnVuY3Rpb24oayl7IC8vIFRPRE86IC5rZXlzKCBpcyBzbG93IC8vIEJVRz8gP1NvbWUgcmUtaW4gbG9naWMgbWF5IGRlcGVuZCBvbiB0aGlzIGJlaW5nIHN5bmM/XG5cdFx0XHRcdFx0XHRpZignXycgPT0gayB8fCB1ID09PSAoc3RhdGUgPSBzdGF0ZV9pcyh0bXAsIGspKSl7IHJldHVybiB9XG5cdFx0XHRcdFx0XHRjYXQub24oJ2luJywgeyQ6IGd1biwgcHV0OiB7JyMnOiBzb3VsLCAnLic6IGssICc9JzogdG1wW2tdLCAnPic6IHN0YXRlfSwgVklBOiBtc2d9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXQub24oJ2luJywgeyQ6IGF0LmJhY2suJCwgcHV0OiB7JyMnOiBzb3VsID0gYXQuYmFjay5zb3VsLCAnLic6IGtleSA9IGF0LmhhcyB8fCBhdC5nZXQsICc9JzogdG1wLCAnPic6IHN0YXRlX2lzKGF0LmJhY2sucHV0LCBrZXkpfSwgdmlhOiBtc2d9KTsgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBidWdneSEgSXQgYXNzdW1lcy9hcHByb3hlcyBkYXRhLCBvdGhlciBzdHVmZiBjb3VsZCBoYXZlIGNvcnJ1cHRlZCBpdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoKG1zZy5zZWVufHwnJylbY2F0LmlkXSl7IHJldHVybiB9IChtc2cuc2VlbiB8fCAobXNnLnNlZW4gPSBmdW5jdGlvbigpe30pKVtjYXQuaWRdID0gY2F0OyAvLyBoZWxwIHN0b3Agc29tZSBpbmZpbml0ZSBsb29wc1xuXG5cdFx0XHRpZihjYXQgIT09IGF0KXsgLy8gZG9uJ3Qgd29ycnkgYWJvdXQgdGhpcyB3aGVuIGZpcnN0IHVuZGVyc3RhbmRpbmcgdGhlIGNvZGUsIGl0IGhhbmRsZXMgY2hhbmdpbmcgY29udGV4dHMgb24gYSBtZXNzYWdlLiBBIHNvdWwgY2hhaW4gd2lsbCBuZXZlciBoYXZlIGEgZGlmZmVyZW50IGNvbnRleHQuXG5cdFx0XHRcdE9iamVjdC5rZXlzKG1zZykuZm9yRWFjaChmdW5jdGlvbihrKXsgdG1wW2tdID0gbXNnW2tdIH0sIHRtcCA9IHt9KTsgLy8gbWFrZSBjb3B5IG9mIG1lc3NhZ2Vcblx0XHRcdFx0dG1wLmdldCA9IGNhdC5nZXQgfHwgdG1wLmdldDtcblx0XHRcdFx0aWYoIWNhdC5zb3VsICYmICFjYXQuaGFzKXsgLy8gaWYgd2UgZG8gbm90IHJlY29nbml6ZSB0aGUgY2hhaW4gdHlwZVxuXHRcdFx0XHRcdHRtcC4kJCQgPSB0bXAuJCQkIHx8IGNhdC4kOyAvLyBtYWtlIGEgcmVmZXJlbmNlIHRvIHdoZXJldmVyIGl0IGNhbWUgZnJvbS5cblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdGlmKGF0LnNvdWwpeyAvLyBhIGhhcyAocHJvcGVydHkpIGNoYWluIHdpbGwgaGF2ZSBhIGRpZmZlcmVudCBjb250ZXh0IHNvbWV0aW1lcyBpZiBpdCBpcyBsaW5rZWQgKHRvIGEgc291bCBjaGFpbikuIEFueXRoaW5nIHRoYXQgaXMgbm90IGEgc291bCBvciBoYXMgY2hhaW4sIHdpbGwgYWx3YXlzIGhhdmUgZGlmZmVyZW50IGNvbnRleHRzLlxuXHRcdFx0XHRcdHRtcC4kID0gY2F0LiQ7XG5cdFx0XHRcdFx0dG1wLiQkID0gdG1wLiQkIHx8IGF0LiQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0bXNnID0gdG1wOyAvLyB1c2UgdGhlIG1lc3NhZ2Ugd2l0aCB0aGUgbmV3IGNvbnRleHQgaW5zdGVhZDtcblx0XHRcdH1cblx0XHRcdHVubGluayhtc2csIGNhdCk7XG5cblx0XHRcdGlmKCgoY2F0LnNvdWwvKiAmJiAoY2F0LmFza3x8JycpWycnXSovKSB8fCBtc2cuJCQpICYmIHN0YXRlID49IHN0YXRlX2lzKHJvb3QuZ3JhcGhbc291bF0sIGtleSkpeyAvLyBUaGUgcm9vdCBoYXMgYW4gaW4tbWVtb3J5IGNhY2hlIG9mIHRoZSBncmFwaCwgYnV0IGlmIG91ciBwZWVyIGhhcyBhc2tlZCBmb3IgdGhlIGRhdGEgdGhlbiB3ZSB3YW50IGEgcGVyIGRlZHVwbGljYXRlZCBjaGFpbiBjb3B5IG9mIHRoZSBkYXRhIHRoYXQgbWlnaHQgaGF2ZSBsb2NhbCBlZGl0cyBvbiBpdC5cblx0XHRcdFx0KHRtcCA9IHJvb3QuJC5nZXQoc291bCkuXykucHV0ID0gc3RhdGVfaWZ5KHRtcC5wdXQsIGtleSwgc3RhdGUsIGNoYW5nZSwgc291bCk7XG5cdFx0XHR9XG5cdFx0XHRpZighYXQuc291bCAvKiYmIChhdC5hc2t8fCcnKVsnJ10qLyAmJiBzdGF0ZSA+PSBzdGF0ZV9pcyhyb290LmdyYXBoW3NvdWxdLCBrZXkpICYmIChzYXQgPSAocm9vdC4kLmdldChzb3VsKS5fLm5leHR8fCcnKVtrZXldKSl7IC8vIFNhbWUgYXMgYWJvdmUgaGVyZSwgYnV0IGZvciBvdGhlciB0eXBlcyBvZiBjaGFpbnMuIC8vIFRPRE86IEltcHJvdmUgcGVyZiBieSBwcmV2ZW50aW5nIGVjaG9lcyByZWNhY2hpbmcuXG5cdFx0XHRcdHNhdC5wdXQgPSBjaGFuZ2U7IC8vIHVwZGF0ZSBjYWNoZVxuXHRcdFx0XHRpZignc3RyaW5nJyA9PSB0eXBlb2YgKHRtcCA9IHZhbGlkKGNoYW5nZSkpKXtcblx0XHRcdFx0XHRzYXQucHV0ID0gcm9vdC4kLmdldCh0bXApLl8ucHV0IHx8IGNoYW5nZTsgLy8gc2hhcmUgc2FtZSBjYWNoZSBhcyB3aGF0IHdlJ3JlIGxpbmtlZCB0by5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRvICYmIHRoaXMudG8ubmV4dChtc2cpOyAvLyAxc3QgQVBJIGpvYiBpcyB0byBjYWxsIGFsbCBjaGFpbiBsaXN0ZW5lcnMuXG5cdFx0XHQvLyBUT0RPOiBNYWtlIGlucHV0IG1vcmUgcmV1c2FibGUgYnkgb25seSBkb2luZyB0aGVzZSAoc29tZT8pIGNhbGxzIGlmIHdlIGFyZSBhIGNoYWluIHdlIHJlY29nbml6ZT8gVGhpcyBtZWFucyBlYWNoIGlucHV0IGxpc3RlbmVyIHdvdWxkIGJlIHJlc3BvbnNpYmxlIGZvciB3aGVuIGxpc3RlbmVycyBuZWVkIHRvIGJlIGNhbGxlZCwgd2hpY2ggbWFrZXMgc2Vuc2UsIGFzIHRoZXkgbWlnaHQgd2FudCB0byBmaWx0ZXIuXG5cdFx0XHRjYXQuYW55ICYmIHNldFRpbWVvdXQuZWFjaChPYmplY3Qua2V5cyhjYXQuYW55KSwgZnVuY3Rpb24oYW55KXsgKGFueSA9IGNhdC5hbnlbYW55XSkgJiYgYW55KG1zZykgfSwwLDk5KTsgLy8gMXN0IEFQSSBqb2IgaXMgdG8gY2FsbCBhbGwgY2hhaW4gbGlzdGVuZXJzLiAvLyBUT0RPOiAua2V5cyggaXMgc2xvdyAvLyBCVUc6IFNvbWUgcmUtaW4gbG9naWMgbWF5IGRlcGVuZCBvbiB0aGlzIGJlaW5nIHN5bmMuXG5cdFx0XHRjYXQuZWNobyAmJiBzZXRUaW1lb3V0LmVhY2goT2JqZWN0LmtleXMoY2F0LmVjaG8pLCBmdW5jdGlvbihsYXQpeyAobGF0ID0gY2F0LmVjaG9bbGF0XSkgJiYgbGF0Lm9uKCdpbicsIG1zZykgfSwwLDk5KTsgLy8gJiBsaW5rZWQgYXQgY2hhaW5zIC8vIFRPRE86IC5rZXlzKCBpcyBzbG93IC8vIEJVRzogU29tZSByZS1pbiBsb2dpYyBtYXkgZGVwZW5kIG9uIHRoaXMgYmVpbmcgc3luYy5cblxuXHRcdFx0aWYoKChtc2cuJCR8fCcnKS5ffHxhdCkuc291bCl7IC8vIGNvbW1lbnRzIGFyZSBsaW5lYXIsIGJ1dCB0aGlzIGxpbmUgb2YgY29kZSBpcyBub24tbGluZWFyLCBzbyBpZiBJIHdlcmUgdG8gY29tbWVudCB3aGF0IGl0IGRvZXMsIHlvdSdkIGhhdmUgdG8gcmVhZCA0MiBvdGhlciBjb21tZW50cyBmaXJzdC4uLiBidXQgeW91IGNhbid0IHJlYWQgYW55IG9mIHRob3NlIGNvbW1lbnRzIHVudGlsIHlvdSBmaXJzdCByZWFkIHRoaXMgY29tbWVudC4gV2hhdCE/IC8vIHNob3VsZG4ndCB0aGlzIG1hdGNoIGxpbmsncyBjaGVjaz9cblx0XHRcdFx0Ly8gaXMgdGhlcmUgY2FzZXMgd2hlcmUgaXQgaXMgYSAkJCB0aGF0IHdlIGRvIE5PVCB3YW50IHRvIGRvIHRoZSBmb2xsb3dpbmc/IFxuXHRcdFx0XHRpZigoc2F0ID0gY2F0Lm5leHQpICYmIChzYXQgPSBzYXRba2V5XSkpeyAvLyBUT0RPOiBwb3NzaWJsZSB0cmljaz8gTWF5YmUgaGF2ZSBgaW9ubWFwYCBjb2RlIHNldCBhIHNhdD8gLy8gVE9ETzogTWF5YmUgd2Ugc2hvdWxkIGRvIGBjYXQuYXNrYCBpbnN0ZWFkPyBJIGd1ZXNzIGRvZXMgbm90IG1hdHRlci5cblx0XHRcdFx0XHR0bXAgPSB7fTsgT2JqZWN0LmtleXMobXNnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyB0bXBba10gPSBtc2dba10gfSk7XG5cdFx0XHRcdFx0dG1wLiQgPSAobXNnLiQkfHxtc2cuJCkuZ2V0KHRtcC5nZXQgPSBrZXkpOyBkZWxldGUgdG1wLiQkOyBkZWxldGUgdG1wLiQkJDtcblx0XHRcdFx0XHRzYXQub24oJ2luJywgdG1wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsaW5rKG1zZywgY2F0KTtcblx0XHR9OyBHdW4ub24uaW4gPSBpbnB1dDtcblxuXHRcdGZ1bmN0aW9uIGxpbmsobXNnLCBjYXQpeyBjYXQgPSBjYXQgfHwgdGhpcy5hcyB8fCBtc2cuJC5fO1xuXHRcdFx0aWYobXNnLiQkICYmIHRoaXMgIT09IEd1bi5vbil7IHJldHVybiB9IC8vICQkIG1lYW5zIHdlIGNhbWUgZnJvbSBhIGxpbmssIHNvIHdlIGFyZSBhdCB0aGUgd3JvbmcgbGV2ZWwsIHRodXMgaWdub3JlIGl0IHVubGVzcyBvdmVycnVsZWQgbWFudWFsbHkgYnkgYmVpbmcgY2FsbGVkIGRpcmVjdGx5LlxuXHRcdFx0aWYoIW1zZy5wdXQgfHwgY2F0LnNvdWwpeyByZXR1cm4gfSAvLyBCdXQgeW91IGNhbm5vdCBvdmVycnVsZSBiZWluZyBsaW5rZWQgdG8gbm90aGluZywgb3IgdHJ5aW5nIHRvIGxpbmsgYSBzb3VsIGNoYWluIC0gdGhhdCBtdXN0IG5ldmVyIGhhcHBlbi5cblx0XHRcdHZhciBwdXQgPSBtc2cucHV0fHwnJywgbGluayA9IHB1dFsnPSddfHxwdXRbJzonXSwgdG1wO1xuXHRcdFx0dmFyIHJvb3QgPSBjYXQucm9vdCwgdGF0ID0gcm9vdC4kLmdldChwdXRbJyMnXSkuZ2V0KHB1dFsnLiddKS5fO1xuXHRcdFx0aWYoJ3N0cmluZycgIT0gdHlwZW9mIChsaW5rID0gdmFsaWQobGluaykpKXtcblx0XHRcdFx0aWYodGhpcyA9PT0gR3VuLm9uKXsgKHRhdC5lY2hvIHx8ICh0YXQuZWNobyA9IHt9KSlbY2F0LmlkXSA9IGNhdCB9IC8vIGFsbG93IHNvbWUgY2hhaW4gdG8gZXhwbGljaXRseSBmb3JjZSBsaW5raW5nIHRvIHNpbXBsZSBkYXRhLlxuXHRcdFx0XHRyZXR1cm47IC8vIGJ5IGRlZmF1bHQgZG8gbm90IGxpbmsgdG8gZGF0YSB0aGF0IGlzIG5vdCBhIGxpbmsuXG5cdFx0XHR9XG5cdFx0XHRpZigodGF0LmVjaG8gfHwgKHRhdC5lY2hvID0ge30pKVtjYXQuaWRdIC8vIHdlJ3ZlIGFscmVhZHkgbGlua2VkIG91cnNlbHZlcyBzbyB3ZSBkbyBub3QgbmVlZCB0byBkbyBpdCBhZ2Fpbi4gRXhjZXB0Li4uIChhbm5veWluZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzKVxuXHRcdFx0XHQmJiAhKHJvb3QucGFzc3x8JycpW2NhdC5pZF0peyByZXR1cm4gfSAvLyBpZiBhIG5ldyBldmVudCBsaXN0ZW5lciB3YXMgYWRkZWQsIHdlIG5lZWQgdG8gbWFrZSBhIHBhc3MgdGhyb3VnaCBmb3IgaXQuIFRoZSBwYXNzIHdpbGwgYmUgb24gdGhlIGNoYWluLCBub3QgYWx3YXlzIHRoZSBjaGFpbiBwYXNzZWQgZG93bi4gXG5cdFx0XHRpZih0bXAgPSByb290LnBhc3MpeyBpZih0bXBbbGluaytjYXQuaWRdKXsgcmV0dXJuIH0gdG1wW2xpbmsrY2F0LmlkXSA9IDEgfSAvLyBCdXQgdGhlIGFib3ZlIGVkZ2UgY2FzZSBtYXkgXCJwYXNzIHRocm91Z2hcIiBvbiBhIGNpcmN1bGFyIGdyYXBoIGNhdXNpbmcgaW5maW5pdGUgcGFzc2VzLCBzbyB3ZSBoYWNraWx5IGFkZCBhIHRlbXBvcmFyeSBjaGVjayBmb3IgdGhhdC5cblxuXHRcdFx0KHRhdC5lY2hvfHwodGF0LmVjaG89e30pKVtjYXQuaWRdID0gY2F0OyAvLyBzZXQgb3Vyc2VsZiB1cCBmb3IgdGhlIGVjaG8hIC8vIFRPRE86IEJVRz8gRWNobyB0byBzZWxmIG5vIGxvbmdlciBjYXVzZXMgcHJvYmxlbXM/IENvbmZpcm0uXG5cblx0XHRcdGlmKGNhdC5oYXMpeyBjYXQubGluayA9IGxpbmsgfVxuXHRcdFx0dmFyIHNhdCA9IHJvb3QuJC5nZXQodGF0LmxpbmsgPSBsaW5rKS5fOyAvLyBncmFiIHdoYXQgd2UncmUgbGlua2luZyB0by5cblx0XHRcdChzYXQuZWNobyB8fCAoc2F0LmVjaG8gPSB7fSkpW3RhdC5pZF0gPSB0YXQ7IC8vIGxpbmsgaXQuXG5cdFx0XHR2YXIgdG1wID0gY2F0LmFza3x8Jyc7IC8vIGFzayB0aGUgY2hhaW4gZm9yIHdoYXQgbmVlZHMgdG8gYmUgbG9hZGVkIG5leHQhXG5cdFx0XHRpZih0bXBbJyddIHx8IGNhdC5sZXgpeyAvLyB3ZSBtaWdodCBuZWVkIHRvIGxvYWQgdGhlIHdob2xlIHRoaW5nIC8vIFRPRE86IGNhdC5sZXggcHJvYmFibHkgaGFzIGVkZ2UgY2FzZSBidWdzIHRvIGl0LCBuZWVkIG1vcmUgdGVzdCBjb3ZlcmFnZS5cblx0XHRcdFx0c2F0Lm9uKCdvdXQnLCB7Z2V0OiB7JyMnOiBsaW5rfX0pO1xuXHRcdFx0fVxuXHRcdFx0c2V0VGltZW91dC5lYWNoKE9iamVjdC5rZXlzKHRtcCksIGZ1bmN0aW9uKGdldCwgc2F0KXsgLy8gaWYgc3ViIGNoYWlucyBhcmUgYXNraW5nIGZvciBkYXRhLiAvLyBUT0RPOiAua2V5cyggaXMgc2xvdyAvLyBCVUc/ID9Tb21lIHJlLWluIGxvZ2ljIG1heSBkZXBlbmQgb24gdGhpcyBiZWluZyBzeW5jP1xuXHRcdFx0XHRpZighZ2V0IHx8ICEoc2F0ID0gdG1wW2dldF0pKXsgcmV0dXJuIH1cblx0XHRcdFx0c2F0Lm9uKCdvdXQnLCB7Z2V0OiB7JyMnOiBsaW5rLCAnLic6IGdldH19KTsgLy8gZ28gZ2V0IGl0LlxuXHRcdFx0fSwwLDk5KTtcblx0XHR9OyBHdW4ub24ubGluayA9IGxpbms7XG5cblx0XHRmdW5jdGlvbiB1bmxpbmsobXNnLCBjYXQpeyAvLyB1Z2gsIHNvIG11Y2ggY29kZSBmb3Igc2VlbWluZ2x5IGVkZ2UgY2FzZSBiZWhhdmlvci5cblx0XHRcdHZhciBwdXQgPSBtc2cucHV0fHwnJywgY2hhbmdlID0gKHUgIT09IHB1dFsnPSddKT8gcHV0Wyc9J10gOiBwdXRbJzonXSwgcm9vdCA9IGNhdC5yb290LCBsaW5rLCB0bXA7XG5cdFx0XHRpZih1ID09PSBjaGFuZ2UpeyAvLyAxc3QgZWRnZSBjYXNlOiBJZiB3ZSBoYXZlIGEgYnJhbmQgbmV3IGRhdGFiYXNlLCBubyBkYXRhIHdpbGwgYmUgZm91bmQuXG5cdFx0XHRcdC8vIFRPRE86IEJVRyEgYmVjYXVzZSBlbXB0eWluZyBjYWNoZSBjb3VsZCBiZSBhc3luYyBmcm9tIGJlbG93LCBtYWtlIHN1cmUgd2UgYXJlIG5vdCBlbXB0eWluZyBhIG5ld2VyIGNhY2hlLiBTbyBtYXliZSBwYXNzIGFuIEFzeW5jIElEIHRvIGNoZWNrIGFnYWluc3Q/XG5cdFx0XHRcdC8vIFRPRE86IEJVRyEgV2hhdCBpZiB0aGlzIGlzIGEgbWFwPyAvLyBXYXJuaW5nISBDbGVhcmluZyB0aGluZ3Mgb3V0IG5lZWRzIHRvIGJlIHJvYnVzdCBhZ2FpbnN0IHN5bmMvYXN5bmMgb3BzLCBvciBlbHNlIHlvdSdsbCBzZWUgYG1hcCB2YWwgZ2V0IHB1dGAgdGVzdCBjYXRhc3Ryb3BoaWNhbGx5IGZhaWwgYmVjYXVzZSBtYXAgYXR0ZW1wdHMgdG8gbGluayB3aGVuIHBhcmVudCBncmFwaCBpcyBzdHJlYW1lZCBiZWZvcmUgY2hpbGQgdmFsdWUgZ2V0cyBzZXQuIE5lZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGxhY2sgYWNrcyBhbmQgZm9yY2UgY2xlYXJpbmcuXG5cdFx0XHRcdGlmKGNhdC5zb3VsICYmIHUgIT09IGNhdC5wdXQpeyByZXR1cm4gfSAvLyBkYXRhIG1heSBub3QgYmUgZm91bmQgb24gYSBzb3VsLCBidXQgaWYgYSBzb3VsIGFscmVhZHkgaGFzIGRhdGEsIHRoZW4gbm90aGluZyBjYW4gY2xlYXIgdGhlIHNvdWwgYXMgYSB3aG9sZS5cblx0XHRcdFx0Ly9pZighY2F0Lmhhcyl7IHJldHVybiB9XG5cdFx0XHRcdHRtcCA9IChtc2cuJCR8fG1zZy4kfHwnJykuX3x8Jyc7XG5cdFx0XHRcdGlmKG1zZ1snQCddICYmICh1ICE9PSB0bXAucHV0IHx8IHUgIT09IGNhdC5wdXQpKXsgcmV0dXJuIH0gLy8gYSBcIm5vdCBmb3VuZFwiIGZyb20gb3RoZXIgcGVlcnMgc2hvdWxkIG5vdCBjbGVhciBvdXQgZGF0YSBpZiB3ZSBoYXZlIGFscmVhZHkgZm91bmQgaXQuXG5cdFx0XHRcdC8vaWYoY2F0LmhhcyAmJiB1ID09PSBjYXQucHV0ICYmICEocm9vdC5wYXNzfHwnJylbY2F0LmlkXSl7IHJldHVybiB9IC8vIGlmIHdlIGFyZSBhbHJlYWR5IHVubGlua2VkLCBkbyBub3QgY2FsbCBhZ2FpbiwgdW5sZXNzIGVkZ2UgY2FzZS4gLy8gVE9ETzogQlVHISBUaGlzIGxpbmUgc2hvdWxkIGJlIGRlbGV0ZWQgZm9yIFwidW5saW5rIGRlZXBseSBuZXN0ZWRcIi5cblx0XHRcdFx0aWYobGluayA9IGNhdC5saW5rIHx8IG1zZy5saW5rZWQpe1xuXHRcdFx0XHRcdGRlbGV0ZSAocm9vdC4kLmdldChsaW5rKS5fLmVjaG98fCcnKVtjYXQuaWRdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGNhdC5oYXMpeyAvLyBUT0RPOiBFbXB0eSBvdXQgbGlua3MsIG1hcHMsIGVjaG9zLCBhY2tzL2Fza3MsIGV0Yy4/XG5cdFx0XHRcdFx0Y2F0LmxpbmsgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdC5wdXQgPSB1OyAvLyBlbXB0eSBvdXQgdGhlIGNhY2hlIGlmLCBmb3IgZXhhbXBsZSwgYWxpY2UncyBjYXIncyBjb2xvciBubyBsb25nZXIgZXhpc3RzIChyZWxhdGl2ZSB0byBhbGljZSkgaWYgYWxpY2Ugbm8gbG9uZ2VyIGhhcyBhIGNhci5cblx0XHRcdFx0Ly8gVE9ETzogQlVHISBGb3IgbWFwcywgcHJveHkgdGhpcyBzbyB0aGUgaW5kaXZpZHVhbCBzdWIgaXMgdHJpZ2dlcmVkLCBub3QgYWxsIHN1YnMuXG5cdFx0XHRcdHNldFRpbWVvdXQuZWFjaChPYmplY3Qua2V5cyhjYXQubmV4dHx8JycpLCBmdW5jdGlvbihnZXQsIHNhdCl7IC8vIGVtcHR5IG91dCBhbGwgc3ViIGNoYWlucy4gLy8gVE9ETzogLmtleXMoIGlzIHNsb3cgLy8gQlVHPyA/U29tZSByZS1pbiBsb2dpYyBtYXkgZGVwZW5kIG9uIHRoaXMgYmVpbmcgc3luYz8gLy8gVE9ETzogQlVHPyBUaGlzIHdpbGwgdHJpZ2dlciBkZWVwZXIgcHV0IGZpcnN0LCBkb2VzIHB1dCBsb2dpYyBkZXBlbmQgb24gbmVzdGVkIG9yZGVyPyAvLyBUT0RPOiBCVUchIEZvciBtYXAsIHRoaXMgbmVlZHMgdG8gYmUgdGhlIGlzb2xhdGVkIGNoaWxkLCBub3QgYWxsIG9mIHRoZW0uXG5cdFx0XHRcdFx0aWYoIShzYXQgPSBjYXQubmV4dFtnZXRdKSl7IHJldHVybiB9XG5cdFx0XHRcdFx0Ly9pZihjYXQuaGFzICYmIHUgPT09IHNhdC5wdXQgJiYgIShyb290LnBhc3N8fCcnKVtzYXQuaWRdKXsgcmV0dXJuIH0gLy8gaWYgd2UgYXJlIGFscmVhZHkgdW5saW5rZWQsIGRvIG5vdCBjYWxsIGFnYWluLCB1bmxlc3MgZWRnZSBjYXNlLiAvLyBUT0RPOiBCVUchIFRoaXMgbGluZSBzaG91bGQgYmUgZGVsZXRlZCBmb3IgXCJ1bmxpbmsgZGVlcGx5IG5lc3RlZFwiLlxuXHRcdFx0XHRcdGlmKGxpbmspeyBkZWxldGUgKHJvb3QuJC5nZXQobGluaykuZ2V0KGdldCkuXy5lY2hvfHwnJylbc2F0LmlkXSB9XG5cdFx0XHRcdFx0c2F0Lm9uKCdpbicsIHtnZXQ6IGdldCwgcHV0OiB1LCAkOiBzYXQuJH0pOyAvLyBUT0RPOiBCVUc/IEFkZCByZWN1cnNpdmUgc2VlbiBjaGVjaz9cblx0XHRcdFx0fSwwLDk5KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoY2F0LnNvdWwpeyByZXR1cm4gfSAvLyBhIHNvdWwgY2Fubm90IHVubGluayBpdHNlbGYuXG5cdFx0XHRpZihtc2cuJCQpeyByZXR1cm4gfSAvLyBhIGxpbmtlZCBjaGFpbiBkb2VzIG5vdCBkbyB0aGUgdW5saW5raW5nLCB0aGUgc3ViIGNoYWluIGRvZXMuIC8vIFRPRE86IEJVRz8gV2lsbCB0aGlzIGNhbmNlbCBtYXBzP1xuXHRcdFx0bGluayA9IHZhbGlkKGNoYW5nZSk7IC8vIG5lZWQgdG8gdW5saW5rIGFueXRpbWUgd2UgYXJlIG5vdCB0aGUgc2FtZSBsaW5rLCB0aG91Z2ggb25seSBkbyB0aGlzIG9uY2UgcGVyIHVubGluayAoYW5kIG5vdCBvbiBpbml0KS5cblx0XHRcdHRtcCA9IG1zZy4kLl98fCcnO1xuXHRcdFx0aWYobGluayA9PT0gdG1wLmxpbmsgfHwgKGNhdC5oYXMgJiYgIXRtcC5saW5rKSl7XG5cdFx0XHRcdGlmKChyb290LnBhc3N8fCcnKVtjYXQuaWRdICYmICdzdHJpbmcnICE9PSB0eXBlb2YgbGluayl7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRlbGV0ZSAodG1wLmVjaG98fCcnKVtjYXQuaWRdO1xuXHRcdFx0dW5saW5rKHtnZXQ6IGNhdC5nZXQsIHB1dDogdSwgJDogbXNnLiQsIGxpbmtlZDogbXNnLmxpbmtlZCA9IG1zZy5saW5rZWQgfHwgdG1wLmxpbmt9LCBjYXQpOyAvLyB1bmxpbmsgb3VyIHN1YiBjaGFpbnMuXG5cdFx0fTsgR3VuLm9uLnVubGluayA9IHVubGluaztcblxuXHRcdGZ1bmN0aW9uIGFjayhtc2csIGV2KXtcblx0XHRcdC8vaWYoIW1zZ1snJSddICYmICh0aGlzfHwnJykub2ZmKXsgdGhpcy5vZmYoKSB9IC8vIGRvIE5PVCBtZW1vcnkgbGVhaywgdHVybiBvZmYgbGlzdGVuZXJzISBOb3cgaGFuZGxlZCBieSAuYXNrIGl0c2VsZlxuXHRcdFx0Ly8gbWFuaGF0dGFuOlxuXHRcdFx0dmFyIGFzID0gdGhpcy5hcywgYXQgPSBhcy4kLl8sIHJvb3QgPSBhdC5yb290LCBnZXQgPSBhcy5nZXR8fCcnLCB0bXAgPSAobXNnLnB1dHx8JycpW2dldFsnIyddXXx8Jyc7XG5cdFx0XHRpZighbXNnLnB1dCB8fCAoJ3N0cmluZycgPT0gdHlwZW9mIGdldFsnLiddICYmIHUgPT09IHRtcFtnZXRbJy4nXV0pKXtcblx0XHRcdFx0aWYodSAhPT0gYXQucHV0KXsgcmV0dXJuIH1cblx0XHRcdFx0aWYoIWF0LnNvdWwgJiYgIWF0Lmhhcyl7IHJldHVybiB9IC8vIFRPRE86IEJVRz8gRm9yIG5vdywgb25seSBjb3JlLWNoYWlucyB3aWxsIGhhbmRsZSBub3QtZm91bmRzLCBiZWNhdXNlIGJ1Z3MgY3JlZXAgaW4gaWYgbm9uLWNvcmUgY2hhaW5zIGFyZSB1c2VkIGFzICQgYnV0IHdlIGNhbiByZXZpc2l0IHRoaXMgbGF0ZXIgZm9yIG1vcmUgcG93ZXJmdWwgZXh0ZW5zaW9ucy5cblx0XHRcdFx0YXQuYWNrID0gKGF0LmFjayB8fCAwKSArIDE7XG5cdFx0XHRcdGF0Lm9uKCdpbicsIHtcblx0XHRcdFx0XHRnZXQ6IGF0LmdldCxcblx0XHRcdFx0XHRwdXQ6IGF0LnB1dCA9IHUsXG5cdFx0XHRcdFx0JDogYXQuJCxcblx0XHRcdFx0XHQnQCc6IG1zZ1snQCddXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvKih0bXAgPSBhdC5RKSAmJiBzZXRUaW1lb3V0LmVhY2goT2JqZWN0LmtleXModG1wKSwgZnVuY3Rpb24oaWQpeyAvLyBUT0RPOiBUZW1wb3JhcnkgdGVzdGluZywgbm90IGludGVncmF0ZWQgb3IgYmVpbmcgdXNlZCwgcHJvYmFibHkgZGVsZXRlLlxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKG1zZykuZm9yRWFjaChmdW5jdGlvbihrKXsgdG1wW2tdID0gbXNnW2tdIH0sIHRtcCA9IHt9KTsgdG1wWydAJ10gPSBpZDsgLy8gY29weSBtZXNzYWdlXG5cdFx0XHRcdFx0cm9vdC5vbignaW4nLCB0bXApO1xuXHRcdFx0XHR9KTsgZGVsZXRlIGF0LlE7Ki9cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0KG1zZy5ffHx7fSkubWlzcyA9IDE7XG5cdFx0XHRHdW4ub24ucHV0KG1zZyk7XG5cdFx0XHRyZXR1cm47IC8vIGVvbVxuXHRcdH1cblxuXHRcdHZhciBlbXB0eSA9IHt9LCB1LCB0ZXh0X3JhbmQgPSBTdHJpbmcucmFuZG9tLCB2YWxpZCA9IEd1bi52YWxpZCwgb2JqX2hhcyA9IGZ1bmN0aW9uKG8sIGspeyByZXR1cm4gbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykgfSwgc3RhdGUgPSBHdW4uc3RhdGUsIHN0YXRlX2lzID0gc3RhdGUuaXMsIHN0YXRlX2lmeSA9IHN0YXRlLmlmeTtcblx0fSkoVVNFLCAnLi9jaGFpbicpO1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHR2YXIgR3VuID0gVVNFKCcuL3Jvb3QnKTtcblx0XHRHdW4uY2hhaW4uZ2V0ID0gZnVuY3Rpb24oa2V5LCBjYiwgYXMpe1xuXHRcdFx0dmFyIGd1biwgdG1wO1xuXHRcdFx0aWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpe1xuXHRcdFx0XHRpZihrZXkubGVuZ3RoID09IDApIHtcdFxuXHRcdFx0XHRcdChndW4gPSB0aGlzLmNoYWluKCkpLl8uZXJyID0ge2VycjogR3VuLmxvZygnMCBsZW5ndGgga2V5IScsIGtleSl9O1xuXHRcdFx0XHRcdGlmKGNiKXsgY2IuY2FsbChndW4sIGd1bi5fLmVycikgfVxuXHRcdFx0XHRcdHJldHVybiBndW47XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGJhY2sgPSB0aGlzLCBjYXQgPSBiYWNrLl87XG5cdFx0XHRcdHZhciBuZXh0ID0gY2F0Lm5leHQgfHwgZW1wdHk7XG5cdFx0XHRcdGlmKCEoZ3VuID0gbmV4dFtrZXldKSl7XG5cdFx0XHRcdFx0Z3VuID0ga2V5ICYmIGNhY2hlKGtleSwgYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z3VuID0gZ3VuICYmIGd1bi4kO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRpZignZnVuY3Rpb24nID09IHR5cGVvZiBrZXkpe1xuXHRcdFx0XHRpZih0cnVlID09PSBjYil7IHJldHVybiBzb3VsKHRoaXMsIGtleSwgY2IsIGFzKSwgdGhpcyB9XG5cdFx0XHRcdGd1biA9IHRoaXM7XG5cdFx0XHRcdHZhciBjYXQgPSBndW4uXywgb3B0ID0gY2IgfHwge30sIHJvb3QgPSBjYXQucm9vdCwgaWQ7XG5cdFx0XHRcdG9wdC5hdCA9IGNhdDtcblx0XHRcdFx0b3B0Lm9rID0ga2V5O1xuXHRcdFx0XHR2YXIgd2FpdCA9IHt9OyAvLyBjYW4gd2UgYXNzaWduIHRoaXMgdG8gdGhlIGF0IGluc3RlYWQsIGxpa2UgaW4gb25jZT9cblx0XHRcdFx0Ly92YXIgcGF0aCA9IFtdOyBjYXQuJC5iYWNrKGF0ID0+IHsgYXQuZ2V0ICYmIHBhdGgucHVzaChhdC5nZXQuc2xpY2UoMCw5KSl9KTsgcGF0aCA9IHBhdGgucmV2ZXJzZSgpLmpvaW4oJy4nKTtcblx0XHRcdFx0ZnVuY3Rpb24gYW55KG1zZywgZXZlLCBmKXtcblx0XHRcdFx0XHRpZihhbnkuc3R1bil7IHJldHVybiB9XG5cdFx0XHRcdFx0aWYoKHRtcCA9IHJvb3QucGFzcykgJiYgIXRtcFtpZF0peyByZXR1cm4gfVxuXHRcdFx0XHRcdHZhciBhdCA9IG1zZy4kLl8sIHNhdCA9IChtc2cuJCR8fCcnKS5fLCBkYXRhID0gKHNhdHx8YXQpLnB1dCwgb2RkID0gKCFhdC5oYXMgJiYgIWF0LnNvdWwpLCB0ZXN0ID0ge30sIGxpbmssIHRtcDtcblx0XHRcdFx0XHRpZihvZGQgfHwgdSA9PT0gZGF0YSl7IC8vIGhhbmRsZXMgbm9uLWNvcmVcblx0XHRcdFx0XHRcdGRhdGEgPSAodSA9PT0gKCh0bXAgPSBtc2cucHV0KXx8JycpWyc9J10pPyAodSA9PT0gKHRtcHx8JycpWyc6J10pPyB0bXAgOiB0bXBbJzonXSA6IHRtcFsnPSddO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihsaW5rID0gKCdzdHJpbmcnID09IHR5cGVvZiAodG1wID0gR3VuLnZhbGlkKGRhdGEpKSkpe1xuXHRcdFx0XHRcdFx0ZGF0YSA9ICh1ID09PSAodG1wID0gcm9vdC4kLmdldCh0bXApLl8ucHV0KSk/IG9wdC5ub3Q/IHUgOiBkYXRhIDogdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihvcHQubm90ICYmIHUgPT09IGRhdGEpeyByZXR1cm4gfVxuXHRcdFx0XHRcdGlmKHUgPT09IG9wdC5zdHVuKXtcblx0XHRcdFx0XHRcdGlmKCh0bXAgPSByb290LnN0dW4pICYmIHRtcC5vbil7XG5cdFx0XHRcdFx0XHRcdGNhdC4kLmJhY2soZnVuY3Rpb24oYSl7IC8vIG91ciBjaGFpbiBzdHVubmVkP1xuXHRcdFx0XHRcdFx0XHRcdHRtcC5vbignJythLmlkLCB0ZXN0ID0ge30pO1xuXHRcdFx0XHRcdFx0XHRcdGlmKCh0ZXN0LnJ1biB8fCAwKSA8IGFueS5pZCl7IHJldHVybiB0ZXN0IH0gLy8gaWYgdGhlcmUgaXMgYW4gZWFybGllciBzdHVuIG9uIGdhcGxlc3MgcGFyZW50cy9zZWxmLlxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0IXRlc3QucnVuICYmIHRtcC5vbignJythdC5pZCwgdGVzdCA9IHt9KTsgLy8gdGhpcyBub2RlIHN0dW5uZWQ/XG5cdFx0XHRcdFx0XHRcdCF0ZXN0LnJ1biAmJiBzYXQgJiYgdG1wLm9uKCcnK3NhdC5pZCwgdGVzdCA9IHt9KTsgLy8gbGlua2VkIG5vZGUgc3R1bm5lZD9cblx0XHRcdFx0XHRcdFx0aWYoYW55LmlkID4gdGVzdC5ydW4pe1xuXHRcdFx0XHRcdFx0XHRcdGlmKCF0ZXN0LnN0dW4gfHwgdGVzdC5zdHVuLmVuZCl7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ZXN0LnN0dW4gPSB0bXAub24oJ3N0dW4nKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRlc3Quc3R1biA9IHRlc3Quc3R1biAmJiB0ZXN0LnN0dW4ubGFzdDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYodGVzdC5zdHVuICYmICF0ZXN0LnN0dW4uZW5kKXtcblx0XHRcdFx0XHRcdFx0XHRcdC8vaWYob2RkICYmIHUgPT09IGRhdGEpeyByZXR1cm4gfVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly9pZih1ID09PSBtc2cucHV0KXsgcmV0dXJuIH0gLy8gXCJub3QgZm91bmRcIiBhY2tzIHdpbGwgYmUgZm91bmQgaWYgdGhlcmUgaXMgc3R1biwgc28gaWdub3JlIHRoZXNlLlxuXHRcdFx0XHRcdFx0XHRcdFx0KHRlc3Quc3R1bi5hZGQgfHwgKHRlc3Quc3R1bi5hZGQgPSB7fSkpW2lkXSA9IGZ1bmN0aW9uKCl7IGFueShtc2csZXZlLDEpIH0gLy8gYWRkIG91cnNlbGYgdG8gdGhlIHN0dW4gY2FsbGJhY2sgbGlzdCB0aGF0IGlzIGNhbGxlZCBhdCBlbmQgb2YgdGhlIHdyaXRlLlxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYoLypvZGQgJiYqLyB1ID09PSBkYXRhKXsgZiA9IDAgfSAvLyBpZiBkYXRhIG5vdCBmb3VuZCwga2VlcCB3YWl0aW5nL3RyeWluZy5cblx0XHRcdFx0XHRcdC8qaWYoZiAmJiB1ID09PSBkYXRhKXtcblx0XHRcdFx0XHRcdFx0Y2F0Lm9uKCdvdXQnLCBvcHQub3V0KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fSovXG5cdFx0XHRcdFx0XHRpZigodG1wID0gcm9vdC5oYXRjaCkgJiYgIXRtcC5lbmQgJiYgdSA9PT0gb3B0LmhhdGNoICYmICFmKXsgLy8gcXVpY2sgaGFjayEgLy8gV2hhdCdzIGdvaW5nIG9uIGhlcmU/IEJlY2F1c2UgZGF0YSBpcyBzdHJlYW1lZCwgd2UgZ2V0IHRoaW5ncyBvbmUgYnkgb25lLCBidXQgYSBsb3Qgb2YgZGV2ZWxvcGVycyB3b3VsZCByYXRoZXIgZ2V0IGEgY2FsbGJhY2sgYWZ0ZXIgZWFjaCBiYXRjaCBpbnN0ZWFkLCBzbyB0aGlzIGRvZXMgdGhhdCBieSBjcmVhdGluZyBhIHdhaXQgbGlzdCBwZXIgY2hhaW4gaWQgdGhhdCBpcyB0aGVuIGNhbGxlZCBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaCBieSB0aGUgaGF0Y2ggY29kZSBpbiB0aGUgcm9vdCBwdXQgbGlzdGVuZXIuXG5cdFx0XHRcdFx0XHRcdGlmKHdhaXRbYXQuJC5fLmlkXSl7IHJldHVybiB9IHdhaXRbYXQuJC5fLmlkXSA9IDE7XG5cdFx0XHRcdFx0XHRcdHRtcC5wdXNoKGZ1bmN0aW9uKCl7YW55KG1zZyxldmUsMSl9KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fTsgd2FpdCA9IHt9OyAvLyBlbmQgcXVpY2sgaGFjay5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gY2FsbDpcblx0XHRcdFx0XHRpZihyb290LnBhc3MpeyBpZihyb290LnBhc3NbaWQrYXQuaWRdKXsgcmV0dXJuIH0gcm9vdC5wYXNzW2lkK2F0LmlkXSA9IDEgfVxuXHRcdFx0XHRcdGlmKG9wdC5vbil7IG9wdC5vay5jYWxsKGF0LiQsIGRhdGEsIGF0LmdldCwgbXNnLCBldmUgfHwgYW55KTsgcmV0dXJuIH0gLy8gVE9ETzogQWxzbyBjb25zaWRlciBicmVha2luZyBgdGhpc2Agc2luY2UgYSBsb3Qgb2YgcGVvcGxlIGRvIGA9PmAgdGhlc2UgZGF5cyBhbmQgYC5jYWxsKGAgaGFzIHNsb3dlciBwZXJmb3JtYW5jZS5cblx0XHRcdFx0XHRpZihvcHQudjIwMjApeyBvcHQub2sobXNnLCBldmUgfHwgYW55KTsgcmV0dXJuIH1cblx0XHRcdFx0XHRPYmplY3Qua2V5cyhtc2cpLmZvckVhY2goZnVuY3Rpb24oayl7IHRtcFtrXSA9IG1zZ1trXSB9LCB0bXAgPSB7fSk7IG1zZyA9IHRtcDsgbXNnLnB1dCA9IGRhdGE7IC8vIDIwMTkgQ09NUEFUSUJJTElUWSEgVE9ETzogR0VUIFJJRCBPRiBUSElTIVxuXHRcdFx0XHRcdG9wdC5vay5jYWxsKG9wdC5hcywgbXNnLCBldmUgfHwgYW55KTsgLy8gaXMgdGhpcyB0aGUgcmlnaHRcblx0XHRcdFx0fTtcblx0XHRcdFx0YW55LmF0ID0gY2F0O1xuXHRcdFx0XHQvLyhjYXQuYW55fHwoY2F0LmFueT1mdW5jdGlvbihtc2cpeyBzZXRUaW1lb3V0LmVhY2goT2JqZWN0LmtleXMoY2F0LmFueXx8JycpLCBmdW5jdGlvbihhY3QpeyAoYWN0ID0gY2F0LmFueVthY3RdKSAmJiBhY3QobXNnKSB9LDAsOTkpIH0pKVtpZCA9IFN0cmluZy5yYW5kb20oNyldID0gYW55OyAvLyBtYXliZSBzd2l0Y2ggdG8gdGhpcyBpbiBmdXR1cmU/XG5cdFx0XHRcdChjYXQuYW55fHwoY2F0LmFueT17fSkpW2lkID0gU3RyaW5nLnJhbmRvbSg3KV0gPSBhbnk7XG5cdFx0XHRcdGFueS5vZmYgPSBmdW5jdGlvbigpeyBhbnkuc3R1biA9IDE7IGlmKCFjYXQuYW55KXsgcmV0dXJuIH0gZGVsZXRlIGNhdC5hbnlbaWRdIH1cblx0XHRcdFx0YW55LnJpZCA9IHJpZDsgLy8gbG9naWMgZnJvbSBvbGQgdmVyc2lvbiwgY2FuIHdlIGNsZWFuIGl0IHVwIG5vdz9cblx0XHRcdFx0YW55LmlkID0gb3B0LnJ1biB8fCArK3Jvb3Qub25jZTsgLy8gdXNlZCBpbiBjYWxsYmFjayB0byBjaGVjayBpZiB3ZSBhcmUgZWFybGllciB0aGFuIGEgd3JpdGUuIC8vIHdpbGwgdGhpcyBldmVyIGNhdXNlIGFuIGludGVnZXIgb3ZlcmZsb3c/XG5cdFx0XHRcdHRtcCA9IHJvb3QucGFzczsgKHJvb3QucGFzcyA9IHt9KVtpZF0gPSAxOyAvLyBFeHBsYW5hdGlvbjogdGVzdCB0cmFkZS1vZmZzIHdhbnQgdG8gcHJldmVudCByZWN1cnNpb24gc28gd2UgYWRkL3JlbW92ZSBwYXNzIGZsYWcgYXMgaXQgZ2V0cyBmdWxmaWxsZWQgdG8gbm90IHJlcGVhdCwgaG93ZXZlciBtYXAgbWFwIG5lZWRzIG1hbnkgcGFzcyBmbGFncyAtIGhvdyBkbyB3ZSByZWNvbmNpbGU/XG5cdFx0XHRcdG9wdC5vdXQgPSBvcHQub3V0IHx8IHtnZXQ6IHt9fTtcblx0XHRcdFx0Y2F0Lm9uKCdvdXQnLCBvcHQub3V0KTtcblx0XHRcdFx0cm9vdC5wYXNzID0gdG1wO1xuXHRcdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRpZignbnVtYmVyJyA9PSB0eXBlb2Yga2V5KXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCcnK2tleSwgY2IsIGFzKTtcblx0XHRcdH0gZWxzZVxuXHRcdFx0aWYoJ3N0cmluZycgPT0gdHlwZW9mICh0bXAgPSB2YWxpZChrZXkpKSl7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldCh0bXAsIGNiLCBhcyk7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmKHRtcCA9IHRoaXMuZ2V0Lm5leHQpe1xuXHRcdFx0XHRndW4gPSB0bXAodGhpcywga2V5KTtcblx0XHRcdH1cblx0XHRcdGlmKCFndW4pe1xuXHRcdFx0XHQoZ3VuID0gdGhpcy5jaGFpbigpKS5fLmVyciA9IHtlcnI6IEd1bi5sb2coJ0ludmFsaWQgZ2V0IHJlcXVlc3QhJywga2V5KX07IC8vIENMRUFOIFVQXG5cdFx0XHRcdGlmKGNiKXsgY2IuY2FsbChndW4sIGd1bi5fLmVycikgfVxuXHRcdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdFx0fVxuXHRcdFx0aWYoY2IgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgY2Ipe1xuXHRcdFx0XHRndW4uZ2V0KGNiLCBhcyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBjYWNoZShrZXksIGJhY2spe1xuXHRcdFx0dmFyIGNhdCA9IGJhY2suXywgbmV4dCA9IGNhdC5uZXh0LCBndW4gPSBiYWNrLmNoYWluKCksIGF0ID0gZ3VuLl87XG5cdFx0XHRpZighbmV4dCl7IG5leHQgPSBjYXQubmV4dCA9IHt9IH1cblx0XHRcdG5leHRbYXQuZ2V0ID0ga2V5XSA9IGF0O1xuXHRcdFx0aWYoYmFjayA9PT0gY2F0LnJvb3QuJCl7XG5cdFx0XHRcdGF0LnNvdWwgPSBrZXk7XG5cdFx0XHRcdC8vYXQucHV0ID0ge307XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmKGNhdC5zb3VsIHx8IGNhdC5oYXMpe1xuXHRcdFx0XHRhdC5oYXMgPSBrZXk7XG5cdFx0XHRcdC8vaWYob2JqX2hhcyhjYXQucHV0LCBrZXkpKXtcblx0XHRcdFx0XHQvL2F0LnB1dCA9IGNhdC5wdXRba2V5XTtcblx0XHRcdFx0Ly99XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXQ7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHNvdWwoZ3VuLCBjYiwgb3B0LCBhcyl7XG5cdFx0XHR2YXIgY2F0ID0gZ3VuLl8sIGFja3MgPSAwLCB0bXA7XG5cdFx0XHRpZih0bXAgPSBjYXQuc291bCB8fCBjYXQubGluayl7IHJldHVybiBjYih0bXAsIGFzLCBjYXQpIH1cblx0XHRcdGlmKGNhdC5qYW0peyByZXR1cm4gY2F0LmphbS5wdXNoKFtjYiwgYXNdKSB9XG5cdFx0XHRjYXQuamFtID0gW1tjYixhc11dO1xuXHRcdFx0Z3VuLmdldChmdW5jdGlvbiBnbyhtc2csIGV2ZSl7XG5cdFx0XHRcdGlmKHUgPT09IG1zZy5wdXQgJiYgIWNhdC5yb290Lm9wdC5zdXBlciAmJiAodG1wID0gT2JqZWN0LmtleXMoY2F0LnJvb3Qub3B0LnBlZXJzKS5sZW5ndGgpICYmICsrYWNrcyA8PSB0bXApeyAvLyBUT0RPOiBzdXBlciBzaG91bGQgbm90IGJlIGluIGNvcmUgY29kZSwgYnJpbmcgQVhFIHVwIGludG8gY29yZSBpbnN0ZWFkIHRvIGZpeD8gLy8gVE9ETzogLmtleXMoIGlzIHNsb3dcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZXZlLnJpZChtc2cpO1xuXHRcdFx0XHR2YXIgYXQgPSAoKGF0ID0gbXNnLiQpICYmIGF0Ll8pIHx8IHt9LCBpID0gMCwgYXM7XG5cdFx0XHRcdHRtcCA9IGNhdC5qYW07IGRlbGV0ZSBjYXQuamFtOyAvLyB0bXAgPSBjYXQuamFtLnNwbGljZSgwLCAxMDApO1xuXHRcdFx0XHQvL2lmKHRtcC5sZW5ndGgpeyBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCl7IGdvKG1zZywgZXZlKSB9KSB9XG5cdFx0XHRcdHdoaWxlKGFzID0gdG1wW2krK10peyAvL0d1bi5vYmoubWFwKHRtcCwgZnVuY3Rpb24oYXMsIGNiKXtcblx0XHRcdFx0XHR2YXIgY2IgPSBhc1swXSwgaWQ7IGFzID0gYXNbMV07XG5cdFx0XHRcdFx0Y2IgJiYgY2IoaWQgPSBhdC5saW5rIHx8IGF0LnNvdWwgfHwgR3VuLnZhbGlkKG1zZy5wdXQpIHx8ICgobXNnLnB1dHx8e30pLl98fHt9KVsnIyddLCBhcywgbXNnLCBldmUpO1xuXHRcdFx0XHR9IC8vKTtcblx0XHRcdH0sIHtvdXQ6IHtnZXQ6IHsnLic6dHJ1ZX19fSk7XG5cdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdH1cblx0XHRmdW5jdGlvbiByaWQoYXQpe1xuXHRcdFx0dmFyIGNhdCA9IHRoaXMuYXQgfHwgdGhpcy5vbjtcblx0XHRcdGlmKCFhdCB8fCBjYXQuc291bCB8fCBjYXQuaGFzKXsgcmV0dXJuIHRoaXMub2ZmKCkgfVxuXHRcdFx0aWYoIShhdCA9IChhdCA9IChhdCA9IGF0LiQgfHwgYXQpLl8gfHwgYXQpLmlkKSl7IHJldHVybiB9XG5cdFx0XHR2YXIgbWFwID0gY2F0Lm1hcCwgdG1wLCBzZWVuO1xuXHRcdFx0Ly9pZighbWFwIHx8ICEodG1wID0gbWFwW2F0XSkgfHwgISh0bXAgPSB0bXAuYXQpKXsgcmV0dXJuIH1cblx0XHRcdGlmKHRtcCA9IChzZWVuID0gdGhpcy5zZWVuIHx8ICh0aGlzLnNlZW4gPSB7fSkpW2F0XSl7IHJldHVybiB0cnVlIH1cblx0XHRcdHNlZW5bYXRdID0gdHJ1ZTtcblx0XHRcdHJldHVybjtcblx0XHRcdC8vdG1wLmVjaG9bY2F0LmlkXSA9IHt9OyAvLyBUT0RPOiBXYXJuaW5nOiBUaGlzIHVuc3Vic2NyaWJlcyBBTEwgb2YgdGhpcyBjaGFpbidzIGxpc3RlbmVycyBmcm9tIHRoaXMgbGluaywgbm90IGp1c3QgdGhlIG9uZSBjYWxsYmFjayBldmVudC5cblx0XHRcdC8vb2JqLmRlbChtYXAsIGF0KTsgLy8gVE9ETzogV2FybmluZzogVGhpcyB1bnN1YnNjcmliZXMgQUxMIG9mIHRoaXMgY2hhaW4ncyBsaXN0ZW5lcnMgZnJvbSB0aGlzIGxpbmssIG5vdCBqdXN0IHRoZSBvbmUgY2FsbGJhY2sgZXZlbnQuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBlbXB0eSA9IHt9LCB2YWxpZCA9IEd1bi52YWxpZCwgdTtcblx0fSkoVVNFLCAnLi9nZXQnKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0dmFyIEd1biA9IFVTRSgnLi9yb290Jyk7XG5cdFx0R3VuLmNoYWluLnB1dCA9IGZ1bmN0aW9uKGRhdGEsIGNiLCBhcyl7IC8vIEkgcmV3cm90ZSBpdCA6KVxuXHRcdFx0dmFyIGd1biA9IHRoaXMsIGF0ID0gZ3VuLl8sIHJvb3QgPSBhdC5yb290O1xuXHRcdFx0YXMgPSBhcyB8fCB7fTtcblx0XHRcdGFzLnJvb3QgPSBhdC5yb290O1xuXHRcdFx0YXMucnVuIHx8IChhcy5ydW4gPSByb290Lm9uY2UpO1xuXHRcdFx0c3R1bihhcywgYXQuaWQpOyAvLyBzZXQgYSBmbGFnIGZvciByZWFkcyB0byBjaGVjayBpZiB0aGlzIGNoYWluIGlzIHdyaXRpbmcuXG5cdFx0XHRhcy5hY2sgPSBhcy5hY2sgfHwgY2I7XG5cdFx0XHRhcy52aWEgPSBhcy52aWEgfHwgZ3VuO1xuXHRcdFx0YXMuZGF0YSA9IGFzLmRhdGEgfHwgZGF0YTtcblx0XHRcdGFzLnNvdWwgfHwgKGFzLnNvdWwgPSBhdC5zb3VsIHx8ICgnc3RyaW5nJyA9PSB0eXBlb2YgY2IgJiYgY2IpKTtcblx0XHRcdHZhciBzID0gYXMuc3RhdGUgPSBhcy5zdGF0ZSB8fCBHdW4uc3RhdGUoKTtcblx0XHRcdGlmKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpeyBkYXRhKGZ1bmN0aW9uKGQpeyBhcy5kYXRhID0gZDsgZ3VuLnB1dCh1LHUsYXMpIH0pOyByZXR1cm4gZ3VuIH1cblx0XHRcdGlmKCFhcy5zb3VsKXsgcmV0dXJuIGdldChhcyksIGd1biB9XG5cdFx0XHRhcy4kID0gcm9vdC4kLmdldChhcy5zb3VsKTsgLy8gVE9ETzogVGhpcyBtYXkgbm90IGFsbG93IHVzZXIgY2hhaW5pbmcgYW5kIHNpbWlsYXI/XG5cdFx0XHRhcy50b2RvID0gW3tpdDogYXMuZGF0YSwgcmVmOiBhcy4kfV07XG5cdFx0XHRhcy50dXJuID0gYXMudHVybiB8fCB0dXJuO1xuXHRcdFx0YXMucmFuID0gYXMucmFuIHx8IHJhbjtcblx0XHRcdC8vdmFyIHBhdGggPSBbXTsgYXMudmlhLmJhY2soYXQgPT4geyBhdC5nZXQgJiYgcGF0aC5wdXNoKGF0LmdldC5zbGljZSgwLDkpKSB9KTsgcGF0aCA9IHBhdGgucmV2ZXJzZSgpLmpvaW4oJy4nKTtcblx0XHRcdC8vIFRPRE86IFBlcmYhIFdlIG9ubHkgbmVlZCB0byBzdHVuIGNoYWlucyB0aGF0IGFyZSBiZWluZyBtb2RpZmllZCwgbm90IG5lY2Vzc2FyaWx5IHdyaXR0ZW4gdG8uXG5cdFx0XHQoZnVuY3Rpb24gd2Fsaygpe1xuXHRcdFx0XHR2YXIgdG8gPSBhcy50b2RvLCBhdCA9IHRvLnBvcCgpLCBkID0gYXQuaXQsIGNpZCA9IGF0LnJlZiAmJiBhdC5yZWYuXy5pZCwgdiwgaywgY2F0LCB0bXAsIGc7XG5cdFx0XHRcdHN0dW4oYXMsIGF0LnJlZik7XG5cdFx0XHRcdGlmKHRtcCA9IGF0LnRvZG8pe1xuXHRcdFx0XHRcdGsgPSB0bXAucG9wKCk7IGQgPSBkW2tdO1xuXHRcdFx0XHRcdGlmKHRtcC5sZW5ndGgpeyB0by5wdXNoKGF0KSB9XG5cdFx0XHRcdH1cblx0XHRcdFx0ayAmJiAodG8ucGF0aCB8fCAodG8ucGF0aCA9IFtdKSkucHVzaChrKTtcblx0XHRcdFx0aWYoISh2ID0gdmFsaWQoZCkpICYmICEoZyA9IEd1bi5pcyhkKSkpe1xuXHRcdFx0XHRcdGlmKCFPYmplY3QucGxhaW4oZCkpeyByYW4uZXJyKGFzLCBcIkludmFsaWQgZGF0YTogXCIrIGNoZWNrKGQpICtcIiBhdCBcIiArIChhcy52aWEuYmFjayhmdW5jdGlvbihhdCl7YXQuZ2V0ICYmIHRtcC5wdXNoKGF0LmdldCl9LCB0bXAgPSBbXSkgfHwgdG1wLmpvaW4oJy4nKSkrJy4nKyh0by5wYXRofHxbXSkuam9pbignLicpKTsgcmV0dXJuIH1cblx0XHRcdFx0XHR2YXIgc2VlbiA9IGFzLnNlZW4gfHwgKGFzLnNlZW4gPSBbXSksIGkgPSBzZWVuLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZShpLS0peyBpZihkID09PSAodG1wID0gc2VlbltpXSkuaXQpeyB2ID0gZCA9IHRtcC5saW5rOyBicmVhayB9IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZihrICYmIHYpeyBhdC5ub2RlID0gc3RhdGVfaWZ5KGF0Lm5vZGUsIGssIHMsIGQpIH0gLy8gaGFuZGxlIHNvdWwgbGF0ZXIuXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmKCFhcy5zZWVuKXsgcmFuLmVycihhcywgXCJEYXRhIGF0IHJvb3Qgb2YgZ3JhcGggbXVzdCBiZSBhIG5vZGUgKGFuIG9iamVjdCkuXCIpOyByZXR1cm4gfVxuXHRcdFx0XHRcdGFzLnNlZW4ucHVzaChjYXQgPSB7aXQ6IGQsIGxpbms6IHt9LCB0b2RvOiBnPyBbXSA6IE9iamVjdC5rZXlzKGQpLnNvcnQoKS5yZXZlcnNlKCksIHBhdGg6ICh0by5wYXRofHxbXSkuc2xpY2UoKSwgdXA6IGF0fSk7IC8vIEFueSBwZXJmIHJlYXNvbnMgdG8gQ1BVIHNjaGVkdWxlIHRoaXMgLmtleXMoID9cblx0XHRcdFx0XHRhdC5ub2RlID0gc3RhdGVfaWZ5KGF0Lm5vZGUsIGssIHMsIGNhdC5saW5rKTtcblx0XHRcdFx0XHQhZyAmJiBjYXQudG9kby5sZW5ndGggJiYgdG8ucHVzaChjYXQpO1xuXHRcdFx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLVxuXHRcdFx0XHRcdHZhciBpZCA9IGFzLnNlZW4ubGVuZ3RoO1xuXHRcdFx0XHRcdChhcy53YWl0IHx8IChhcy53YWl0ID0ge30pKVtpZF0gPSAnJztcblx0XHRcdFx0XHR0bXAgPSAoY2F0LnJlZiA9IChnPyBkIDogaz8gYXQucmVmLmdldChrKSA6IGF0LnJlZikpLl87XG5cdFx0XHRcdFx0KHRtcCA9IChkICYmIChkLl98fCcnKVsnIyddKSB8fCB0bXAuc291bCB8fCB0bXAubGluayk/IHJlc29sdmUoe3NvdWw6IHRtcH0pIDogY2F0LnJlZi5nZXQocmVzb2x2ZSwge3J1bjogYXMucnVuLCAvKmhhdGNoOiAwLCovIHYyMDIwOjEsIG91dDp7Z2V0OnsnLic6JyAnfX19KTsgLy8gVE9ETzogQlVHISBUaGlzIHNob3VsZCBiZSByZXNvbHZlIE9OTFkgc291bCB0byBwcmV2ZW50IGZ1bGwgZGF0YSBmcm9tIGJlaW5nIGxvYWRlZC4gLy8gRml4ZWQgbm93P1xuXHRcdFx0XHRcdC8vc2V0VGltZW91dChmdW5jdGlvbigpeyBpZihGKXsgcmV0dXJuIH0gY29uc29sZS5sb2coXCJJIEhBVkUgTk9UIEJFRU4gQ0FMTEVEIVwiLCBwYXRoLCBpZCwgY2F0LnJlZi5fLmlkLCBrKSB9LCA5MDAwKTsgdmFyIEY7IC8vIE1BS0UgU1VSRSBUTyBBREQgRiA9IDEgYmVsb3chXG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZShtc2csIGV2ZSl7XG5cdFx0XHRcdFx0XHR2YXIgZW5kID0gY2F0LmxpbmtbJyMnXTtcblx0XHRcdFx0XHRcdGlmKGV2ZSl7IGV2ZS5vZmYoKTsgZXZlLnJpZChtc2cpIH0gLy8gVE9ETzogVG9vIGVhcmx5ISBDaGVjayBhbGwgcGVlcnMgYWNrIG5vdCBmb3VuZC5cblx0XHRcdFx0XHRcdC8vIFRPRE86IEJVRyBtYXliZT8gTWFrZSBzdXJlIHRoaXMgZG9lcyBub3QgcGljayB1cCBhIGxpbmsgY2hhbmdlIHdpcGUsIHRoYXQgaXQgdXNlcyB0aGUgY2hhbmdpZ24gbGluayBpbnN0ZWFkLlxuXHRcdFx0XHRcdFx0dmFyIHNvdWwgPSBlbmQgfHwgbXNnLnNvdWwgfHwgKHRtcCA9IChtc2cuJCR8fG1zZy4kKS5ffHwnJykuc291bCB8fCB0bXAubGluayB8fCAoKHRtcCA9IHRtcC5wdXR8fCcnKS5ffHwnJylbJyMnXSB8fCB0bXBbJyMnXSB8fCAoKCh0bXAgPSBtc2cucHV0fHwnJykgJiYgbXNnLiQkKT8gdG1wWycjJ10gOiAodG1wWyc9J118fHRtcFsnOiddfHwnJylbJyMnXSk7XG5cdFx0XHRcdFx0XHQhZW5kICYmIHN0dW4oYXMsIG1zZy4kKTtcblx0XHRcdFx0XHRcdGlmKCFzb3VsICYmICFhdC5saW5rWycjJ10peyAvLyBjaGVjayBzb3VsIGxpbmsgYWJvdmUgdXNcblx0XHRcdFx0XHRcdFx0KGF0LndhaXQgfHwgKGF0LndhaXQgPSBbXSkpLnB1c2goZnVuY3Rpb24oKXsgcmVzb2x2ZShtc2csIGV2ZSkgfSkgLy8gd2FpdFxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZighc291bCl7XG5cdFx0XHRcdFx0XHRcdHNvdWwgPSBbXTtcblx0XHRcdFx0XHRcdFx0KG1zZy4kJHx8bXNnLiQpLmJhY2soZnVuY3Rpb24oYXQpe1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRtcCA9IGF0LnNvdWwgfHwgYXQubGluayl7IHJldHVybiBzb3VsLnB1c2godG1wKSB9XG5cdFx0XHRcdFx0XHRcdFx0c291bC5wdXNoKGF0LmdldCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRzb3VsID0gc291bC5yZXZlcnNlKCkuam9pbignLycpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2F0LmxpbmtbJyMnXSA9IHNvdWw7XG5cdFx0XHRcdFx0XHQhZyAmJiAoKChhcy5ncmFwaCB8fCAoYXMuZ3JhcGggPSB7fSkpW3NvdWxdID0gKGNhdC5ub2RlIHx8IChjYXQubm9kZSA9IHtfOnt9fSkpKS5fWycjJ10gPSBzb3VsKTtcblx0XHRcdFx0XHRcdGRlbGV0ZSBhcy53YWl0W2lkXTtcblx0XHRcdFx0XHRcdGNhdC53YWl0ICYmIHNldFRpbWVvdXQuZWFjaChjYXQud2FpdCwgZnVuY3Rpb24oY2IpeyBjYiAmJiBjYigpIH0pO1xuXHRcdFx0XHRcdFx0YXMucmFuKGFzKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCF0by5sZW5ndGgpeyByZXR1cm4gYXMucmFuKGFzKSB9XG5cdFx0XHRcdGFzLnR1cm4od2Fsayk7XG5cdFx0XHR9KCkpO1xuXHRcdFx0cmV0dXJuIGd1bjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdHVuKGFzLCBpZCl7XG5cdFx0XHRpZighaWQpeyByZXR1cm4gfSBpZCA9IChpZC5ffHwnJykuaWR8fGlkO1xuXHRcdFx0dmFyIHJ1biA9IGFzLnJvb3Quc3R1biB8fCAoYXMucm9vdC5zdHVuID0ge29uOiBHdW4ub259KSwgdGVzdCA9IHt9LCB0bXA7XG5cdFx0XHRhcy5zdHVuIHx8IChhcy5zdHVuID0gcnVuLm9uKCdzdHVuJywgZnVuY3Rpb24oKXsgfSkpO1xuXHRcdFx0aWYodG1wID0gcnVuLm9uKCcnK2lkKSl7IHRtcC50aGUubGFzdC5uZXh0KHRlc3QpIH1cblx0XHRcdGlmKHRlc3QucnVuID49IGFzLnJ1bil7IHJldHVybiB9XG5cdFx0XHRydW4ub24oJycraWQsIGZ1bmN0aW9uKHRlc3Qpe1xuXHRcdFx0XHRpZihhcy5zdHVuLmVuZCl7XG5cdFx0XHRcdFx0dGhpcy5vZmYoKTtcblx0XHRcdFx0XHR0aGlzLnRvLm5leHQodGVzdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlc3QucnVuID0gdGVzdC5ydW4gfHwgYXMucnVuO1xuXHRcdFx0XHR0ZXN0LnN0dW4gPSB0ZXN0LnN0dW4gfHwgYXMuc3R1bjsgcmV0dXJuO1xuXHRcdFx0XHRpZih0aGlzLnRvLnRvKXtcblx0XHRcdFx0XHR0aGlzLnRoZS5sYXN0Lm5leHQodGVzdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlc3Quc3R1biA9IGFzLnN0dW47XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByYW4oYXMpe1xuXHRcdFx0aWYoYXMuZXJyKXsgcmFuLmVuZChhcy5zdHVuLCBhcy5yb290KTsgcmV0dXJuIH0gLy8gbW92ZSBsb2cgaGFuZGxlIGhlcmUuXG5cdFx0XHRpZihhcy50b2RvLmxlbmd0aCB8fCBhcy5lbmQgfHwgIU9iamVjdC5lbXB0eShhcy53YWl0KSl7IHJldHVybiB9IGFzLmVuZCA9IDE7XG5cdFx0XHQvLyhhcy5yZXRyeSA9IGZ1bmN0aW9uKCl7IGFzLmFja3MgPSAwO1xuXHRcdFx0dmFyIGNhdCA9IChhcy4kLmJhY2soLTEpLl8pLCByb290ID0gY2F0LnJvb3QsIGFzayA9IGNhdC5hc2soZnVuY3Rpb24oYWNrKXtcblx0XHRcdFx0cm9vdC5vbignYWNrJywgYWNrKTtcblx0XHRcdFx0aWYoYWNrLmVyciAmJiAhYWNrLmxhY2speyBHdW4ubG9nKGFjaykgfVxuXHRcdFx0XHRpZigrK2Fja3MgPiAoYXMuYWNrcyB8fCAwKSl7IHRoaXMub2ZmKCkgfSAvLyBBZGp1c3RhYmxlIEFDS3MhIE9ubHkgMSBieSBkZWZhdWx0LlxuXHRcdFx0XHRpZighYXMuYWNrKXsgcmV0dXJuIH1cblx0XHRcdFx0YXMuYWNrKGFjaywgdGhpcyk7XG5cdFx0XHR9LCBhcy5vcHQpLCBhY2tzID0gMCwgc3R1biA9IGFzLnN0dW4sIHRtcDtcblx0XHRcdCh0bXAgPSBmdW5jdGlvbigpeyAvLyB0aGlzIGlzIG5vdCBvZmZpY2lhbCB5ZXQsIGJ1dCBxdWljayBzb2x1dGlvbiB0byBoYWNrIGluIGZvciBub3cuXG5cdFx0XHRcdGlmKCFzdHVuKXsgcmV0dXJuIH1cblx0XHRcdFx0cmFuLmVuZChzdHVuLCByb290KTtcblx0XHRcdFx0c2V0VGltZW91dC5lYWNoKE9iamVjdC5rZXlzKHN0dW4gPSBzdHVuLmFkZHx8JycpLCBmdW5jdGlvbihjYil7IGlmKGNiID0gc3R1bltjYl0pe2NiKCl9IH0pOyAvLyByZXN1bWUgdGhlIHN0dW5uZWQgcmVhZHMgLy8gQW55IHBlcmYgcmVhc29ucyB0byBDUFUgc2NoZWR1bGUgdGhpcyAua2V5cyggP1xuXHRcdFx0fSkuaGF0Y2ggPSB0bXA7IC8vIHRoaXMgaXMgbm90IG9mZmljaWFsIHlldCBeXG5cdFx0XHQvL2NvbnNvbGUubG9nKDEsIFwiUFVUXCIsIGFzLnJ1biwgYXMuZ3JhcGgpO1xuXHRcdFx0aWYoYXMuYWNrICYmICFhcy5vayl7IGFzLm9rID0gYXMuYWNrcyB8fCA5IH0gLy8gVE9ETzogSW4gZnV0dXJlISBSZW1vdmUgdGhpcyEgVGhpcyBpcyBqdXN0IG9sZCBBUEkgc3VwcG9ydC5cblx0XHRcdChhcy52aWEuXykub24oJ291dCcsIHtwdXQ6IGFzLm91dCA9IGFzLmdyYXBoLCBvazogYXMub2sgJiYgeydAJzogYXMub2srMX0sIG9wdDogYXMub3B0LCAnIyc6IGFzaywgXzogdG1wfSk7XG5cdFx0XHQvL30pKCk7XG5cdFx0fTsgcmFuLmVuZCA9IGZ1bmN0aW9uKHN0dW4scm9vdCl7XG5cdFx0XHRzdHVuLmVuZCA9IG5vb3A7IC8vIGxpa2Ugd2l0aCB0aGUgZWFybGllciBpZCwgY2hlYXBlciB0byBtYWtlIHRoaXMgZmxhZyBhIGZ1bmN0aW9uIHNvIGJlbG93IGNhbGxiYWNrcyBkbyBub3QgaGF2ZSB0byBkbyBhbiBleHRyYSB0eXBlIGNoZWNrLlxuXHRcdFx0aWYoc3R1bi50aGUudG8gPT09IHN0dW4gJiYgc3R1biA9PT0gc3R1bi50aGUubGFzdCl7IGRlbGV0ZSByb290LnN0dW4gfVxuXHRcdFx0c3R1bi5vZmYoKTtcblx0XHR9OyByYW4uZXJyID0gZnVuY3Rpb24oYXMsIGVycil7XG5cdFx0XHQoYXMuYWNrfHxub29wKS5jYWxsKGFzLCBhcy5vdXQgPSB7IGVycjogYXMuZXJyID0gR3VuLmxvZyhlcnIpIH0pO1xuXHRcdFx0YXMucmFuKGFzKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXQoYXMpe1xuXHRcdFx0dmFyIGF0ID0gYXMudmlhLl8sIHRtcDtcblx0XHRcdGFzLnZpYSA9IGFzLnZpYS5iYWNrKGZ1bmN0aW9uKGF0KXtcblx0XHRcdFx0aWYoYXQuc291bCB8fCAhYXQuZ2V0KXsgcmV0dXJuIGF0LiQgfVxuXHRcdFx0XHR0bXAgPSBhcy5kYXRhOyAoYXMuZGF0YSA9IHt9KVthdC5nZXRdID0gdG1wO1xuXHRcdFx0fSk7XG5cdFx0XHRpZighYXMudmlhIHx8ICFhcy52aWEuXy5zb3VsKXtcblx0XHRcdFx0YXMudmlhID0gYXQucm9vdC4kLmdldCgoKGFzLmRhdGF8fCcnKS5ffHwnJylbJyMnXSB8fCBhdC4kLmJhY2soJ29wdC51dWlkJykoKSlcblx0XHRcdH1cblx0XHRcdGFzLnZpYS5wdXQoYXMuZGF0YSwgYXMuYWNrLCBhcyk7XG5cdFx0XHRcblxuXHRcdFx0cmV0dXJuO1xuXHRcdFx0aWYoYXQuZ2V0ICYmIGF0LmJhY2suc291bCl7XG5cdFx0XHRcdHRtcCA9IGFzLmRhdGE7XG5cdFx0XHRcdGFzLnZpYSA9IGF0LmJhY2suJDtcblx0XHRcdFx0KGFzLmRhdGEgPSB7fSlbYXQuZ2V0XSA9IHRtcDsgXG5cdFx0XHRcdGFzLnZpYS5wdXQoYXMuZGF0YSwgYXMuYWNrLCBhcyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gY2hlY2soZCwgdG1wKXsgcmV0dXJuICgoZCAmJiAodG1wID0gZC5jb25zdHJ1Y3RvcikgJiYgdG1wLm5hbWUpIHx8IHR5cGVvZiBkKSB9XG5cblx0XHR2YXIgdSwgZW1wdHkgPSB7fSwgbm9vcCA9IGZ1bmN0aW9uKCl7fSwgdHVybiA9IHNldFRpbWVvdXQudHVybiwgdmFsaWQgPSBHdW4udmFsaWQsIHN0YXRlX2lmeSA9IEd1bi5zdGF0ZS5pZnk7XG5cdFx0dmFyIGlpZmUgPSBmdW5jdGlvbihmbixhcyl7Zm4uY2FsbChhc3x8ZW1wdHkpfVxuXHR9KShVU0UsICcuL3B1dCcpO1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHR2YXIgR3VuID0gVVNFKCcuL3Jvb3QnKTtcblx0XHRVU0UoJy4vY2hhaW4nKTtcblx0XHRVU0UoJy4vYmFjaycpO1xuXHRcdFVTRSgnLi9wdXQnKTtcblx0XHRVU0UoJy4vZ2V0Jyk7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBHdW47XG5cdH0pKFVTRSwgJy4vaW5kZXgnKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0dmFyIEd1biA9IFVTRSgnLi9pbmRleCcpO1xuXHRcdEd1bi5jaGFpbi5vbiA9IGZ1bmN0aW9uKHRhZywgYXJnLCBlYXMsIGFzKXsgLy8gZG9uJ3QgcmV3cml0ZSFcblx0XHRcdHZhciBndW4gPSB0aGlzLCBjYXQgPSBndW4uXywgcm9vdCA9IGNhdC5yb290LCBhY3QsIG9mZiwgaWQsIHRtcDtcblx0XHRcdGlmKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKXtcblx0XHRcdFx0aWYoIWFyZyl7IHJldHVybiBjYXQub24odGFnKSB9XG5cdFx0XHRcdGFjdCA9IGNhdC5vbih0YWcsIGFyZywgZWFzIHx8IGNhdCwgYXMpO1xuXHRcdFx0XHRpZihlYXMgJiYgZWFzLiQpe1xuXHRcdFx0XHRcdChlYXMuc3VicyB8fCAoZWFzLnN1YnMgPSBbXSkpLnB1c2goYWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9wdCA9IGFyZztcblx0XHRcdChvcHQgPSAodHJ1ZSA9PT0gb3B0KT8ge2NoYW5nZTogdHJ1ZX0gOiBvcHQgfHwge30pLm5vdCA9IDE7IG9wdC5vbiA9IDE7XG5cdFx0XHQvL29wdC5hdCA9IGNhdDtcblx0XHRcdC8vb3B0Lm9rID0gdGFnO1xuXHRcdFx0Ly9vcHQubGFzdCA9IHt9O1xuXHRcdFx0dmFyIHdhaXQgPSB7fTsgLy8gY2FuIHdlIGFzc2lnbiB0aGlzIHRvIHRoZSBhdCBpbnN0ZWFkLCBsaWtlIGluIG9uY2U/XG5cdFx0XHRndW4uZ2V0KHRhZywgb3B0KTtcblx0XHRcdC8qZ3VuLmdldChmdW5jdGlvbiBvbihkYXRhLGtleSxtc2csZXZlKXsgdmFyICQgPSB0aGlzO1xuXHRcdFx0XHRpZih0bXAgPSByb290LmhhdGNoKXsgLy8gcXVpY2sgaGFjayFcblx0XHRcdFx0XHRpZih3YWl0WyQuXy5pZF0peyByZXR1cm4gfSB3YWl0WyQuXy5pZF0gPSAxO1xuXHRcdFx0XHRcdHRtcC5wdXNoKGZ1bmN0aW9uKCl7b24uY2FsbCgkLCBkYXRhLGtleSxtc2csZXZlKX0pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fTsgd2FpdCA9IHt9OyAvLyBlbmQgcXVpY2sgaGFjay5cblx0XHRcdFx0dGFnLmNhbGwoJCwgZGF0YSxrZXksbXNnLGV2ZSk7XG5cdFx0XHR9LCBvcHQpOyAvLyBUT0RPOiBQRVJGISBFdmVudCBsaXN0ZW5lciBsZWFrISEhPyovXG5cdFx0XHQvKlxuXHRcdFx0ZnVuY3Rpb24gb25lKG1zZywgZXZlKXtcblx0XHRcdFx0aWYob25lLnN0dW4peyByZXR1cm4gfVxuXHRcdFx0XHR2YXIgYXQgPSBtc2cuJC5fLCBkYXRhID0gYXQucHV0LCB0bXA7XG5cdFx0XHRcdGlmKHRtcCA9IGF0LmxpbmspeyBkYXRhID0gcm9vdC4kLmdldCh0bXApLl8ucHV0IH1cblx0XHRcdFx0aWYob3B0Lm5vdD09PXUgJiYgdSA9PT0gZGF0YSl7IHJldHVybiB9XG5cdFx0XHRcdGlmKG9wdC5zdHVuPT09dSAmJiAodG1wID0gcm9vdC5zdHVuKSAmJiAodG1wID0gdG1wW2F0LmlkXSB8fCB0bXBbYXQuYmFjay5pZF0pICYmICF0bXAuZW5kKXsgLy8gUmVtZW1iZXIhIElmIHlvdSBwb3J0IHRoaXMgaW50byBgLmdldChjYmAgbWFrZSBzdXJlIHlvdSBhbGxvdyBzdHVuOjAgc2tpcCBvcHRpb24gZm9yIGAucHV0KGAuXG5cdFx0XHRcdFx0dG1wW2lkXSA9IGZ1bmN0aW9uKCl7b25lKG1zZyxldmUpfTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly90bXAgPSBvbmUud2FpdCB8fCAob25lLndhaXQgPSB7fSk7IGNvbnNvbGUubG9nKHRtcFthdC5pZF0gPT09ICcnKTsgaWYodG1wW2F0LmlkXSAhPT0gJycpeyB0bXBbYXQuaWRdID0gdG1wW2F0LmlkXSB8fCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dG1wW2F0LmlkXT0nJztvbmUobXNnLGV2ZSl9LDEpOyByZXR1cm4gfSBkZWxldGUgdG1wW2F0LmlkXTtcblx0XHRcdFx0Ly8gY2FsbDpcblx0XHRcdFx0aWYob3B0LmFzKXtcblx0XHRcdFx0XHRvcHQub2suY2FsbChvcHQuYXMsIG1zZywgZXZlIHx8IG9uZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3B0Lm9rLmNhbGwoYXQuJCwgZGF0YSwgbXNnLmdldCB8fCBhdC5nZXQsIG1zZywgZXZlIHx8IG9uZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRvbmUuYXQgPSBjYXQ7XG5cdFx0XHQoY2F0LmFjdHx8KGNhdC5hY3Q9e30pKVtpZCA9IFN0cmluZy5yYW5kb20oNyldID0gb25lO1xuXHRcdFx0b25lLm9mZiA9IGZ1bmN0aW9uKCl7IG9uZS5zdHVuID0gMTsgaWYoIWNhdC5hY3QpeyByZXR1cm4gfSBkZWxldGUgY2F0LmFjdFtpZF0gfVxuXHRcdFx0Y2F0Lm9uKCdvdXQnLCB7Z2V0OiB7fX0pOyovXG5cdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdH1cblx0XHQvLyBSdWxlczpcblx0XHQvLyAxLiBJZiBjYWNoZWQsIHNob3VsZCBiZSBmYXN0LCBidXQgbm90IHJlYWQgd2hpbGUgd3JpdGUuXG5cdFx0Ly8gMi4gU2hvdWxkIG5vdCByZXRyaWdnZXIgb3RoZXIgbGlzdGVuZXJzLCBzaG91bGQgZ2V0IHRyaWdnZXJlZCBldmVuIGlmIG5vdGhpbmcgZm91bmQuXG5cdFx0Ly8gMy4gSWYgdGhlIHNhbWUgY2FsbGJhY2sgcGFzc2VkIHRvIG1hbnkgZGlmZmVyZW50IG9uY2UgY2hhaW5zLCBlYWNoIHNob3VsZCByZXNvbHZlIC0gYW4gdW5zdWJzY3JpYmUgZnJvbSB0aGUgc2FtZSBjYWxsYmFjayBzaG91bGQgbm90IGVmZmVjdCB0aGUgc3RhdGUgb2YgdGhlIG90aGVyIHJlc29sdmluZyBjaGFpbnMsIGlmIHlvdSBkbyB3YW50IHRvIGNhbmNlbCB0aGVtIGFsbCBlYXJseSB5b3Ugc2hvdWxkIG11dGF0ZSB0aGUgY2FsbGJhY2sgaXRzZWxmIHdpdGggYSBmbGFnICYgY2hlY2sgZm9yIGl0IGF0IHRvcCBvZiBjYWxsYmFja1xuXHRcdEd1bi5jaGFpbi5vbmNlID0gZnVuY3Rpb24oY2IsIG9wdCl7IG9wdCA9IG9wdCB8fCB7fTsgLy8gYXZvaWQgcmV3cml0aW5nXG5cdFx0XHRpZighY2IpeyByZXR1cm4gbm9uZSh0aGlzLG9wdCkgfVxuXHRcdFx0dmFyIGd1biA9IHRoaXMsIGNhdCA9IGd1bi5fLCByb290ID0gY2F0LnJvb3QsIGRhdGEgPSBjYXQucHV0LCBpZCA9IFN0cmluZy5yYW5kb20oNyksIG9uZSwgdG1wO1xuXHRcdFx0Z3VuLmdldChmdW5jdGlvbihkYXRhLGtleSxtc2csZXZlKXtcblx0XHRcdFx0dmFyICQgPSB0aGlzLCBhdCA9ICQuXywgb25lID0gKGF0Lm9uZXx8KGF0Lm9uZT17fSkpO1xuXHRcdFx0XHRpZihldmUuc3R1bil7IHJldHVybiB9IGlmKCcnID09PSBvbmVbaWRdKXsgcmV0dXJuIH1cblx0XHRcdFx0aWYodHJ1ZSA9PT0gKHRtcCA9IEd1bi52YWxpZChkYXRhKSkpeyBvbmNlKCk7IHJldHVybiB9XG5cdFx0XHRcdGlmKCdzdHJpbmcnID09IHR5cGVvZiB0bXApeyByZXR1cm4gfSAvLyBUT0RPOiBCVUc/IFdpbGwgdGhpcyBhbHdheXMgbG9hZD9cblx0XHRcdFx0Y2xlYXJUaW1lb3V0KChjYXQub25lfHwnJylbaWRdKTsgLy8gY2xlYXIgXCJub3QgZm91bmRcIiBzaW5jZSB0aGV5IG9ubHkgZ2V0IHNldCBvbiBjYXQuXG5cdFx0XHRcdGNsZWFyVGltZW91dChvbmVbaWRdKTsgb25lW2lkXSA9IHNldFRpbWVvdXQob25jZSwgb3B0LndhaXR8fDk5KTsgLy8gVE9ETzogQnVnPyBUaGlzIGRvZXNuJ3QgaGFuZGxlIHBsdXJhbCBjaGFpbnMuXG5cdFx0XHRcdGZ1bmN0aW9uIG9uY2UoZil7XG5cdFx0XHRcdFx0aWYoIWF0LmhhcyAmJiAhYXQuc291bCl7IGF0ID0ge3B1dDogZGF0YSwgZ2V0OiBrZXl9IH0gLy8gaGFuZGxlcyBub24tY29yZSBtZXNzYWdlcy5cblx0XHRcdFx0XHRpZih1ID09PSAodG1wID0gYXQucHV0KSl7IHRtcCA9ICgobXNnLiQkfHwnJykuX3x8JycpLnB1dCB9XG5cdFx0XHRcdFx0aWYoJ3N0cmluZycgPT0gdHlwZW9mIEd1bi52YWxpZCh0bXApKXtcblx0XHRcdFx0XHRcdHRtcCA9IHJvb3QuJC5nZXQodG1wKS5fLnB1dDtcblx0XHRcdFx0XHRcdGlmKHRtcCA9PT0gdSAmJiAhZil7XG5cdFx0XHRcdFx0XHRcdG9uZVtpZF0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IG9uY2UoMSkgfSwgb3B0LndhaXR8fDk5KTsgLy8gVE9ETzogUXVpY2sgZml4LiBNYXliZSB1c2UgYWNrIGNvdW50IGZvciBtb3JlIHByZWRpY3RhYmxlIGNvbnRyb2w/XG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiQU5EIFZBTklTSEVEXCIsIGRhdGEpO1xuXHRcdFx0XHRcdGlmKGV2ZS5zdHVuKXsgcmV0dXJuIH0gaWYoJycgPT09IG9uZVtpZF0peyByZXR1cm4gfSBvbmVbaWRdID0gJyc7XG5cdFx0XHRcdFx0aWYoY2F0LnNvdWwgfHwgY2F0Lmhhcyl7IGV2ZS5vZmYoKSB9IC8vIFRPRE86IFBsdXJhbCBjaGFpbnM/IC8vIGVsc2UgeyA/Lm9mZigpIH0gLy8gYmV0dGVyIHRoYW4gb25lIGNoZWNrP1xuXHRcdFx0XHRcdGNiLmNhbGwoJCwgdG1wLCBhdC5nZXQpO1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChvbmVbaWRdKTsgLy8gY2xlYXIgXCJub3QgZm91bmRcIiBzaW5jZSB0aGV5IG9ubHkgZ2V0IHNldCBvbiBjYXQuIC8vIFRPRE86IFRoaXMgd2FzIGhhY2tpbHkgYWRkZWQsIGlzIGl0IG5lY2Vzc2FyeSBvciBpbXBvcnRhbnQ/IFByb2JhYmx5IG5vdCwgaW4gZnV0dXJlIHRyeSByZW1vdmluZyB0aGlzLiBXYXMgYWRkZWQganVzdCBhcyBhIHNhZmV0eSBmb3IgdGhlIGAmJiAhZmAgY2hlY2suXG5cdFx0XHRcdH07XG5cdFx0XHR9LCB7b246IDF9KTtcblx0XHRcdHJldHVybiBndW47XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG5vbmUoZ3VuLG9wdCxjaGFpbil7XG5cdFx0XHRHdW4ubG9nLm9uY2UoXCJ2YWxvbmNlXCIsIFwiQ2hhaW5hYmxlIHZhbCBpcyBleHBlcmltZW50YWwsIGl0cyBiZWhhdmlvciBhbmQgQVBJIG1heSBjaGFuZ2UgbW92aW5nIGZvcndhcmQuIFBsZWFzZSBwbGF5IHdpdGggaXQgYW5kIHJlcG9ydCBidWdzIGFuZCBpZGVhcyBvbiBob3cgdG8gaW1wcm92ZSBpdC5cIik7XG5cdFx0XHQoY2hhaW4gPSBndW4uY2hhaW4oKSkuXy5uaXggPSBndW4ub25jZShmdW5jdGlvbihkYXRhLCBrZXkpeyBjaGFpbi5fLm9uKCdpbicsIHRoaXMuXykgfSk7XG5cdFx0XHRjaGFpbi5fLmxleCA9IGd1bi5fLmxleDsgLy8gVE9ETzogQmV0dGVyIGFwcHJvYWNoIGluIGZ1dHVyZT8gVGhpcyBpcyBxdWljayBmb3Igbm93LlxuXHRcdFx0cmV0dXJuIGNoYWluO1xuXHRcdH1cblxuXHRcdEd1bi5jaGFpbi5vZmYgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gbWFrZSBvZmYgbW9yZSBhZ2dyZXNzaXZlLiBXYXJuaW5nLCBpdCBtaWdodCBiYWNrZmlyZSFcblx0XHRcdHZhciBndW4gPSB0aGlzLCBhdCA9IGd1bi5fLCB0bXA7XG5cdFx0XHR2YXIgY2F0ID0gYXQuYmFjaztcblx0XHRcdGlmKCFjYXQpeyByZXR1cm4gfVxuXHRcdFx0YXQuYWNrID0gMDsgLy8gc28gY2FuIHJlc3Vic2NyaWJlLlxuXHRcdFx0aWYodG1wID0gY2F0Lm5leHQpe1xuXHRcdFx0XHRpZih0bXBbYXQuZ2V0XSl7XG5cdFx0XHRcdFx0ZGVsZXRlIHRtcFthdC5nZXRdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFRPRE86IGRlbGV0ZSBjYXQub25lW21hcC5pZF0/XG5cdFx0XHRpZiAodG1wID0gY2F0LmFueSkge1xuXHRcdFx0XHRkZWxldGUgY2F0LmFueTtcblx0XHRcdFx0Y2F0LmFueSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0aWYodG1wID0gY2F0LmFzayl7XG5cdFx0XHRcdGRlbGV0ZSB0bXBbYXQuZ2V0XTtcblx0XHRcdH1cblx0XHRcdGlmKHRtcCA9IGNhdC5wdXQpe1xuXHRcdFx0XHRkZWxldGUgdG1wW2F0LmdldF07XG5cdFx0XHR9XG5cdFx0XHRpZih0bXAgPSBhdC5zb3VsKXtcblx0XHRcdFx0ZGVsZXRlIGNhdC5yb290LmdyYXBoW3RtcF07XG5cdFx0XHR9XG5cdFx0XHRpZih0bXAgPSBhdC5tYXApe1xuXHRcdFx0XHRPYmplY3Qua2V5cyh0bXApLmZvckVhY2goZnVuY3Rpb24oaSxhdCl7IGF0ID0gdG1wW2ldOyAvL29ial9tYXAodG1wLCBmdW5jdGlvbihhdCl7XG5cdFx0XHRcdFx0aWYoYXQubGluayl7XG5cdFx0XHRcdFx0XHRjYXQucm9vdC4kLmdldChhdC5saW5rKS5vZmYoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0aWYodG1wID0gYXQubmV4dCl7XG5cdFx0XHRcdE9iamVjdC5rZXlzKHRtcCkuZm9yRWFjaChmdW5jdGlvbihpLG5lYXQpeyBuZWF0ID0gdG1wW2ldOyAvL29ial9tYXAodG1wLCBmdW5jdGlvbihuZWF0KXtcblx0XHRcdFx0XHRuZWF0LiQub2ZmKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0YXQub24oJ29mZicsIHt9KTtcblx0XHRcdHJldHVybiBndW47XG5cdFx0fVxuXHRcdHZhciBlbXB0eSA9IHt9LCBub29wID0gZnVuY3Rpb24oKXt9LCB1O1xuXHR9KShVU0UsICcuL29uJyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdHZhciBHdW4gPSBVU0UoJy4vaW5kZXgnKSwgbmV4dCA9IEd1bi5jaGFpbi5nZXQubmV4dDtcblx0XHRHdW4uY2hhaW4uZ2V0Lm5leHQgPSBmdW5jdGlvbihndW4sIGxleCl7IHZhciB0bXA7XG5cdFx0XHRpZighT2JqZWN0LnBsYWluKGxleCkpeyByZXR1cm4gKG5leHR8fG5vb3ApKGd1biwgbGV4KSB9XG5cdFx0XHRpZih0bXAgPSAoKHRtcCA9IGxleFsnIyddKXx8JycpWyc9J10gfHwgdG1wKXsgcmV0dXJuIGd1bi5nZXQodG1wKSB9XG5cdFx0XHQodG1wID0gZ3VuLmNoYWluKCkuXykubGV4ID0gbGV4OyAvLyBMRVghXG5cdFx0XHRndW4ub24oJ2luJywgZnVuY3Rpb24oZXZlKXtcblx0XHRcdFx0aWYoU3RyaW5nLm1hdGNoKGV2ZS5nZXR8fCAoZXZlLnB1dHx8JycpWycuJ10sIGxleFsnLiddIHx8IGxleFsnIyddIHx8IGxleCkpe1xuXHRcdFx0XHRcdHRtcC5vbignaW4nLCBldmUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudG8ubmV4dChldmUpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gdG1wLiQ7XG5cdFx0fVxuXHRcdEd1bi5jaGFpbi5tYXAgPSBmdW5jdGlvbihjYiwgb3B0LCB0KXtcblx0XHRcdHZhciBndW4gPSB0aGlzLCBjYXQgPSBndW4uXywgbGV4LCBjaGFpbjtcblx0XHRcdGlmKE9iamVjdC5wbGFpbihjYikpeyBsZXggPSBjYlsnLiddPyBjYiA6IHsnLic6IGNifTsgY2IgPSB1IH1cblx0XHRcdGlmKCFjYil7XG5cdFx0XHRcdGlmKGNoYWluID0gY2F0LmVhY2gpeyByZXR1cm4gY2hhaW4gfVxuXHRcdFx0XHQoY2F0LmVhY2ggPSBjaGFpbiA9IGd1bi5jaGFpbigpKS5fLmxleCA9IGxleCB8fCBjaGFpbi5fLmxleCB8fCBjYXQubGV4O1xuXHRcdFx0XHRjaGFpbi5fLm5peCA9IGd1bi5iYWNrKCduaXgnKTtcblx0XHRcdFx0Z3VuLm9uKCdpbicsIG1hcCwgY2hhaW4uXyk7XG5cdFx0XHRcdHJldHVybiBjaGFpbjtcblx0XHRcdH1cblx0XHRcdEd1bi5sb2cub25jZShcIm1hcGZuXCIsIFwiTWFwIGZ1bmN0aW9ucyBhcmUgZXhwZXJpbWVudGFsLCB0aGVpciBiZWhhdmlvciBhbmQgQVBJIG1heSBjaGFuZ2UgbW92aW5nIGZvcndhcmQuIFBsZWFzZSBwbGF5IHdpdGggaXQgYW5kIHJlcG9ydCBidWdzIGFuZCBpZGVhcyBvbiBob3cgdG8gaW1wcm92ZSBpdC5cIik7XG5cdFx0XHRjaGFpbiA9IGd1bi5jaGFpbigpO1xuXHRcdFx0Z3VuLm1hcCgpLm9uKGZ1bmN0aW9uKGRhdGEsIGtleSwgbXNnLCBldmUpe1xuXHRcdFx0XHR2YXIgbmV4dCA9IChjYnx8bm9vcCkuY2FsbCh0aGlzLCBkYXRhLCBrZXksIG1zZywgZXZlKTtcblx0XHRcdFx0aWYodSA9PT0gbmV4dCl7IHJldHVybiB9XG5cdFx0XHRcdGlmKGRhdGEgPT09IG5leHQpeyByZXR1cm4gY2hhaW4uXy5vbignaW4nLCBtc2cpIH1cblx0XHRcdFx0aWYoR3VuLmlzKG5leHQpKXsgcmV0dXJuIGNoYWluLl8ub24oJ2luJywgbmV4dC5fKSB9XG5cdFx0XHRcdHZhciB0bXAgPSB7fTsgT2JqZWN0LmtleXMobXNnLnB1dCkuZm9yRWFjaChmdW5jdGlvbihrKXsgdG1wW2tdID0gbXNnLnB1dFtrXSB9LCB0bXApOyB0bXBbJz0nXSA9IG5leHQ7IFxuXHRcdFx0XHRjaGFpbi5fLm9uKCdpbicsIHtnZXQ6IGtleSwgcHV0OiB0bXB9KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGNoYWluO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBtYXAobXNnKXsgdGhpcy50by5uZXh0KG1zZyk7XG5cdFx0XHR2YXIgY2F0ID0gdGhpcy5hcywgZ3VuID0gbXNnLiQsIGF0ID0gZ3VuLl8sIHB1dCA9IG1zZy5wdXQsIHRtcDtcblx0XHRcdGlmKCFhdC5zb3VsICYmICFtc2cuJCQpeyByZXR1cm4gfSAvLyB0aGlzIGxpbmUgdG9vayBodW5kcmVkcyBvZiB0cmllcyB0byBmaWd1cmUgb3V0LiBJdCBvbmx5IHdvcmtzIGlmIGNvcmUgY2hlY2tzIHRvIGZpbHRlciBvdXQgYWJvdmUgY2hhaW5zIGR1cmluZyBsaW5rIHRoby4gVGhpcyBzYXlzIFwib25seSBib3RoZXIgdG8gbWFwIG9uIGEgbm9kZVwiIGZvciB0aGlzIGxheWVyIG9mIHRoZSBjaGFpbi4gSWYgc29tZXRoaW5nIGlzIG5vdCBhIG5vZGUsIG1hcCBzaG91bGQgbm90IHdvcmsuXG5cdFx0XHRpZigodG1wID0gY2F0LmxleCkgJiYgIVN0cmluZy5tYXRjaChtc2cuZ2V0fHwgKHB1dHx8JycpWycuJ10sIHRtcFsnLiddIHx8IHRtcFsnIyddIHx8IHRtcCkpeyByZXR1cm4gfVxuXHRcdFx0R3VuLm9uLmxpbmsobXNnLCBjYXQpO1xuXHRcdH1cblx0XHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCl7fSwgZXZlbnQgPSB7c3R1bjogbm9vcCwgb2ZmOiBub29wfSwgdTtcblx0fSkoVVNFLCAnLi9tYXAnKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0dmFyIEd1biA9IFVTRSgnLi9pbmRleCcpO1xuXHRcdEd1bi5jaGFpbi5zZXQgPSBmdW5jdGlvbihpdGVtLCBjYiwgb3B0KXtcblx0XHRcdHZhciBndW4gPSB0aGlzLCByb290ID0gZ3VuLmJhY2soLTEpLCBzb3VsLCB0bXA7XG5cdFx0XHRjYiA9IGNiIHx8IGZ1bmN0aW9uKCl7fTtcblx0XHRcdG9wdCA9IG9wdCB8fCB7fTsgb3B0Lml0ZW0gPSBvcHQuaXRlbSB8fCBpdGVtO1xuXHRcdFx0aWYoc291bCA9ICgoaXRlbXx8JycpLl98fCcnKVsnIyddKXsgKGl0ZW0gPSB7fSlbJyMnXSA9IHNvdWwgfSAvLyBjaGVjayBpZiBub2RlLCBtYWtlIGxpbmsuXG5cdFx0XHRpZignc3RyaW5nJyA9PSB0eXBlb2YgKHRtcCA9IEd1bi52YWxpZChpdGVtKSkpeyByZXR1cm4gZ3VuLmdldChzb3VsID0gdG1wKS5wdXQoaXRlbSwgY2IsIG9wdCkgfSAvLyBjaGVjayBpZiBsaW5rXG5cdFx0XHRpZighR3VuLmlzKGl0ZW0pKXtcblx0XHRcdFx0aWYoT2JqZWN0LnBsYWluKGl0ZW0pKXtcblx0XHRcdFx0XHRpdGVtID0gcm9vdC5nZXQoc291bCA9IGd1bi5iYWNrKCdvcHQudXVpZCcpKCkpLnB1dChpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZ3VuLmdldChzb3VsIHx8IHJvb3QuYmFjaygnb3B0LnV1aWQnKSg3KSkucHV0KGl0ZW0sIGNiLCBvcHQpO1xuXHRcdFx0fVxuXHRcdFx0Z3VuLnB1dChmdW5jdGlvbihnbyl7XG5cdFx0XHRcdGl0ZW0uZ2V0KGZ1bmN0aW9uKHNvdWwsIG8sIG1zZyl7IC8vIFRPRE86IEJVRyEgV2Ugbm8gbG9uZ2VyIGhhdmUgdGhpcyBvcHRpb24/ICYgZ28gZXJyb3Igbm90IGhhbmRsZWQ/XG5cdFx0XHRcdFx0aWYoIXNvdWwpeyByZXR1cm4gY2IuY2FsbChndW4sIHtlcnI6IEd1bi5sb2coJ09ubHkgYSBub2RlIGNhbiBiZSBsaW5rZWQhIE5vdCBcIicgKyBtc2cucHV0ICsgJ1wiIScpfSkgfVxuXHRcdFx0XHRcdCh0bXAgPSB7fSlbc291bF0gPSB7JyMnOiBzb3VsfTsgZ28odG1wKTtcblx0XHRcdFx0fSx0cnVlKTtcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9XG5cdH0pKFVTRSwgJy4vc2V0Jyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFVTRSgnLi9zaGltJyk7XG5cblx0XHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCl7fVxuXHRcdHZhciBwYXJzZSA9IEpTT04ucGFyc2VBc3luYyB8fCBmdW5jdGlvbih0LGNiLHIpeyB2YXIgdSwgZCA9ICtuZXcgRGF0ZTsgdHJ5eyBjYih1LCBKU09OLnBhcnNlKHQsciksIGpzb24uc3Vja3MoK25ldyBEYXRlIC0gZCkpIH1jYXRjaChlKXsgY2IoZSkgfSB9XG5cdFx0dmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeUFzeW5jIHx8IGZ1bmN0aW9uKHYsY2IscixzKXsgdmFyIHUsIGQgPSArbmV3IERhdGU7IHRyeXsgY2IodSwgSlNPTi5zdHJpbmdpZnkodixyLHMpLCBqc29uLnN1Y2tzKCtuZXcgRGF0ZSAtIGQpKSB9Y2F0Y2goZSl7IGNiKGUpIH0gfVxuXHRcdGpzb24uc3Vja3MgPSBmdW5jdGlvbihkKXsgaWYoZCA+IDk5KXsgY29uc29sZS5sb2coXCJXYXJuaW5nOiBKU09OIGJsb2NraW5nIENQVSBkZXRlY3RlZC4gQWRkIGBndW4vbGliL3lzb24uanNgIHRvIGZpeC5cIik7IGpzb24uc3Vja3MgPSBub29wIH0gfVxuXG5cdFx0ZnVuY3Rpb24gTWVzaChyb290KXtcblx0XHRcdHZhciBtZXNoID0gZnVuY3Rpb24oKXt9O1xuXHRcdFx0dmFyIG9wdCA9IHJvb3Qub3B0IHx8IHt9O1xuXHRcdFx0b3B0LmxvZyA9IG9wdC5sb2cgfHwgY29uc29sZS5sb2c7XG5cdFx0XHRvcHQuZ2FwID0gb3B0LmdhcCB8fCBvcHQud2FpdCB8fCAwO1xuXHRcdFx0b3B0Lm1heCA9IG9wdC5tYXggfHwgKG9wdC5tZW1vcnk/IChvcHQubWVtb3J5ICogOTk5ICogOTk5KSA6IDMwMDAwMDAwMCkgKiAwLjM7XG5cdFx0XHRvcHQucGFjayA9IG9wdC5wYWNrIHx8IChvcHQubWF4ICogMC4wMSAqIDAuMDEpO1xuXHRcdFx0b3B0LnB1ZmYgPSBvcHQucHVmZiB8fCA5OyAvLyBJREVBOiBkbyBhIHN0YXJ0L2VuZCBiZW5jaG1hcmssIGRpdmlkZSBvcHMvcmVzdWx0LlxuXHRcdFx0dmFyIHB1ZmYgPSBzZXRUaW1lb3V0LnR1cm4gfHwgc2V0VGltZW91dDtcblxuXHRcdFx0dmFyIGR1cCA9IHJvb3QuZHVwLCBkdXBfY2hlY2sgPSBkdXAuY2hlY2ssIGR1cF90cmFjayA9IGR1cC50cmFjaztcblxuXHRcdFx0dmFyIFNUID0gK25ldyBEYXRlLCBMVCA9IFNUO1xuXG5cdFx0XHR2YXIgaGVhciA9IG1lc2guaGVhciA9IGZ1bmN0aW9uKHJhdywgcGVlcil7XG5cdFx0XHRcdGlmKCFyYXcpeyByZXR1cm4gfVxuXHRcdFx0XHRpZihvcHQubWF4IDw9IHJhdy5sZW5ndGgpeyByZXR1cm4gbWVzaC5zYXkoe2RhbTogJyEnLCBlcnI6IFwiTWVzc2FnZSB0b28gYmlnIVwifSwgcGVlcikgfVxuXHRcdFx0XHRpZihtZXNoID09PSB0aGlzKXtcblx0XHRcdFx0XHQvKmlmKCdzdHJpbmcnID09IHR5cGVvZiByYXcpeyB0cnl7XG5cdFx0XHRcdFx0XHR2YXIgc3RhdCA9IGNvbnNvbGUuU1RBVCB8fCB7fTtcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ0hFQVI6JywgcGVlci5pZCwgKHJhd3x8JycpLnNsaWNlKDAsMjUwKSwgKChyYXd8fCcnKS5sZW5ndGggLyAxMDI0IC8gMTAyNCkudG9GaXhlZCg0KSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coc2V0VGltZW91dC50dXJuLnMubGVuZ3RoLCAnc3RhY2tzJywgcGFyc2VGbG9hdCgoLShMVCAtIChMVCA9ICtuZXcgRGF0ZSkpLzEwMDApLnRvRml4ZWQoMykpLCAnc2VjJywgcGFyc2VGbG9hdCgoKExULVNUKS8xMDAwIC8gNjApLnRvRml4ZWQoMSkpLCAndXAnLCBzdGF0LnBlZXJzfHwwLCAncGVlcnMnLCBzdGF0Lmhhc3x8MCwgJ2hhcycsIHN0YXQubWVtaHVzZWR8fDAsIHN0YXQubWVtdXNlZHx8MCwgc3RhdC5tZW1heHx8MCwgJ2hlYXAgbWVtIG1heCcpO1xuXHRcdFx0XHRcdH1jYXRjaChlKXsgY29uc29sZS5sb2coJ0RCRyBlcnInLCBlKSB9fSovXG5cdFx0XHRcdFx0aGVhci5kICs9IHJhdy5sZW5ndGh8fDAgOyArK2hlYXIuYyB9IC8vIFNUQVRTIVxuXHRcdFx0XHR2YXIgUyA9IHBlZXIuU0ggPSArbmV3IERhdGU7XG5cdFx0XHRcdHZhciB0bXAgPSByYXdbMF0sIG1zZztcblx0XHRcdFx0Ly9yYXcgJiYgcmF3LnNsaWNlICYmIGNvbnNvbGUubG9nKFwiaGVhcjpcIiwgKChwZWVyLndpcmV8fCcnKS5oZWFkZXJzfHwnJykub3JpZ2luLCByYXcubGVuZ3RoLCByYXcuc2xpY2UgJiYgcmF3LnNsaWNlKDAsNTApKTsgLy90Yy1pYW11bmlxdWUtdGMtcGFja2FnZS1kczFcblx0XHRcdFx0aWYoJ1snID09PSB0bXApe1xuXHRcdFx0XHRcdHBhcnNlKHJhdywgZnVuY3Rpb24oZXJyLCBtc2cpe1xuXHRcdFx0XHRcdFx0aWYoZXJyIHx8ICFtc2cpeyByZXR1cm4gbWVzaC5zYXkoe2RhbTogJyEnLCBlcnI6IFwiREFNIEpTT04gcGFyc2UgZXJyb3IuXCJ9LCBwZWVyKSB9XG5cdFx0XHRcdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKCtuZXcgRGF0ZSwgbXNnLmxlbmd0aCwgJyMgb24gaGVhciBiYXRjaCcpO1xuXHRcdFx0XHRcdFx0dmFyIFAgPSBvcHQucHVmZjtcblx0XHRcdFx0XHRcdChmdW5jdGlvbiBnbygpe1xuXHRcdFx0XHRcdFx0XHR2YXIgUyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0XHRcdFx0dmFyIGkgPSAwLCBtOyB3aGlsZShpIDwgUCAmJiAobSA9IG1zZ1tpKytdKSl7IG1lc2guaGVhcihtLCBwZWVyKSB9XG5cdFx0XHRcdFx0XHRcdG1zZyA9IG1zZy5zbGljZShpKTsgLy8gc2xpY2luZyBhZnRlciBpcyBmYXN0ZXIgdGhhbiBzaGlmdGluZyBkdXJpbmcuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgK25ldyBEYXRlIC0gUywgJ2hlYXIgbG9vcCcpO1xuXHRcdFx0XHRcdFx0XHRmbHVzaChwZWVyKTsgLy8gZm9yY2Ugc2VuZCBhbGwgc3luY2hyb25vdXNseSBiYXRjaGVkIGFja3MuXG5cdFx0XHRcdFx0XHRcdGlmKCFtc2cubGVuZ3RoKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRcdFx0cHVmZihnbywgMCk7XG5cdFx0XHRcdFx0XHR9KCkpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJhdyA9ICcnOyAvLyBcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoJ3snID09PSB0bXAgfHwgKChyYXdbJyMnXSB8fCBPYmplY3QucGxhaW4ocmF3KSkgJiYgKG1zZyA9IHJhdykpKXtcblx0XHRcdFx0XHRpZihtc2cpeyByZXR1cm4gaGVhci5vbmUobXNnLCBwZWVyLCBTKSB9XG5cdFx0XHRcdFx0cGFyc2UocmF3LCBmdW5jdGlvbihlcnIsIG1zZyl7XG5cdFx0XHRcdFx0XHRpZihlcnIgfHwgIW1zZyl7IHJldHVybiBtZXNoLnNheSh7ZGFtOiAnIScsIGVycjogXCJEQU0gSlNPTiBwYXJzZSBlcnJvci5cIn0sIHBlZXIpIH1cblx0XHRcdFx0XHRcdGhlYXIub25lKG1zZywgcGVlciwgUyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRoZWFyLm9uZSA9IGZ1bmN0aW9uKG1zZywgcGVlciwgUyl7IC8vIFMgaGVyZSBpcyB0ZW1wb3JhcnkhIFVuZG8uXG5cdFx0XHRcdHZhciBpZCwgaGFzaCwgdG1wLCBhc2gsIERCRztcblx0XHRcdFx0aWYobXNnLkRCRyl7IG1zZy5EQkcgPSBEQkcgPSB7REJHOiBtc2cuREJHfSB9XG5cdFx0XHRcdERCRyAmJiAoREJHLmggPSBTKTtcblx0XHRcdFx0REJHICYmIChEQkcuaHAgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRpZighKGlkID0gbXNnWycjJ10pKXsgaWQgPSBtc2dbJyMnXSA9IFN0cmluZy5yYW5kb20oOSkgfVxuXHRcdFx0XHRpZih0bXAgPSBkdXBfY2hlY2soaWQpKXsgcmV0dXJuIH1cblx0XHRcdFx0Ly8gREFNIGxvZ2ljOlxuXHRcdFx0XHRpZighKGhhc2ggPSBtc2dbJyMjJ10pICYmIGZhbHNlICYmIHUgIT09IG1zZy5wdXQpeyAvKmhhc2ggPSBtc2dbJyMjJ10gPSBUeXBlLm9iai5oYXNoKG1zZy5wdXQpKi8gfSAvLyBkaXNhYmxlIGhhc2hpbmcgZm9yIG5vdyAvLyBUT0RPOiBpbXBvc2Ugd2FybmluZy9wZW5hbHR5IGluc3RlYWQgKD8pXG5cdFx0XHRcdGlmKGhhc2ggJiYgKHRtcCA9IG1zZ1snQCddIHx8IChtc2cuZ2V0ICYmIGlkKSkgJiYgZHVwLmNoZWNrKGFzaCA9IHRtcCtoYXNoKSl7IHJldHVybiB9IC8vIEltYWdpbmUgQSA8LT4gQiA8PT4gKEMgJiBEKSwgQyAmIEQgcmVwbHkgd2l0aCBzYW1lIEFDSyBidXQgaGF2ZSBkaWZmZXJlbnQgSURzLCBCIGNhbiB1c2UgaGFzaCB0byBkZWR1cC4gT3IgaWYgYSBHRVQgaGFzIGEgaGFzaCBhbHJlYWR5LCB3ZSBzaG91bGRuJ3QgQUNLIGlmIHNhbWUuXG5cdFx0XHRcdChtc2cuXyA9IGZ1bmN0aW9uKCl7fSkudmlhID0gbWVzaC5sZWFwID0gcGVlcjtcblx0XHRcdFx0aWYoKHRtcCA9IG1zZ1snPjwnXSkgJiYgJ3N0cmluZycgPT0gdHlwZW9mIHRtcCl7IHRtcC5zbGljZSgwLDk5KS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24oayl7IHRoaXNba10gPSAxIH0sIChtc2cuXykueW8gPSB7fSkgfSAvLyBQZWVycyBhbHJlYWR5IHNlbnQgdG8sIGRvIG5vdCByZXNlbmQuXG5cdFx0XHRcdC8vIERBTSBeXG5cdFx0XHRcdGlmKHRtcCA9IG1zZy5kYW0pe1xuXHRcdFx0XHRcdGlmKHRtcCA9IG1lc2guaGVhclt0bXBdKXtcblx0XHRcdFx0XHRcdHRtcChtc2csIHBlZXIsIHJvb3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkdXBfdHJhY2soaWQpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0bXAgPSBtc2cub2speyBtc2cuXy5uZWFyID0gdG1wWycvJ10gfVxuXHRcdFx0XHR2YXIgUyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0REJHICYmIChEQkcuaXMgPSBTKTsgcGVlci5TSSA9IGlkO1xuXHRcdFx0XHRkdXBfdHJhY2suZWQgPSBmdW5jdGlvbihkKXtcblx0XHRcdFx0XHRpZihpZCAhPT0gZCl7IHJldHVybiB9XG5cdFx0XHRcdFx0ZHVwX3RyYWNrLmVkID0gMDtcblx0XHRcdFx0XHRpZighKGQgPSBkdXAuc1tpZF0pKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRkLnZpYSA9IHBlZXI7XG5cdFx0XHRcdFx0aWYobXNnLmdldCl7IGQuaXQgPSBtc2cgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJvb3Qub24oJ2luJywgbWVzaC5sYXN0ID0gbXNnKTtcblx0XHRcdFx0REJHICYmIChEQkcuaGQgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKFMsICtuZXcgRGF0ZSAtIFMsIG1zZy5nZXQ/ICdtc2cgZ2V0JyA6IG1zZy5wdXQ/ICdtc2cgcHV0JyA6ICdtc2cnKTtcblx0XHRcdFx0ZHVwX3RyYWNrKGlkKTsgLy8gaW4gY2FzZSAnaW4nIGRvZXMgbm90IGNhbGwgdHJhY2suXG5cdFx0XHRcdGlmKGFzaCl7IGR1cF90cmFjayhhc2gpIH0gLy9kdXAudHJhY2sodG1wK2hhc2gsIHRydWUpLml0ID0gaXQobXNnKTtcblx0XHRcdFx0bWVzaC5sZWFwID0gbWVzaC5sYXN0ID0gbnVsbDsgLy8gd2FybmluZyEgbWVzaC5sZWFwIGNvdWxkIGJlIGJ1Z2d5LlxuXHRcdFx0fVxuXHRcdFx0dmFyIHRvbWFwID0gZnVuY3Rpb24oayxpLG0pe20oayx0cnVlKX07XG5cdFx0XHRoZWFyLmMgPSBoZWFyLmQgPSAwO1xuXG5cdFx0XHQ7KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBTTUlBID0gMDtcblx0XHRcdFx0dmFyIGxvb3A7XG5cdFx0XHRcdG1lc2guaGFzaCA9IGZ1bmN0aW9uKG1zZywgcGVlcil7IHZhciBoLCBzLCB0O1xuXHRcdFx0XHRcdHZhciBTID0gK25ldyBEYXRlO1xuXHRcdFx0XHRcdGpzb24obXNnLnB1dCwgZnVuY3Rpb24gaGFzaChlcnIsIHRleHQpe1xuXHRcdFx0XHRcdFx0dmFyIHNzID0gKHMgfHwgKHMgPSB0ID0gdGV4dHx8JycpKS5zbGljZSgwLCAzMjc2OCk7IC8vIDEwMjQgKiAzMlxuXHRcdFx0XHRcdCAgaCA9IFN0cmluZy5oYXNoKHNzLCBoKTsgcyA9IHMuc2xpY2UoMzI3NjgpO1xuXHRcdFx0XHRcdCAgaWYocyl7IHB1ZmYoaGFzaCwgMCk7IHJldHVybiB9XG5cdFx0XHRcdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKFMsICtuZXcgRGF0ZSAtIFMsICdzYXkganNvbitoYXNoJyk7XG5cdFx0XHRcdFx0ICBtc2cuXy4kcHV0ID0gdDtcblx0XHRcdFx0XHQgIG1zZ1snIyMnXSA9IGg7XG5cdFx0XHRcdFx0ICBtZXNoLnNheShtc2csIHBlZXIpO1xuXHRcdFx0XHRcdCAgZGVsZXRlIG1zZy5fLiRwdXQ7XG5cdFx0XHRcdFx0fSwgc29ydCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gc29ydChrLCB2KXsgdmFyIHRtcDtcblx0XHRcdFx0XHRpZighKHYgaW5zdGFuY2VvZiBPYmplY3QpKXsgcmV0dXJuIHYgfVxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKHYpLnNvcnQoKS5mb3JFYWNoKHNvcnRhLCB7dG86IHRtcCA9IHt9LCBvbjogdn0pO1xuXHRcdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHRcdH0gZnVuY3Rpb24gc29ydGEoayl7IHRoaXMudG9ba10gPSB0aGlzLm9uW2tdIH1cblxuXHRcdFx0XHR2YXIgc2F5ID0gbWVzaC5zYXkgPSBmdW5jdGlvbihtc2csIHBlZXIpeyB2YXIgdG1wO1xuXHRcdFx0XHRcdGlmKCh0bXAgPSB0aGlzKSAmJiAodG1wID0gdG1wLnRvKSAmJiB0bXAubmV4dCl7IHRtcC5uZXh0KG1zZykgfSAvLyBjb21wYXRpYmxlIHdpdGggbWlkZGxld2FyZSBhZGFwdGVycy5cblx0XHRcdFx0XHRpZighbXNnKXsgcmV0dXJuIGZhbHNlIH1cblx0XHRcdFx0XHR2YXIgaWQsIGhhc2gsIHJhdywgYWNrID0gbXNnWydAJ107XG4vL2lmKG9wdC5zdXBlciAmJiAoIWFjayB8fCAhbXNnLnB1dCkpeyByZXR1cm4gfSAvLyBUT0RPOiBNQU5IQVRUQU4gU1RVQiAvL09CVklPVVNMWSBCVUchIEJ1dCBzcXVlbGNoIHJlbGF5LiAvLyA6KCBnZXQgb25seSBpcyAxMDAlKyBDUFUgdXNhZ2UgOihcblx0XHRcdFx0XHR2YXIgbWV0YSA9IG1zZy5ffHwobXNnLl89ZnVuY3Rpb24oKXt9KTtcblx0XHRcdFx0XHR2YXIgREJHID0gbXNnLkRCRywgUyA9ICtuZXcgRGF0ZTsgbWV0YS55ID0gbWV0YS55IHx8IFM7IGlmKCFwZWVyKXsgREJHICYmIChEQkcueSA9IFMpIH1cblx0XHRcdFx0XHRpZighKGlkID0gbXNnWycjJ10pKXsgaWQgPSBtc2dbJyMnXSA9IFN0cmluZy5yYW5kb20oOSkgfVxuXHRcdFx0XHRcdCFsb29wICYmIGR1cF90cmFjayhpZCk7Ly8uaXQgPSBpdChtc2cpOyAvLyB0cmFjayBmb3IgOSBzZWNvbmRzLCBkZWZhdWx0LiBFYXJ0aDwtPk1hcnMgd291bGQgbmVlZCBtb3JlISAvLyBhbHdheXMgdHJhY2ssIG1heWJlIG1vdmUgdGhpcyB0byB0aGUgJ2FmdGVyJyBsb2dpYyBpZiB3ZSBzcGxpdCBmdW5jdGlvbi5cblx0XHRcdFx0XHQvL2lmKG1zZy5wdXQgJiYgKG1zZy5lcnIgfHwgKGR1cC5zW2lkXXx8JycpLmVycikpeyByZXR1cm4gZmFsc2UgfSAvLyBUT0RPOiBpbiB0aGVvcnkgd2Ugc2hvdWxkIG5vdCBiZSBhYmxlIHRvIHN0dW4gYSBtZXNzYWdlLCBidXQgZm9yIG5vdyBnb2luZyB0byBjaGVjayBpZiBpdCBjYW4gaGVscCBuZXR3b3JrIHBlcmZvcm1hbmNlIHByZXZlbnRpbmcgaW52YWxpZCBkYXRhIHRvIHJlbGF5LlxuXHRcdFx0XHRcdGlmKCEoaGFzaCA9IG1zZ1snIyMnXSkgJiYgdSAhPT0gbXNnLnB1dCAmJiAhbWV0YS52aWEgJiYgYWNrKXsgbWVzaC5oYXNoKG1zZywgcGVlcik7IHJldHVybiB9IC8vIFRPRE86IFNob3VsZCBicm9hZGNhc3RzIGJlIGhhc2hlZD9cblx0XHRcdFx0XHRpZighcGVlciAmJiBhY2speyBwZWVyID0gKCh0bXAgPSBkdXAuc1thY2tdKSAmJiAodG1wLnZpYSB8fCAoKHRtcCA9IHRtcC5pdCkgJiYgKHRtcCA9IHRtcC5fKSAmJiB0bXAudmlhKSkpIHx8ICgodG1wID0gbWVzaC5sYXN0KSAmJiBhY2sgPT09IHRtcFsnIyddICYmIG1lc2gubGVhcCkgfSAvLyB3YXJuaW5nISBtZXNoLmxlYXAgY291bGQgYmUgYnVnZ3khIG1lc2ggbGFzdCBjaGVjayByZWR1Y2VzIHRoaXMuIC8vIFRPRE86IENMRUFOIFVQIFRISVMgTElORSBOT1c/IGAuaXRgIHNob3VsZCBiZSByZWxpYWJsZS5cblx0XHRcdFx0XHRpZighcGVlciAmJiBhY2speyAvLyBzdGlsbCBubyBwZWVyLCB0aGVuIGFjayBkYWlzeSBjaGFpbiAndHVubmVsJyBnb3QgbG9zdC5cblx0XHRcdFx0XHRcdGlmKGR1cC5zW2Fja10peyByZXR1cm4gfSAvLyBpbiBkdXBzIGJ1dCBubyBwZWVyIGhpbnRzIHRoYXQgdGhpcyB3YXMgYWNrIHRvIG91cnNlbGYsIGlnbm9yZS5cblx0XHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoK25ldyBEYXRlLCArK1NNSUEsICd0b3RhbCBubyBwZWVyIHRvIGFjayB0bycpOyAvLyBUT0RPOiBEZWxldGUgdGhpcyBub3cuIERyb3BwaW5nIGxvc3QgQUNLcyBpcyBwcm90b2NvbCBmaW5lIG5vdy5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9IC8vIFRPRE86IFRlbXBvcmFyeT8gSWYgYWNrIHZpYSB0cmFjZSBoYXMgYmVlbiBsb3N0LCBhY2tzIHdpbGwgZ28gdG8gYWxsIHBlZXJzLCB3aGljaCB0cmFzaGVzIGJyb3dzZXIgYmFuZHdpZHRoLiBOb3QgcmVsYXlpbmcgdGhlIGFjayB3aWxsIGZvcmNlIHNlbmRlciB0byBhc2sgZm9yIGFjayBhZ2Fpbi4gTm90ZSwgdGhpcyBpcyB0ZWNobmljYWxseSB3cm9uZyBmb3IgbWVzaCBiZWhhdmlvci5cblx0XHRcdFx0XHRpZihhY2sgJiYgIW1zZy5wdXQgJiYgIWhhc2ggJiYgKChkdXAuc1thY2tdfHwnJykuaXR8fCcnKVsnIyMnXSl7IHJldHVybiBmYWxzZSB9IC8vIElmIHdlJ3JlIHNheWluZyAnbm90IGZvdW5kJyBidXQgYSByZWxheSBoYWQgZGF0YSwgZG8gbm90IGJvdGhlciBzZW5kaW5nIG91ciBub3QgZm91bmQuIC8vIElzIHRoaXMgY29ycmVjdCwgcmV0dXJuIGZhbHNlPyAvLyBOT1RFOiBBREQgUEFOSUMgVEVTVCBGT1IgVEhJUyFcblx0XHRcdFx0XHRpZighcGVlciAmJiBtZXNoLndheSl7IHJldHVybiBtZXNoLndheShtc2cpIH1cblx0XHRcdFx0XHREQkcgJiYgKERCRy55aCA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdFx0aWYoIShyYXcgPSBtZXRhLnJhdykpeyBtZXNoLnJhdyhtc2csIHBlZXIpOyByZXR1cm4gfVxuXHRcdFx0XHRcdERCRyAmJiAoREJHLnlyID0gK25ldyBEYXRlKTtcblx0XHRcdFx0XHRpZighcGVlciB8fCAhcGVlci5pZCl7XG5cdFx0XHRcdFx0XHRpZighT2JqZWN0LnBsYWluKHBlZXIgfHwgb3B0LnBlZXJzKSl7IHJldHVybiBmYWxzZSB9XG5cdFx0XHRcdFx0XHR2YXIgUyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0XHRcdHZhciBQID0gb3B0LnB1ZmYsIHBzID0gb3B0LnBlZXJzLCBwbCA9IE9iamVjdC5rZXlzKHBlZXIgfHwgb3B0LnBlZXJzIHx8IHt9KTsgLy8gVE9ETzogLmtleXMoIGlzIHNsb3dcblx0XHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgK25ldyBEYXRlIC0gUywgJ3BlZXIga2V5cycpO1xuXHRcdFx0XHRcdFx0OyhmdW5jdGlvbiBnbygpe1xuXHRcdFx0XHRcdFx0XHR2YXIgUyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0XHRcdFx0Ly9UeXBlLm9iai5tYXAocGVlciB8fCBvcHQucGVlcnMsIGVhY2gpOyAvLyBpbiBjYXNlIHBlZXIgaXMgYSBwZWVyIGxpc3QuXG5cdFx0XHRcdFx0XHRcdGxvb3AgPSAxOyB2YXIgd3IgPSBtZXRhLnJhdzsgbWV0YS5yYXcgPSByYXc7IC8vIHF1aWNrIHBlcmYgaGFja1xuXHRcdFx0XHRcdFx0XHR2YXIgaSA9IDAsIHA7IHdoaWxlKGkgPCA5ICYmIChwID0gKHBsfHwnJylbaSsrXSkpe1xuXHRcdFx0XHRcdFx0XHRcdGlmKCEocCA9IHBzW3BdIHx8IChwZWVyfHwnJylbcF0pKXsgY29udGludWUgfVxuXHRcdFx0XHRcdFx0XHRcdG1lc2guc2F5KG1zZywgcCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bWV0YS5yYXcgPSB3cjsgbG9vcCA9IDA7XG5cdFx0XHRcdFx0XHRcdHBsID0gcGwuc2xpY2UoaSk7IC8vIHNsaWNpbmcgYWZ0ZXIgaXMgZmFzdGVyIHRoYW4gc2hpZnRpbmcgZHVyaW5nLlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKFMsICtuZXcgRGF0ZSAtIFMsICdzYXkgbG9vcCcpO1xuXHRcdFx0XHRcdFx0XHRpZighcGwubGVuZ3RoKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRcdFx0cHVmZihnbywgMCk7XG5cdFx0XHRcdFx0XHRcdGFjayAmJiBkdXBfdHJhY2soYWNrKTsgLy8ga2VlcCBmb3IgbGF0ZXJcblx0XHRcdFx0XHRcdH0oKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFRPRE86IFBFUkY6IGNvbnNpZGVyIHNwbGl0dGluZyBmdW5jdGlvbiBoZXJlLCBzbyBzYXkgbG9vcHMgZG8gbGVzcyB3b3JrLlxuXHRcdFx0XHRcdGlmKCFwZWVyLndpcmUgJiYgbWVzaC53aXJlKXsgbWVzaC53aXJlKHBlZXIpIH1cblx0XHRcdFx0XHRpZihpZCA9PT0gcGVlci5sYXN0KXsgcmV0dXJuIH0gcGVlci5sYXN0ID0gaWQ7ICAvLyB3YXMgaXQganVzdCBzZW50P1xuXHRcdFx0XHRcdGlmKHBlZXIgPT09IG1ldGEudmlhKXsgcmV0dXJuIGZhbHNlIH0gLy8gZG9uJ3Qgc2VuZCBiYWNrIHRvIHNlbGYuXG5cdFx0XHRcdFx0aWYoKHRtcCA9IG1ldGEueW8pICYmICh0bXBbcGVlci51cmxdIHx8IHRtcFtwZWVyLnBpZF0gfHwgdG1wW3BlZXIuaWRdKSAvKiYmICFvKi8peyByZXR1cm4gZmFsc2UgfVxuXHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgKChEQkd8fG1ldGEpLnlwID0gK25ldyBEYXRlKSAtIChtZXRhLnkgfHwgUyksICdzYXkgcHJlcCcpO1xuXHRcdFx0XHRcdCFsb29wICYmIGFjayAmJiBkdXBfdHJhY2soYWNrKTsgLy8gc3RyZWFtaW5nIGxvbmcgcmVzcG9uc2VzIG5lZWRzIHRvIGtlZXAgYWxpdmUgdGhlIGFjay5cblx0XHRcdFx0XHRpZihwZWVyLmJhdGNoKXtcblx0XHRcdFx0XHRcdHBlZXIudGFpbCA9ICh0bXAgPSBwZWVyLnRhaWwgfHwgMCkgKyByYXcubGVuZ3RoO1xuXHRcdFx0XHRcdFx0aWYocGVlci50YWlsIDw9IG9wdC5wYWNrKXtcblx0XHRcdFx0XHRcdFx0cGVlci5iYXRjaCArPSAodG1wPycsJzonJykrcmF3O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmbHVzaChwZWVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGVlci5iYXRjaCA9ICdbJzsgLy8gUHJldmVudHMgZG91YmxlIEpTT04hXG5cdFx0XHRcdFx0dmFyIFNUID0gK25ldyBEYXRlO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoU1QsICtuZXcgRGF0ZSAtIFNULCAnMG1zIFRPJyk7XG5cdFx0XHRcdFx0XHRmbHVzaChwZWVyKTtcblx0XHRcdFx0XHR9LCBvcHQuZ2FwKTsgLy8gVE9ETzogcXVldWluZy9iYXRjaGluZyBtaWdodCBiZSBiYWQgZm9yIGxvdy1sYXRlbmN5IHZpZGVvIGdhbWUgcGVyZm9ybWFuY2UhIEFsbG93IG9wdCBvdXQ/XG5cdFx0XHRcdFx0c2VuZChyYXcsIHBlZXIpO1xuXHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiAoYWNrID09PSBwZWVyLlNJKSAmJiBjb25zb2xlLlNUQVQoUywgK25ldyBEYXRlIC0gcGVlci5TSCwgJ3NheSBhY2snKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZXNoLnNheS5jID0gbWVzaC5zYXkuZCA9IDA7XG5cdFx0XHRcdC8vIFRPRE86IHRoaXMgY2F1c2VkIGEgb3V0LW9mLW1lbW9yeSBjcmFzaCFcblx0XHRcdFx0bWVzaC5yYXcgPSBmdW5jdGlvbihtc2csIHBlZXIpeyAvLyBUT0RPOiBDbGVhbiB0aGlzIHVwIC8gZGVsZXRlIGl0IC8gbW92ZSBsb2dpYyBvdXQhXG5cdFx0XHRcdFx0aWYoIW1zZyl7IHJldHVybiAnJyB9XG5cdFx0XHRcdFx0dmFyIG1ldGEgPSAobXNnLl8pIHx8IHt9LCBwdXQsIHRtcDtcblx0XHRcdFx0XHRpZih0bXAgPSBtZXRhLnJhdyl7IHJldHVybiB0bXAgfVxuXHRcdFx0XHRcdGlmKCdzdHJpbmcnID09IHR5cGVvZiBtc2cpeyByZXR1cm4gbXNnIH1cblx0XHRcdFx0XHR2YXIgaGFzaCA9IG1zZ1snIyMnXSwgYWNrID0gbXNnWydAJ107XG5cdFx0XHRcdFx0aWYoaGFzaCAmJiBhY2spe1xuXHRcdFx0XHRcdFx0aWYoIW1ldGEudmlhICYmIGR1cF9jaGVjayhhY2sraGFzaCkpeyByZXR1cm4gZmFsc2UgfSAvLyBmb3Igb3VyIG93biBvdXQgbWVzc2FnZXMsIG1lbW9yeSAmIHN0b3JhZ2UgbWF5IGFjayB0aGUgc2FtZSB0aGluZywgc28gZGVkdXAgdGhhdC4gVGhvIGlmIHZpYSBhbm90aGVyIHBlZXIsIHdlIGFscmVhZHkgdHJhY2tlZCBpdCB1cG9uIGhlYXJpbmcsIHNvIHRoaXMgd2lsbCBhbHdheXMgdHJpZ2dlciBmYWxzZSBwb3NpdGl2ZXMsIHNvIGRvbid0IGRvIHRoYXQhXG5cdFx0XHRcdFx0XHRpZih0bXAgPSAoZHVwLnNbYWNrXXx8JycpLml0KXtcblx0XHRcdFx0XHRcdFx0aWYoaGFzaCA9PT0gdG1wWycjIyddKXsgcmV0dXJuIGZhbHNlIH0gLy8gaWYgYXNrIGhhcyBhIG1hdGNoaW5nIGhhc2gsIGFja2luZyBpcyBvcHRpb25hbC5cblx0XHRcdFx0XHRcdFx0aWYoIXRtcFsnIyMnXSl7IHRtcFsnIyMnXSA9IGhhc2ggfSAvLyBpZiBub25lLCBhZGQgb3VyIGhhc2ggdG8gYXNrIHNvIGFueW9uZSB3ZSByZWxheSB0byBjYW4gZGVkdXAuIC8vIE5PVEU6IE1heSBvbmx5IGNoZWNrIGFnYWluc3QgMXN0IGFjayBjaHVuaywgMm5kKyB3b24ndCBrbm93IGFuZCBzdGlsbCBzdHJlYW0gYmFjayB0byByZWxheWluZyBwZWVycyB3aGljaCBtYXkgdGhlbiBkZWR1cC4gQW55IHdheSB0byBmaXggdGhpcyB3YXN0ZWQgYmFuZHdpZHRoPyBJIGd1ZXNzIGZvcmNlIHJhdGUgbGltaXRpbmcgYnJlYWtpbmcgY2hhbmdlLCB0aGF0IGFza2luZyBwZWVyIGhhcyB0byBhc2sgZm9yIG5leHQgbGV4aWNhbCBjaHVuay5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoIW1zZy5kYW0gJiYgIW1zZ1snQCddKXtcblx0XHRcdFx0XHRcdHZhciBpID0gMCwgdG8gPSBbXTsgdG1wID0gb3B0LnBlZXJzO1xuXHRcdFx0XHRcdFx0Zm9yKHZhciBrIGluIHRtcCl7IHZhciBwID0gdG1wW2tdOyAvLyBUT0RPOiBNYWtlIGl0IHVwIHBlZXJzIGluc3RlYWQhXG5cdFx0XHRcdFx0XHRcdHRvLnB1c2gocC51cmwgfHwgcC5waWQgfHwgcC5pZCk7XG5cdFx0XHRcdFx0XHRcdGlmKCsraSA+IDYpeyBicmVhayB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihpID4gMSl7IG1zZ1snPjwnXSA9IHRvLmpvaW4oKSB9IC8vIFRPRE86IEJVRyEgVGhpcyBnZXRzIHNldCByZWdhcmRsZXNzIG9mIHBlZXJzIHNlbnQgdG8hIERldGVjdD9cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYobXNnLnB1dCAmJiAodG1wID0gbXNnLm9rKSl7IG1zZy5vayA9IHsnQCc6KHRtcFsnQCddfHwxKS0xLCAnLyc6ICh0bXBbJy8nXT09bXNnLl8ubmVhcik/IG1lc2gubmVhciA6IHRtcFsnLyddfTsgfVxuXHRcdFx0XHRcdGlmKHB1dCA9IG1ldGEuJHB1dCl7XG5cdFx0XHRcdFx0XHR0bXAgPSB7fTsgT2JqZWN0LmtleXMobXNnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyB0bXBba10gPSBtc2dba10gfSk7XG5cdFx0XHRcdFx0XHR0bXAucHV0ID0gJzpdKShbOic7XG5cdFx0XHRcdFx0XHRqc29uKHRtcCwgZnVuY3Rpb24oZXJyLCByYXcpe1xuXHRcdFx0XHRcdFx0XHRpZihlcnIpeyByZXR1cm4gfSAvLyBUT0RPOiBIYW5kbGUhIVxuXHRcdFx0XHRcdFx0XHR2YXIgUyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0XHRcdFx0dG1wID0gcmF3LmluZGV4T2YoJ1wicHV0XCI6XCI6XSkoWzpcIicpO1xuXHRcdFx0XHRcdFx0XHRyZXModSwgcmF3ID0gcmF3LnNsaWNlKDAsIHRtcCs2KSArIHB1dCArIHJhdy5zbGljZSh0bXAgKyAxNCkpO1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKFMsICtuZXcgRGF0ZSAtIFMsICdzYXkgc2xpY2UnKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRqc29uKG1zZywgcmVzKTtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXMoZXJyLCByYXcpe1xuXHRcdFx0XHRcdFx0aWYoZXJyKXsgcmV0dXJuIH0gLy8gVE9ETzogSGFuZGxlISFcblx0XHRcdFx0XHRcdG1ldGEucmF3ID0gcmF3OyAvL2lmKG1ldGEgJiYgKHJhd3x8JycpLmxlbmd0aCA8ICg5OTkgKiA5OSkpeyBtZXRhLnJhdyA9IHJhdyB9IC8vIEhOUEVSRjogSWYgc3RyaW5nIHRvbyBiaWcsIGRvbid0IGtlZXAgaW4gbWVtb3J5LlxuXHRcdFx0XHRcdFx0bWVzaC5zYXkobXNnLCBwZWVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0oKSk7XG5cblx0XHRcdGZ1bmN0aW9uIGZsdXNoKHBlZXIpe1xuXHRcdFx0XHR2YXIgdG1wID0gcGVlci5iYXRjaCwgdCA9ICdzdHJpbmcnID09IHR5cGVvZiB0bXAsIGw7XG5cdFx0XHRcdGlmKHQpeyB0bXAgKz0gJ10nIH0vLyBUT0RPOiBQcmV2ZW50IGRvdWJsZSBKU09OIVxuXHRcdFx0XHRwZWVyLmJhdGNoID0gcGVlci50YWlsID0gbnVsbDtcblx0XHRcdFx0aWYoIXRtcCl7IHJldHVybiB9XG5cdFx0XHRcdGlmKHQ/IDMgPiB0bXAubGVuZ3RoIDogIXRtcC5sZW5ndGgpeyByZXR1cm4gfSAvLyBUT0RPOiBeXG5cdFx0XHRcdGlmKCF0KXt0cnl7dG1wID0gKDEgPT09IHRtcC5sZW5ndGg/IHRtcFswXSA6IEpTT04uc3RyaW5naWZ5KHRtcCkpO1xuXHRcdFx0XHR9Y2F0Y2goZSl7cmV0dXJuIG9wdC5sb2coJ0RBTSBKU09OIHN0cmluZ2lmeSBlcnJvcicsIGUpfX1cblx0XHRcdFx0aWYoIXRtcCl7IHJldHVybiB9XG5cdFx0XHRcdHNlbmQodG1wLCBwZWVyKTtcblx0XHRcdH1cblx0XHRcdC8vIGZvciBub3cgLSBmaW5kIGJldHRlciBwbGFjZSBsYXRlci5cblx0XHRcdGZ1bmN0aW9uIHNlbmQocmF3LCBwZWVyKXsgdHJ5e1xuXHRcdFx0XHR2YXIgd2lyZSA9IHBlZXIud2lyZTtcblx0XHRcdFx0aWYocGVlci5zYXkpe1xuXHRcdFx0XHRcdHBlZXIuc2F5KHJhdyk7XG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRpZih3aXJlLnNlbmQpe1xuXHRcdFx0XHRcdHdpcmUuc2VuZChyYXcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1lc2guc2F5LmQgKz0gcmF3Lmxlbmd0aHx8MDsgKyttZXNoLnNheS5jOyAvLyBTVEFUUyFcblx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0KHBlZXIucXVldWUgPSBwZWVyLnF1ZXVlIHx8IFtdKS5wdXNoKHJhdyk7XG5cdFx0XHR9fVxuXG5cdFx0XHRtZXNoLm5lYXIgPSAwO1xuXHRcdFx0bWVzaC5oaSA9IGZ1bmN0aW9uKHBlZXIpe1xuXHRcdFx0XHR2YXIgd2lyZSA9IHBlZXIud2lyZSwgdG1wO1xuXHRcdFx0XHRpZighd2lyZSl7IG1lc2gud2lyZSgocGVlci5sZW5ndGggJiYge3VybDogcGVlciwgaWQ6IHBlZXJ9KSB8fCBwZWVyKTsgcmV0dXJuIH1cblx0XHRcdFx0aWYocGVlci5pZCl7XG5cdFx0XHRcdFx0b3B0LnBlZXJzW3BlZXIudXJsIHx8IHBlZXIuaWRdID0gcGVlcjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bXAgPSBwZWVyLmlkID0gcGVlci5pZCB8fCBwZWVyLnVybCB8fCBTdHJpbmcucmFuZG9tKDkpO1xuXHRcdFx0XHRcdG1lc2guc2F5KHtkYW06ICc/JywgcGlkOiByb290Lm9wdC5waWR9LCBvcHQucGVlcnNbdG1wXSA9IHBlZXIpO1xuXHRcdFx0XHRcdGRlbGV0ZSBkdXAuc1twZWVyLmxhc3RdOyAvLyBJTVBPUlRBTlQ6IHNlZSBodHRwczovL2d1bi5lY28vZG9jcy9EQU0jc2VsZlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFwZWVyLm1ldCl7XG5cdFx0XHRcdFx0bWVzaC5uZWFyKys7XG5cdFx0XHRcdFx0cGVlci5tZXQgPSArKG5ldyBEYXRlKTtcblx0XHRcdFx0XHRyb290Lm9uKCdoaScsIHBlZXIpXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQHJvZ293c2tpIEkgbmVlZCB0aGlzIGhlcmUgYnkgZGVmYXVsdCBmb3Igbm93IHRvIGZpeCBnbzFkZmlzaCdzIGJ1Z1xuXHRcdFx0XHR0bXAgPSBwZWVyLnF1ZXVlOyBwZWVyLnF1ZXVlID0gW107XG5cdFx0XHRcdHNldFRpbWVvdXQuZWFjaCh0bXB8fFtdLGZ1bmN0aW9uKG1zZyl7XG5cdFx0XHRcdFx0c2VuZChtc2csIHBlZXIpO1xuXHRcdFx0XHR9LDAsOSk7XG5cdFx0XHRcdC8vVHlwZS5vYmoubmF0aXZlICYmIFR5cGUub2JqLm5hdGl2ZSgpOyAvLyBkaXJ0eSBwbGFjZSB0byBjaGVjayBpZiBvdGhlciBKUyBwb2xsdXRlZC5cblx0XHRcdH1cblx0XHRcdG1lc2guYnllID0gZnVuY3Rpb24ocGVlcil7XG5cdFx0XHRcdHBlZXIubWV0ICYmIC0tbWVzaC5uZWFyO1xuXHRcdFx0XHRkZWxldGUgcGVlci5tZXQ7XG5cdFx0XHRcdHJvb3Qub24oJ2J5ZScsIHBlZXIpO1xuXHRcdFx0XHR2YXIgdG1wID0gKyhuZXcgRGF0ZSk7IHRtcCA9ICh0bXAgLSAocGVlci5tZXR8fHRtcCkpO1xuXHRcdFx0XHRtZXNoLmJ5ZS50aW1lID0gKChtZXNoLmJ5ZS50aW1lIHx8IHRtcCkgKyB0bXApIC8gMjtcblx0XHRcdH1cblx0XHRcdG1lc2guaGVhclsnISddID0gZnVuY3Rpb24obXNnLCBwZWVyKXsgb3B0LmxvZygnRXJyb3I6JywgbXNnLmVycikgfVxuXHRcdFx0bWVzaC5oZWFyWyc/J10gPSBmdW5jdGlvbihtc2csIHBlZXIpe1xuXHRcdFx0XHRpZihtc2cucGlkKXtcblx0XHRcdFx0XHRpZighcGVlci5waWQpeyBwZWVyLnBpZCA9IG1zZy5waWQgfVxuXHRcdFx0XHRcdGlmKG1zZ1snQCddKXsgcmV0dXJuIH1cblx0XHRcdFx0fVxuXHRcdFx0XHRtZXNoLnNheSh7ZGFtOiAnPycsIHBpZDogb3B0LnBpZCwgJ0AnOiBtc2dbJyMnXX0sIHBlZXIpO1xuXHRcdFx0XHRkZWxldGUgZHVwLnNbcGVlci5sYXN0XTsgLy8gSU1QT1JUQU5UOiBzZWUgaHR0cHM6Ly9ndW4uZWNvL2RvY3MvREFNI3NlbGZcblx0XHRcdH1cblx0XHRcdG1lc2guaGVhclsnbW9iJ10gPSBmdW5jdGlvbihtc2csIHBlZXIpeyAvLyBOT1RFOiBBWEUgd2lsbCBvdmVybG9hZCB0aGlzIHdpdGggYmV0dGVyIGxvZ2ljLlxuXHRcdFx0XHRpZighbXNnLnBlZXJzKXsgcmV0dXJuIH1cblx0XHRcdFx0dmFyIHBlZXJzID0gT2JqZWN0LmtleXMobXNnLnBlZXJzKSwgb25lID0gcGVlcnNbKE1hdGgucmFuZG9tKCkqcGVlcnMubGVuZ3RoKSA+PiAwXTtcblx0XHRcdFx0aWYoIW9uZSl7IHJldHVybiB9XG5cdFx0XHRcdG1lc2guYnllKHBlZXIpO1xuXHRcdFx0XHRtZXNoLmhpKG9uZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJvb3Qub24oJ2NyZWF0ZScsIGZ1bmN0aW9uKHJvb3Qpe1xuXHRcdFx0XHRyb290Lm9wdC5waWQgPSByb290Lm9wdC5waWQgfHwgU3RyaW5nLnJhbmRvbSg5KTtcblx0XHRcdFx0dGhpcy50by5uZXh0KHJvb3QpO1xuXHRcdFx0XHRyb290Lm9uKCdvdXQnLCBtZXNoLnNheSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cm9vdC5vbignYnllJywgZnVuY3Rpb24ocGVlciwgdG1wKXtcblx0XHRcdFx0cGVlciA9IG9wdC5wZWVyc1twZWVyLmlkIHx8IHBlZXJdIHx8IHBlZXI7XG5cdFx0XHRcdHRoaXMudG8ubmV4dChwZWVyKTtcblx0XHRcdFx0cGVlci5ieWU/IHBlZXIuYnllKCkgOiAodG1wID0gcGVlci53aXJlKSAmJiB0bXAuY2xvc2UgJiYgdG1wLmNsb3NlKCk7XG5cdFx0XHRcdGRlbGV0ZSBvcHQucGVlcnNbcGVlci5pZF07XG5cdFx0XHRcdHBlZXIud2lyZSA9IG51bGw7XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIGdldHMgPSB7fTtcblx0XHRcdHJvb3Qub24oJ2J5ZScsIGZ1bmN0aW9uKHBlZXIsIHRtcCl7IHRoaXMudG8ubmV4dChwZWVyKTtcblx0XHRcdFx0aWYodG1wID0gY29uc29sZS5TVEFUKXsgdG1wLnBlZXJzID0gbWVzaC5uZWFyOyB9XG5cdFx0XHRcdGlmKCEodG1wID0gcGVlci51cmwpKXsgcmV0dXJuIH0gZ2V0c1t0bXBdID0gdHJ1ZTtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpeyBkZWxldGUgZ2V0c1t0bXBdIH0sb3B0LmxhY2sgfHwgOTAwMCk7XG5cdFx0XHR9KTtcblx0XHRcdHJvb3Qub24oJ2hpJywgZnVuY3Rpb24ocGVlciwgdG1wKXsgdGhpcy50by5uZXh0KHBlZXIpO1xuXHRcdFx0XHRpZih0bXAgPSBjb25zb2xlLlNUQVQpeyB0bXAucGVlcnMgPSBtZXNoLm5lYXIgfVxuXHRcdFx0XHRpZihvcHQuc3VwZXIpeyByZXR1cm4gfSAvLyB0ZW1wb3JhcnkgKD8pIHVudGlsIHdlIGhhdmUgYmV0dGVyIGZpeC9zb2x1dGlvbj9cblx0XHRcdFx0dmFyIHNvdWxzID0gT2JqZWN0LmtleXMocm9vdC5uZXh0fHwnJyk7IC8vIFRPRE86IC5rZXlzKCBpcyBzbG93XG5cdFx0XHRcdGlmKHNvdWxzLmxlbmd0aCA+IDk5OTkgJiYgIWNvbnNvbGUuU1VCUyl7IGNvbnNvbGUubG9nKGNvbnNvbGUuU1VCUyA9IFwiV2FybmluZzogWW91IGhhdmUgbW9yZSB0aGFuIDEwSyBsaXZlIEdFVHMsIHdoaWNoIG1pZ2h0IHVzZSBtb3JlIGJhbmR3aWR0aCB0aGFuIHlvdXIgc2NyZWVuIGNhbiBzaG93IC0gY29uc2lkZXIgYC5vZmYoKWAuXCIpIH1cblx0XHRcdFx0c2V0VGltZW91dC5lYWNoKHNvdWxzLCBmdW5jdGlvbihzb3VsKXsgdmFyIG5vZGUgPSByb290Lm5leHRbc291bF07XG5cdFx0XHRcdFx0aWYob3B0LnN1cGVyIHx8IChub2RlLmFza3x8JycpWycnXSl7IG1lc2guc2F5KHtnZXQ6IHsnIyc6IHNvdWx9fSwgcGVlcik7IHJldHVybiB9XG5cdFx0XHRcdFx0c2V0VGltZW91dC5lYWNoKE9iamVjdC5rZXlzKG5vZGUuYXNrfHwnJyksIGZ1bmN0aW9uKGtleSl7IGlmKCFrZXkpeyByZXR1cm4gfVxuXHRcdFx0XHRcdFx0Ly8gaXMgdGhlIGxhY2sgb2YgIyMgYSAhb25pb24gaGludD9cblx0XHRcdFx0XHRcdG1lc2guc2F5KHsnIyMnOiBTdHJpbmcuaGFzaCgocm9vdC5ncmFwaFtzb3VsXXx8JycpW2tleV0pLCBnZXQ6IHsnIyc6IHNvdWwsICcuJzoga2V5fX0sIHBlZXIpO1xuXHRcdFx0XHRcdFx0Ly8gVE9ETzogU3dpdGNoIHRoaXMgc28gQm9vayBjb3VsZCByb3V0ZT9cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gbWVzaDtcblx0XHR9XG5cdCAgdmFyIGVtcHR5ID0ge30sIG9rID0gdHJ1ZSwgdTtcblxuXHQgIHRyeXsgbW9kdWxlLmV4cG9ydHMgPSBNZXNoIH1jYXRjaChlKXt9XG5cblx0fSkoVVNFLCAnLi9tZXNoJyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdHZhciBHdW4gPSBVU0UoJy4vaW5kZXgnKTtcblx0XHRHdW4uTWVzaCA9IFVTRSgnLi9tZXNoJyk7XG5cblx0XHQvLyBUT0RPOiByZXN5bmMgdXBvbiByZWNvbm5lY3Qgb25saW5lL29mZmxpbmVcblx0XHQvL3dpbmRvdy5vbm9ubGluZSA9IHdpbmRvdy5vbm9mZmxpbmUgPSBmdW5jdGlvbigpeyBjb25zb2xlLmxvZygnb25saW5lPycsIG5hdmlnYXRvci5vbkxpbmUpIH1cblxuXHRcdEd1bi5vbignb3B0JywgZnVuY3Rpb24ocm9vdCl7XG5cdFx0XHR0aGlzLnRvLm5leHQocm9vdCk7XG5cdFx0XHRpZihyb290Lm9uY2UpeyByZXR1cm4gfVxuXHRcdFx0dmFyIG9wdCA9IHJvb3Qub3B0O1xuXHRcdFx0aWYoZmFsc2UgPT09IG9wdC5XZWJTb2NrZXQpeyByZXR1cm4gfVxuXG5cdFx0XHR2YXIgZW52ID0gR3VuLndpbmRvdyB8fCB7fTtcblx0XHRcdHZhciB3ZWJzb2NrZXQgPSBvcHQuV2ViU29ja2V0IHx8IGVudi5XZWJTb2NrZXQgfHwgZW52LndlYmtpdFdlYlNvY2tldCB8fCBlbnYubW96V2ViU29ja2V0O1xuXHRcdFx0aWYoIXdlYnNvY2tldCl7IHJldHVybiB9XG5cdFx0XHRvcHQuV2ViU29ja2V0ID0gd2Vic29ja2V0O1xuXG5cdFx0XHR2YXIgbWVzaCA9IG9wdC5tZXNoID0gb3B0Lm1lc2ggfHwgR3VuLk1lc2gocm9vdCk7XG5cblx0XHRcdHZhciB3aXJlID0gbWVzaC53aXJlIHx8IG9wdC53aXJlO1xuXHRcdFx0bWVzaC53aXJlID0gb3B0LndpcmUgPSBvcGVuO1xuXHRcdFx0ZnVuY3Rpb24gb3BlbihwZWVyKXsgdHJ5e1xuXHRcdFx0XHRpZighcGVlciB8fCAhcGVlci51cmwpeyByZXR1cm4gd2lyZSAmJiB3aXJlKHBlZXIpIH1cblx0XHRcdFx0dmFyIHVybCA9IHBlZXIudXJsLnJlcGxhY2UoL15odHRwLywgJ3dzJyk7XG5cdFx0XHRcdHZhciB3aXJlID0gcGVlci53aXJlID0gbmV3IG9wdC5XZWJTb2NrZXQodXJsKTtcblx0XHRcdFx0d2lyZS5vbmNsb3NlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRyZWNvbm5lY3QocGVlcik7XG5cdFx0XHRcdFx0b3B0Lm1lc2guYnllKHBlZXIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR3aXJlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuXHRcdFx0XHRcdHJlY29ubmVjdChwZWVyKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0d2lyZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdG9wdC5tZXNoLmhpKHBlZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdpcmUub25tZXNzYWdlID0gZnVuY3Rpb24obXNnKXtcblx0XHRcdFx0XHRpZighbXNnKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRvcHQubWVzaC5oZWFyKG1zZy5kYXRhIHx8IG1zZywgcGVlcik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB3aXJlO1xuXHRcdFx0fWNhdGNoKGUpeyBvcHQubWVzaC5ieWUocGVlcikgfX1cblxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpeyAhb3B0LnN1cGVyICYmIHJvb3Qub24oJ291dCcsIHtkYW06J2hpJ30pIH0sMSk7IC8vIGl0IGNhbiB0YWtlIGEgd2hpbGUgdG8gb3BlbiBhIHNvY2tldCwgc28gbWF5YmUgbm8gbG9uZ2VyIGxhenkgbG9hZCBmb3IgcGVyZiByZWFzb25zP1xuXG5cdFx0XHR2YXIgd2FpdCA9IDIgKiA5OTk7XG5cdFx0XHRmdW5jdGlvbiByZWNvbm5lY3QocGVlcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dChwZWVyLmRlZmVyKTtcblx0XHRcdFx0aWYoIW9wdC5wZWVyc1twZWVyLnVybF0peyByZXR1cm4gfVxuXHRcdFx0XHRpZihkb2MgJiYgcGVlci5yZXRyeSA8PSAwKXsgcmV0dXJuIH1cblx0XHRcdFx0cGVlci5yZXRyeSA9IChwZWVyLnJldHJ5IHx8IG9wdC5yZXRyeSsxIHx8IDYwKSAtICgoLXBlZXIudHJpZWQgKyAocGVlci50cmllZCA9ICtuZXcgRGF0ZSkgPCB3YWl0KjQpPzE6MCk7XG5cdFx0XHRcdHBlZXIuZGVmZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRvKCl7XG5cdFx0XHRcdFx0aWYoZG9jICYmIGRvYy5oaWRkZW4peyByZXR1cm4gc2V0VGltZW91dCh0byx3YWl0KSB9XG5cdFx0XHRcdFx0b3BlbihwZWVyKTtcblx0XHRcdFx0fSwgd2FpdCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZG9jID0gKCcnK3UgIT09IHR5cGVvZiBkb2N1bWVudCkgJiYgZG9jdW1lbnQ7XG5cdFx0fSk7XG5cdFx0dmFyIG5vb3AgPSBmdW5jdGlvbigpe30sIHU7XG5cdH0pKFVTRSwgJy4vd2Vic29ja2V0Jyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdGlmKHR5cGVvZiBHdW4gPT09ICd1bmRlZmluZWQnKXsgcmV0dXJuIH1cblxuXHRcdHZhciBub29wID0gZnVuY3Rpb24oKXt9LCBzdG9yZSwgdTtcblx0XHR0cnl7c3RvcmUgPSAoR3VuLndpbmRvd3x8bm9vcCkubG9jYWxTdG9yYWdlfWNhdGNoKGUpe31cblx0XHRpZighc3RvcmUpe1xuXHRcdFx0R3VuLmxvZyhcIldhcm5pbmc6IE5vIGxvY2FsU3RvcmFnZSBleGlzdHMgdG8gcGVyc2lzdCBkYXRhIHRvIVwiKTtcblx0XHRcdHN0b3JlID0ge3NldEl0ZW06IGZ1bmN0aW9uKGssdil7dGhpc1trXT12fSwgcmVtb3ZlSXRlbTogZnVuY3Rpb24oayl7ZGVsZXRlIHRoaXNba119LCBnZXRJdGVtOiBmdW5jdGlvbihrKXtyZXR1cm4gdGhpc1trXX19O1xuXHRcdH1cblxuXHRcdHZhciBwYXJzZSA9IEpTT04ucGFyc2VBc3luYyB8fCBmdW5jdGlvbih0LGNiLHIpeyB2YXIgdTsgdHJ5eyBjYih1LCBKU09OLnBhcnNlKHQscikpIH1jYXRjaChlKXsgY2IoZSkgfSB9XG5cdFx0dmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeUFzeW5jIHx8IGZ1bmN0aW9uKHYsY2IscixzKXsgdmFyIHU7IHRyeXsgY2IodSwgSlNPTi5zdHJpbmdpZnkodixyLHMpKSB9Y2F0Y2goZSl7IGNiKGUpIH0gfVxuXG5cdFx0R3VuLm9uKCdjcmVhdGUnLCBmdW5jdGlvbiBsZyhyb290KXtcblx0XHRcdHRoaXMudG8ubmV4dChyb290KTtcblx0XHRcdHZhciBvcHQgPSByb290Lm9wdCwgZ3JhcGggPSByb290LmdyYXBoLCBhY2tzID0gW10sIGRpc2ssIHRvLCBzaXplLCBzdG9wO1xuXHRcdFx0aWYoZmFsc2UgPT09IG9wdC5sb2NhbFN0b3JhZ2UpeyByZXR1cm4gfVxuXHRcdFx0b3B0LnByZWZpeCA9IG9wdC5maWxlIHx8ICdndW4vJztcblx0XHRcdHRyeXsgZGlzayA9IGxnW29wdC5wcmVmaXhdID0gbGdbb3B0LnByZWZpeF0gfHwgSlNPTi5wYXJzZShzaXplID0gc3RvcmUuZ2V0SXRlbShvcHQucHJlZml4KSkgfHwge307IC8vIFRPRE86IFBlcmYhIFRoaXMgd2lsbCBibG9jaywgc2hvdWxkIHdlIGNhcmUsIHNpbmNlIGxpbWl0ZWQgdG8gNU1CIGFueXdheXM/XG5cdFx0XHR9Y2F0Y2goZSl7IGRpc2sgPSBsZ1tvcHQucHJlZml4XSA9IHt9OyB9XG5cdFx0XHRzaXplID0gKHNpemV8fCcnKS5sZW5ndGg7XG5cblx0XHRcdHJvb3Qub24oJ2dldCcsIGZ1bmN0aW9uKG1zZyl7XG5cdFx0XHRcdHRoaXMudG8ubmV4dChtc2cpO1xuXHRcdFx0XHR2YXIgbGV4ID0gbXNnLmdldCwgc291bCwgZGF0YSwgdG1wLCB1O1xuXHRcdFx0XHRpZighbGV4IHx8ICEoc291bCA9IGxleFsnIyddKSl7IHJldHVybiB9XG5cdFx0XHRcdGRhdGEgPSBkaXNrW3NvdWxdIHx8IHU7XG5cdFx0XHRcdGlmKGRhdGEgJiYgKHRtcCA9IGxleFsnLiddKSAmJiAhT2JqZWN0LnBsYWluKHRtcCkpeyAvLyBwbHVjayFcblx0XHRcdFx0XHRkYXRhID0gR3VuLnN0YXRlLmlmeSh7fSwgdG1wLCBHdW4uc3RhdGUuaXMoZGF0YSwgdG1wKSwgZGF0YVt0bXBdLCBzb3VsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2lmKGRhdGEpeyAodG1wID0ge30pW3NvdWxdID0gZGF0YSB9IC8vIGJhY2sgaW50byBhIGdyYXBoLlxuXHRcdFx0XHQvL3NldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0R3VuLm9uLmdldC5hY2sobXNnLCBkYXRhKTsgLy9yb290Lm9uKCdpbicsIHsnQCc6IG1zZ1snIyddLCBwdXQ6IHRtcCwgbFM6MX0pOy8vIHx8IHJvb3QuJH0pO1xuXHRcdFx0XHQvL30sIE1hdGgucmFuZG9tKCkgKiAxMCk7IC8vIEZPUiBURVNUSU5HIFBVUlBPU0VTIVxuXHRcdFx0fSk7XG5cblx0XHRcdHJvb3Qub24oJ3B1dCcsIGZ1bmN0aW9uKG1zZyl7XG5cdFx0XHRcdHRoaXMudG8ubmV4dChtc2cpOyAvLyByZW1lbWJlciB0byBjYWxsIG5leHQgbWlkZGxld2FyZSBhZGFwdGVyXG5cdFx0XHRcdHZhciBwdXQgPSBtc2cucHV0LCBzb3VsID0gcHV0WycjJ10sIGtleSA9IHB1dFsnLiddLCBpZCA9IG1zZ1snIyddLCBvayA9IG1zZy5va3x8JycsIHRtcDsgLy8gcHVsbCBkYXRhIG9mZiB3aXJlIGVudmVsb3BlXG5cdFx0XHRcdGRpc2tbc291bF0gPSBHdW4uc3RhdGUuaWZ5KGRpc2tbc291bF0sIGtleSwgcHV0Wyc+J10sIHB1dFsnOiddLCBzb3VsKTsgLy8gbWVyZ2UgaW50byBkaXNrIG9iamVjdFxuXHRcdFx0XHRpZihzdG9wICYmIHNpemUgPiAoNDk5OTg4MCkpeyByb290Lm9uKCdpbicsIHsnQCc6IGlkLCBlcnI6IFwibG9jYWxTdG9yYWdlIG1heCFcIn0pOyByZXR1cm47IH1cblx0XHRcdFx0Ly9pZighbXNnWydAJ10peyBhY2tzLnB1c2goaWQpIH0gLy8gdGhlbiBhY2sgYW55IG5vbi1hY2sgd3JpdGUuIC8vIFRPRE86IHVzZSBiYXRjaCBpZC5cblx0XHRcdFx0aWYoIW1zZ1snQCddICYmICghbXNnLl8udmlhIHx8IE1hdGgucmFuZG9tKCkgPCAob2tbJ0AnXSAvIG9rWycvJ10pKSl7IGFja3MucHVzaChpZCkgfSAvLyB0aGVuIGFjayBhbnkgbm9uLWFjayB3cml0ZS4gLy8gVE9ETzogdXNlIGJhdGNoIGlkLlxuXHRcdFx0XHRpZih0byl7IHJldHVybiB9XG5cdFx0XHRcdHRvID0gc2V0VGltZW91dChmbHVzaCwgOSsoc2l6ZSAvIDMzMykpOyAvLyAwLjFNQiA9IDAuM3MsIDVNQiA9IDE1cyBcblx0XHRcdH0pO1xuXHRcdFx0ZnVuY3Rpb24gZmx1c2goKXtcblx0XHRcdFx0aWYoIWFja3MubGVuZ3RoICYmICgoc2V0VGltZW91dC50dXJufHwnJykuc3x8JycpLmxlbmd0aCl7IHNldFRpbWVvdXQoZmx1c2gsOTkpOyByZXR1cm47IH0gLy8gZGVmZXIgaWYgXCJidXN5XCIgJiYgbm8gc2F2ZXMuXG5cdFx0XHRcdHZhciBlcnIsIGFjayA9IGFja3M7IGNsZWFyVGltZW91dCh0byk7IHRvID0gZmFsc2U7IGFja3MgPSBbXTtcblx0XHRcdFx0anNvbihkaXNrLCBmdW5jdGlvbihlcnIsIHRtcCl7XG5cdFx0XHRcdFx0dHJ5eyFlcnIgJiYgc3RvcmUuc2V0SXRlbShvcHQucHJlZml4LCB0bXApO1xuXHRcdFx0XHRcdH1jYXRjaChlKXsgZXJyID0gc3RvcCA9IGUgfHwgXCJsb2NhbFN0b3JhZ2UgZmFpbHVyZVwiIH1cblx0XHRcdFx0XHRpZihlcnIpe1xuXHRcdFx0XHRcdFx0R3VuLmxvZyhlcnIgKyBcIiBDb25zaWRlciB1c2luZyBHVU4ncyBJbmRleGVkREIgcGx1Z2luIGZvciBSQUQgZm9yIG1vcmUgc3RvcmFnZSBzcGFjZSwgaHR0cHM6Ly9ndW4uZWNvL2RvY3MvUkFEI2luc3RhbGxcIik7XG5cdFx0XHRcdFx0XHRyb290Lm9uKCdsb2NhbFN0b3JhZ2U6ZXJyb3InLCB7ZXJyOiBlcnIsIGdldDogb3B0LnByZWZpeCwgcHV0OiBkaXNrfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNpemUgPSB0bXAubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly9pZighZXJyICYmICFPYmplY3QuZW1wdHkob3B0LnBlZXJzKSl7IHJldHVybiB9IC8vIG9ubHkgYWNrIGlmIHRoZXJlIGFyZSBubyBwZWVycy4gLy8gU3dpdGNoIHRoaXMgdG8gcHJvYmFiaWxpc3RpYyBtb2RlXG5cdFx0XHRcdFx0c2V0VGltZW91dC5lYWNoKGFjaywgZnVuY3Rpb24oaWQpe1xuXHRcdFx0XHRcdFx0cm9vdC5vbignaW4nLCB7J0AnOiBpZCwgZXJyOiBlcnIsIG9rOiAwfSk7IC8vIGxvY2FsU3RvcmFnZSBpc24ndCByZWxpYWJsZSwgc28gbWFrZSBpdHMgYG9rYCBjb2RlIGJlIGEgbG93IG51bWJlci5cblx0XHRcdFx0XHR9LDAsOTkpO1xuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdFxuXHRcdH0pO1xuXHR9KShVU0UsICcuL2xvY2FsU3RvcmFnZScpO1xuXG59KCkpO1xuXG4vKiBCRUxPVyBJUyBURU1QT1JBUlkgRk9SIE9MRCBJTlRFUk5BTCBDT01QQVRJQklMSVRZLCBUSEVZIEFSRSBJTU1FRElBVEVMWSBERVBSRUNBVEVEIEFORCBXSUxMIEJFIFJFTU9WRUQgSU4gTkVYVCBWRVJTSU9OICovXG47KGZ1bmN0aW9uKCl7XG5cdHZhciB1O1xuXHRpZignJyt1ID09IHR5cGVvZiBHdW4peyByZXR1cm4gfVxuXHR2YXIgREVQID0gZnVuY3Rpb24obil7IGNvbnNvbGUud2FybihcIldhcm5pbmchIERlcHJlY2F0ZWQgaW50ZXJuYWwgdXRpbGl0eSB3aWxsIGJyZWFrIGluIG5leHQgdmVyc2lvbjpcIiwgbikgfVxuXHQvLyBHZW5lcmljIGphdmFzY3JpcHQgdXRpbGl0aWVzLlxuXHR2YXIgVHlwZSA9IEd1bjtcblx0Ly9UeXBlLmZucyA9IFR5cGUuZm4gPSB7aXM6IGZ1bmN0aW9uKGZuKXsgcmV0dXJuICghIWZuICYmIGZuIGluc3RhbmNlb2YgRnVuY3Rpb24pIH19XG5cdFR5cGUuZm4gPSBUeXBlLmZuIHx8IHtpczogZnVuY3Rpb24oZm4peyBERVAoJ2ZuJyk7IHJldHVybiAoISFmbiAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBmbikgfX1cblx0VHlwZS5iaSA9IFR5cGUuYmkgfHwge2lzOiBmdW5jdGlvbihiKXsgREVQKCdiaScpO3JldHVybiAoYiBpbnN0YW5jZW9mIEJvb2xlYW4gfHwgdHlwZW9mIGIgPT0gJ2Jvb2xlYW4nKSB9fVxuXHRUeXBlLm51bSA9IFR5cGUubnVtIHx8IHtpczogZnVuY3Rpb24obil7IERFUCgnbnVtJyk7IHJldHVybiAhbGlzdF9pcyhuKSAmJiAoKG4gLSBwYXJzZUZsb2F0KG4pICsgMSkgPj0gMCB8fCBJbmZpbml0eSA9PT0gbiB8fCAtSW5maW5pdHkgPT09IG4pIH19XG5cdFR5cGUudGV4dCA9IFR5cGUudGV4dCB8fCB7aXM6IGZ1bmN0aW9uKHQpeyBERVAoJ3RleHQnKTsgcmV0dXJuICh0eXBlb2YgdCA9PSAnc3RyaW5nJykgfX1cblx0VHlwZS50ZXh0LmlmeSA9IFR5cGUudGV4dC5pZnkgfHwgZnVuY3Rpb24odCl7IERFUCgndGV4dC5pZnknKTtcblx0XHRpZihUeXBlLnRleHQuaXModCkpeyByZXR1cm4gdCB9XG5cdFx0aWYodHlwZW9mIEpTT04gIT09IFwidW5kZWZpbmVkXCIpeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodCkgfVxuXHRcdHJldHVybiAodCAmJiB0LnRvU3RyaW5nKT8gdC50b1N0cmluZygpIDogdDtcblx0fVxuXHRUeXBlLnRleHQucmFuZG9tID0gVHlwZS50ZXh0LnJhbmRvbSB8fCBmdW5jdGlvbihsLCBjKXsgREVQKCd0ZXh0LnJhbmRvbScpO1xuXHRcdHZhciBzID0gJyc7XG5cdFx0bCA9IGwgfHwgMjQ7IC8vIHlvdSBhcmUgbm90IGdvaW5nIHRvIG1ha2UgYSAwIGxlbmd0aCByYW5kb20gbnVtYmVyLCBzbyBubyBuZWVkIHRvIGNoZWNrIHR5cGVcblx0XHRjID0gYyB8fCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XG5cdFx0d2hpbGUobCA+IDApeyBzICs9IGMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGMubGVuZ3RoKSk7IGwtLSB9XG5cdFx0cmV0dXJuIHM7XG5cdH1cblx0VHlwZS50ZXh0Lm1hdGNoID0gVHlwZS50ZXh0Lm1hdGNoIHx8IGZ1bmN0aW9uKHQsIG8peyB2YXIgdG1wLCB1OyBERVAoJ3RleHQubWF0Y2gnKTtcblx0XHRpZignc3RyaW5nJyAhPT0gdHlwZW9mIHQpeyByZXR1cm4gZmFsc2UgfVxuXHRcdGlmKCdzdHJpbmcnID09IHR5cGVvZiBvKXsgbyA9IHsnPSc6IG99IH1cblx0XHRvID0gbyB8fCB7fTtcblx0XHR0bXAgPSAob1snPSddIHx8IG9bJyonXSB8fCBvWyc+J10gfHwgb1snPCddKTtcblx0XHRpZih0ID09PSB0bXApeyByZXR1cm4gdHJ1ZSB9XG5cdFx0aWYodSAhPT0gb1snPSddKXsgcmV0dXJuIGZhbHNlIH1cblx0XHR0bXAgPSAob1snKiddIHx8IG9bJz4nXSB8fCBvWyc8J10pO1xuXHRcdGlmKHQuc2xpY2UoMCwgKHRtcHx8JycpLmxlbmd0aCkgPT09IHRtcCl7IHJldHVybiB0cnVlIH1cblx0XHRpZih1ICE9PSBvWycqJ10peyByZXR1cm4gZmFsc2UgfVxuXHRcdGlmKHUgIT09IG9bJz4nXSAmJiB1ICE9PSBvWyc8J10pe1xuXHRcdFx0cmV0dXJuICh0ID49IG9bJz4nXSAmJiB0IDw9IG9bJzwnXSk/IHRydWUgOiBmYWxzZTtcblx0XHR9XG5cdFx0aWYodSAhPT0gb1snPiddICYmIHQgPj0gb1snPiddKXsgcmV0dXJuIHRydWUgfVxuXHRcdGlmKHUgIT09IG9bJzwnXSAmJiB0IDw9IG9bJzwnXSl7IHJldHVybiB0cnVlIH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0VHlwZS50ZXh0Lmhhc2ggPSBUeXBlLnRleHQuaGFzaCB8fCBmdW5jdGlvbihzLCBjKXsgLy8gdmlhIFNPXG5cdFx0REVQKCd0ZXh0Lmhhc2gnKTtcblx0XHRpZih0eXBlb2YgcyAhPT0gJ3N0cmluZycpeyByZXR1cm4gfVxuXHQgIGMgPSBjIHx8IDA7XG5cdCAgaWYoIXMubGVuZ3RoKXsgcmV0dXJuIGMgfVxuXHQgIGZvcih2YXIgaT0wLGw9cy5sZW5ndGgsbjsgaTxsOyArK2kpe1xuXHQgICAgbiA9IHMuY2hhckNvZGVBdChpKTtcblx0ICAgIGMgPSAoKGM8PDUpLWMpK247XG5cdCAgICBjIHw9IDA7XG5cdCAgfVxuXHQgIHJldHVybiBjO1xuXHR9XG5cdFR5cGUubGlzdCA9IFR5cGUubGlzdCB8fCB7aXM6IGZ1bmN0aW9uKGwpeyBERVAoJ2xpc3QnKTsgcmV0dXJuIChsIGluc3RhbmNlb2YgQXJyYXkpIH19XG5cdFR5cGUubGlzdC5zbGl0ID0gVHlwZS5saXN0LnNsaXQgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRUeXBlLmxpc3Quc29ydCA9IFR5cGUubGlzdC5zb3J0IHx8IGZ1bmN0aW9uKGspeyAvLyBjcmVhdGVzIGEgbmV3IHNvcnQgZnVuY3Rpb24gYmFzZWQgb2ZmIHNvbWUga2V5XG5cdFx0REVQKCdsaXN0LnNvcnQnKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oQSxCKXtcblx0XHRcdGlmKCFBIHx8ICFCKXsgcmV0dXJuIDAgfSBBID0gQVtrXTsgQiA9IEJba107XG5cdFx0XHRpZihBIDwgQil7IHJldHVybiAtMSB9ZWxzZSBpZihBID4gQil7IHJldHVybiAxIH1cblx0XHRcdGVsc2UgeyByZXR1cm4gMCB9XG5cdFx0fVxuXHR9XG5cdFR5cGUubGlzdC5tYXAgPSBUeXBlLmxpc3QubWFwIHx8IGZ1bmN0aW9uKGwsIGMsIF8peyBERVAoJ2xpc3QubWFwJyk7IHJldHVybiBvYmpfbWFwKGwsIGMsIF8pIH1cblx0VHlwZS5saXN0LmluZGV4ID0gMTsgLy8gY2hhbmdlIHRoaXMgdG8gMCBpZiB5b3Ugd2FudCBub24tbG9naWNhbCwgbm9uLW1hdGhlbWF0aWNhbCwgbm9uLW1hdHJpeCwgbm9uLWNvbnZlbmllbnQgYXJyYXkgbm90YXRpb25cblx0VHlwZS5vYmogPSBUeXBlLmJvaiB8fCB7aXM6IGZ1bmN0aW9uKG8peyBERVAoJ29iaicpOyByZXR1cm4gbz8gKG8gaW5zdGFuY2VvZiBPYmplY3QgJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykubWF0Y2goL15cXFtvYmplY3QgKFxcdyspXFxdJC8pWzFdID09PSAnT2JqZWN0JyA6IGZhbHNlIH19XG5cdFR5cGUub2JqLnB1dCA9IFR5cGUub2JqLnB1dCB8fCBmdW5jdGlvbihvLCBrLCB2KXsgREVQKCdvYmoucHV0Jyk7IHJldHVybiAob3x8e30pW2tdID0gdiwgbyB9XG5cdFR5cGUub2JqLmhhcyA9IFR5cGUub2JqLmhhcyB8fCBmdW5jdGlvbihvLCBrKXsgREVQKCdvYmouaGFzJyk7IHJldHVybiBvICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSB9XG5cdFR5cGUub2JqLmRlbCA9IFR5cGUub2JqLmRlbCB8fCBmdW5jdGlvbihvLCBrKXsgREVQKCdvYmouZGVsJyk7IFxuXHRcdGlmKCFvKXsgcmV0dXJuIH1cblx0XHRvW2tdID0gbnVsbDtcblx0XHRkZWxldGUgb1trXTtcblx0XHRyZXR1cm4gbztcblx0fVxuXHRUeXBlLm9iai5hcyA9IFR5cGUub2JqLmFzIHx8IGZ1bmN0aW9uKG8sIGssIHYsIHUpeyBERVAoJ29iai5hcycpOyByZXR1cm4gb1trXSA9IG9ba10gfHwgKHUgPT09IHY/IHt9IDogdikgfVxuXHRUeXBlLm9iai5pZnkgPSBUeXBlLm9iai5pZnkgfHwgZnVuY3Rpb24obyl7IERFUCgnb2JqLmlmeScpOyBcblx0XHRpZihvYmpfaXMobykpeyByZXR1cm4gbyB9XG5cdFx0dHJ5e28gPSBKU09OLnBhcnNlKG8pO1xuXHRcdH1jYXRjaChlKXtvPXt9fTtcblx0XHRyZXR1cm4gbztcblx0fVxuXHQ7KGZ1bmN0aW9uKCl7IHZhciB1O1xuXHRcdGZ1bmN0aW9uIG1hcCh2LGspe1xuXHRcdFx0aWYob2JqX2hhcyh0aGlzLGspICYmIHUgIT09IHRoaXNba10peyByZXR1cm4gfVxuXHRcdFx0dGhpc1trXSA9IHY7XG5cdFx0fVxuXHRcdFR5cGUub2JqLnRvID0gVHlwZS5vYmoudG8gfHwgZnVuY3Rpb24oZnJvbSwgdG8peyBERVAoJ29iai50bycpOyBcblx0XHRcdHRvID0gdG8gfHwge307XG5cdFx0XHRvYmpfbWFwKGZyb20sIG1hcCwgdG8pO1xuXHRcdFx0cmV0dXJuIHRvO1xuXHRcdH1cblx0fSgpKTtcblx0VHlwZS5vYmouY29weSA9IFR5cGUub2JqLmNvcHkgfHwgZnVuY3Rpb24obyl7IERFUCgnb2JqLmNvcHknKTsgLy8gYmVjYXVzZSBodHRwOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MDMyODIyNDAyNS9odHRwOi8vanNwZXJmLmNvbS9jbG9uaW5nLWFuLW9iamVjdC8yXG5cdFx0cmV0dXJuICFvPyBvIDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvKSk7IC8vIGlzIHNob2NraW5nbHkgZmFzdGVyIHRoYW4gYW55dGhpbmcgZWxzZSwgYW5kIG91ciBkYXRhIGhhcyB0byBiZSBhIHN1YnNldCBvZiBKU09OIGFueXdheXMhXG5cdH1cblx0OyhmdW5jdGlvbigpe1xuXHRcdGZ1bmN0aW9uIGVtcHR5KHYsaSl7IHZhciBuID0gdGhpcy5uLCB1O1xuXHRcdFx0aWYobiAmJiAoaSA9PT0gbiB8fCAob2JqX2lzKG4pICYmIG9ial9oYXMobiwgaSkpKSl7IHJldHVybiB9XG5cdFx0XHRpZih1ICE9PSBpKXsgcmV0dXJuIHRydWUgfVxuXHRcdH1cblx0XHRUeXBlLm9iai5lbXB0eSA9IFR5cGUub2JqLmVtcHR5IHx8IGZ1bmN0aW9uKG8sIG4peyBERVAoJ29iai5lbXB0eScpOyBcblx0XHRcdGlmKCFvKXsgcmV0dXJuIHRydWUgfVxuXHRcdFx0cmV0dXJuIG9ial9tYXAobyxlbXB0eSx7bjpufSk/IGZhbHNlIDogdHJ1ZTtcblx0XHR9XG5cdH0oKSk7XG5cdDsoZnVuY3Rpb24oKXtcblx0XHRmdW5jdGlvbiB0KGssdil7XG5cdFx0XHRpZigyID09PSBhcmd1bWVudHMubGVuZ3RoKXtcblx0XHRcdFx0dC5yID0gdC5yIHx8IHt9O1xuXHRcdFx0XHR0LnJba10gPSB2O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IHQuciA9IHQuciB8fCBbXTtcblx0XHRcdHQuci5wdXNoKGspO1xuXHRcdH07XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cywgbWFwLCB1O1xuXHRcdE9iamVjdC5rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24obyl7IHJldHVybiBtYXAobywgZnVuY3Rpb24odixrLHQpe3Qoayl9KSB9XG5cdFx0VHlwZS5vYmoubWFwID0gbWFwID0gVHlwZS5vYmoubWFwIHx8IGZ1bmN0aW9uKGwsIGMsIF8peyBERVAoJ29iai5tYXAnKTsgXG5cdFx0XHR2YXIgdSwgaSA9IDAsIHgsIHIsIGxsLCBsbGUsIGYgPSAnZnVuY3Rpb24nID09IHR5cGVvZiBjO1xuXHRcdFx0dC5yID0gdTtcblx0XHRcdGlmKGtleXMgJiYgb2JqX2lzKGwpKXtcblx0XHRcdFx0bGwgPSBrZXlzKGwpOyBsbGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XyA9IF8gfHwge307XG5cdFx0XHRpZihsaXN0X2lzKGwpIHx8IGxsKXtcblx0XHRcdFx0eCA9IChsbCB8fCBsKS5sZW5ndGg7XG5cdFx0XHRcdGZvcig7aSA8IHg7IGkrKyl7XG5cdFx0XHRcdFx0dmFyIGlpID0gKGkgKyBUeXBlLmxpc3QuaW5kZXgpO1xuXHRcdFx0XHRcdGlmKGYpe1xuXHRcdFx0XHRcdFx0ciA9IGxsZT8gYy5jYWxsKF8sIGxbbGxbaV1dLCBsbFtpXSwgdCkgOiBjLmNhbGwoXywgbFtpXSwgaWksIHQpO1xuXHRcdFx0XHRcdFx0aWYociAhPT0gdSl7IHJldHVybiByIH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly9pZihUeXBlLnRlc3QuaXMoYyxsW2ldKSl7IHJldHVybiBpaSB9IC8vIHNob3VsZCBpbXBsZW1lbnQgZGVlcCBlcXVhbGl0eSB0ZXN0aW5nIVxuXHRcdFx0XHRcdFx0aWYoYyA9PT0gbFtsbGU/IGxsW2ldIDogaV0peyByZXR1cm4gbGw/IGxsW2ldIDogaWkgfSAvLyB1c2UgdGhpcyBmb3Igbm93XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IoaSBpbiBsKXtcblx0XHRcdFx0XHRpZihmKXtcblx0XHRcdFx0XHRcdGlmKG9ial9oYXMobCxpKSl7XG5cdFx0XHRcdFx0XHRcdHIgPSBfPyBjLmNhbGwoXywgbFtpXSwgaSwgdCkgOiBjKGxbaV0sIGksIHQpO1xuXHRcdFx0XHRcdFx0XHRpZihyICE9PSB1KXsgcmV0dXJuIHIgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvL2lmKGEudGVzdC5pcyhjLGxbaV0pKXsgcmV0dXJuIGkgfSAvLyBzaG91bGQgaW1wbGVtZW50IGRlZXAgZXF1YWxpdHkgdGVzdGluZyFcblx0XHRcdFx0XHRcdGlmKGMgPT09IGxbaV0peyByZXR1cm4gaSB9IC8vIHVzZSB0aGlzIGZvciBub3dcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmPyB0LnIgOiBUeXBlLmxpc3QuaW5kZXg/IDAgOiAtMTtcblx0XHR9XG5cdH0oKSk7XG5cdFR5cGUudGltZSA9IFR5cGUudGltZSB8fCB7fTtcblx0VHlwZS50aW1lLmlzID0gVHlwZS50aW1lLmlzIHx8IGZ1bmN0aW9uKHQpeyBERVAoJ3RpbWUnKTsgcmV0dXJuIHQ/IHQgaW5zdGFuY2VvZiBEYXRlIDogKCtuZXcgRGF0ZSgpLmdldFRpbWUoKSkgfVxuXG5cdHZhciBmbl9pcyA9IFR5cGUuZm4uaXM7XG5cdHZhciBsaXN0X2lzID0gVHlwZS5saXN0LmlzO1xuXHR2YXIgb2JqID0gVHlwZS5vYmosIG9ial9pcyA9IG9iai5pcywgb2JqX2hhcyA9IG9iai5oYXMsIG9ial9tYXAgPSBvYmoubWFwO1xuXG5cdHZhciBWYWwgPSB7fTtcblx0VmFsLmlzID0gZnVuY3Rpb24odil7IERFUCgndmFsLmlzJyk7IC8vIFZhbGlkIHZhbHVlcyBhcmUgYSBzdWJzZXQgb2YgSlNPTjogbnVsbCwgYmluYXJ5LCBudW1iZXIgKCFJbmZpbml0eSksIHRleHQsIG9yIGEgc291bCByZWxhdGlvbi4gQXJyYXlzIG5lZWQgc3BlY2lhbCBhbGdvcml0aG1zIHRvIGhhbmRsZSBjb25jdXJyZW5jeSwgc28gdGhleSBhcmUgbm90IHN1cHBvcnRlZCBkaXJlY3RseS4gVXNlIGFuIGV4dGVuc2lvbiB0aGF0IHN1cHBvcnRzIHRoZW0gaWYgbmVlZGVkIGJ1dCByZXNlYXJjaCB0aGVpciBwcm9ibGVtcyBmaXJzdC5cblx0XHRpZih2ID09PSB1KXsgcmV0dXJuIGZhbHNlIH1cblx0XHRpZih2ID09PSBudWxsKXsgcmV0dXJuIHRydWUgfSAvLyBcImRlbGV0ZXNcIiwgbnVsbGluZyBvdXQga2V5cy5cblx0XHRpZih2ID09PSBJbmZpbml0eSl7IHJldHVybiBmYWxzZSB9IC8vIHdlIHdhbnQgdGhpcyB0byBiZSwgYnV0IEpTT04gZG9lcyBub3Qgc3VwcG9ydCBpdCwgc2FkIGZhY2UuXG5cdFx0aWYodGV4dF9pcyh2KSAvLyBieSBcInRleHRcIiB3ZSBtZWFuIHN0cmluZ3MuXG5cdFx0fHwgYmlfaXModikgLy8gYnkgXCJiaW5hcnlcIiB3ZSBtZWFuIGJvb2xlYW4uXG5cdFx0fHwgbnVtX2lzKHYpKXsgLy8gYnkgXCJudW1iZXJcIiB3ZSBtZWFuIGludGVnZXJzIG9yIGRlY2ltYWxzLlxuXHRcdFx0cmV0dXJuIHRydWU7IC8vIHNpbXBsZSB2YWx1ZXMgYXJlIHZhbGlkLlxuXHRcdH1cblx0XHRyZXR1cm4gVmFsLmxpbmsuaXModikgfHwgZmFsc2U7IC8vIGlzIHRoZSB2YWx1ZSBhIHNvdWwgcmVsYXRpb24/IFRoZW4gaXQgaXMgdmFsaWQgYW5kIHJldHVybiBpdC4gSWYgbm90LCBldmVyeXRoaW5nIGVsc2UgcmVtYWluaW5nIGlzIGFuIGludmFsaWQgZGF0YSB0eXBlLiBDdXN0b20gZXh0ZW5zaW9ucyBjYW4gYmUgYnVpbHQgb24gdG9wIG9mIHRoZXNlIHByaW1pdGl2ZXMgdG8gc3VwcG9ydCBvdGhlciB0eXBlcy5cblx0fVxuXHRWYWwubGluayA9IFZhbC5yZWwgPSB7XzogJyMnfTtcblx0OyhmdW5jdGlvbigpe1xuXHRcdFZhbC5saW5rLmlzID0gZnVuY3Rpb24odil7IERFUCgndmFsLmxpbmsuaXMnKTsgLy8gdGhpcyBkZWZpbmVzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGEgc291bCByZWxhdGlvbiBvciBub3QsIHRoZXkgbG9vayBsaWtlIHRoaXM6IHsnIyc6ICdVVUlEJ31cblx0XHRcdGlmKHYgJiYgdltyZWxfXSAmJiAhdi5fICYmIG9ial9pcyh2KSl7IC8vIG11c3QgYmUgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YXIgbyA9IHt9O1xuXHRcdFx0XHRvYmpfbWFwKHYsIG1hcCwgbyk7XG5cdFx0XHRcdGlmKG8uaWQpeyAvLyBhIHZhbGlkIGlkIHdhcyBmb3VuZC5cblx0XHRcdFx0XHRyZXR1cm4gby5pZDsgLy8geWF5ISBSZXR1cm4gaXQuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTsgLy8gdGhlIHZhbHVlIHdhcyBub3QgYSB2YWxpZCBzb3VsIHJlbGF0aW9uLlxuXHRcdH1cblx0XHRmdW5jdGlvbiBtYXAocywgayl7IHZhciBvID0gdGhpczsgLy8gbWFwIG92ZXIgdGhlIG9iamVjdC4uLlxuXHRcdFx0aWYoby5pZCl7IHJldHVybiBvLmlkID0gZmFsc2UgfSAvLyBpZiBJRCBpcyBhbHJlYWR5IGRlZmluZWQgQU5EIHdlJ3JlIHN0aWxsIGxvb3BpbmcgdGhyb3VnaCB0aGUgb2JqZWN0LCBpdCBpcyBjb25zaWRlcmVkIGludmFsaWQuXG5cdFx0XHRpZihrID09IHJlbF8gJiYgdGV4dF9pcyhzKSl7IC8vIHRoZSBrZXkgc2hvdWxkIGJlICcjJyBhbmQgaGF2ZSBhIHRleHQgdmFsdWUuXG5cdFx0XHRcdG8uaWQgPSBzOyAvLyB3ZSBmb3VuZCB0aGUgc291bCFcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBvLmlkID0gZmFsc2U7IC8vIGlmIHRoZXJlIGV4aXN0cyBhbnl0aGluZyBlbHNlIG9uIHRoZSBvYmplY3QgdGhhdCBpc24ndCB0aGUgc291bCwgdGhlbiBpdCBpcyBjb25zaWRlcmVkIGludmFsaWQuXG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpO1xuXHRWYWwubGluay5pZnkgPSBmdW5jdGlvbih0KXsgREVQKCd2YWwubGluay5pZnknKTsgcmV0dXJuIG9ial9wdXQoe30sIHJlbF8sIHQpIH0gLy8gY29udmVydCBhIHNvdWwgaW50byBhIHJlbGF0aW9uIGFuZCByZXR1cm4gaXQuXG5cdFR5cGUub2JqLmhhcy5fID0gJy4nO1xuXHR2YXIgcmVsXyA9IFZhbC5saW5rLl8sIHU7XG5cdHZhciBiaV9pcyA9IFR5cGUuYmkuaXM7XG5cdHZhciBudW1faXMgPSBUeXBlLm51bS5pcztcblx0dmFyIHRleHRfaXMgPSBUeXBlLnRleHQuaXM7XG5cdHZhciBvYmogPSBUeXBlLm9iaiwgb2JqX2lzID0gb2JqLmlzLCBvYmpfcHV0ID0gb2JqLnB1dCwgb2JqX21hcCA9IG9iai5tYXA7XG5cblx0VHlwZS52YWwgPSBUeXBlLnZhbCB8fCBWYWw7XG5cblx0dmFyIE5vZGUgPSB7XzogJ18nfTtcblx0Tm9kZS5zb3VsID0gZnVuY3Rpb24obiwgbyl7IERFUCgnbm9kZS5zb3VsJyk7IHJldHVybiAobiAmJiBuLl8gJiYgbi5fW28gfHwgc291bF9dKSB9IC8vIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIHNvdWwgb24gYSBub2RlIGFuZCByZXR1cm4gaXQuXG5cdE5vZGUuc291bC5pZnkgPSBmdW5jdGlvbihuLCBvKXsgREVQKCdub2RlLnNvdWwuaWZ5Jyk7IC8vIHB1dCBhIHNvdWwgb24gYW4gb2JqZWN0LlxuXHRcdG8gPSAodHlwZW9mIG8gPT09ICdzdHJpbmcnKT8ge3NvdWw6IG99IDogbyB8fCB7fTtcblx0XHRuID0gbiB8fCB7fTsgLy8gbWFrZSBzdXJlIGl0IGV4aXN0cy5cblx0XHRuLl8gPSBuLl8gfHwge307IC8vIG1ha2Ugc3VyZSBtZXRhIGV4aXN0cy5cblx0XHRuLl9bc291bF9dID0gby5zb3VsIHx8IG4uX1tzb3VsX10gfHwgdGV4dF9yYW5kb20oKTsgLy8gcHV0IHRoZSBzb3VsIG9uIGl0LlxuXHRcdHJldHVybiBuO1xuXHR9XG5cdE5vZGUuc291bC5fID0gVmFsLmxpbmsuXztcblx0OyhmdW5jdGlvbigpe1xuXHRcdE5vZGUuaXMgPSBmdW5jdGlvbihuLCBjYiwgYXMpeyBERVAoJ25vZGUuaXMnKTsgdmFyIHM7IC8vIGNoZWNrcyB0byBzZWUgaWYgYW4gb2JqZWN0IGlzIGEgdmFsaWQgbm9kZS5cblx0XHRcdGlmKCFvYmpfaXMobikpeyByZXR1cm4gZmFsc2UgfSAvLyBtdXN0IGJlIGFuIG9iamVjdC5cblx0XHRcdGlmKHMgPSBOb2RlLnNvdWwobikpeyAvLyBtdXN0IGhhdmUgYSBzb3VsIG9uIGl0LlxuXHRcdFx0XHRyZXR1cm4gIW9ial9tYXAobiwgbWFwLCB7YXM6YXMsY2I6Y2IsczpzLG46bn0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBub3BlISBUaGlzIHdhcyBub3QgYSB2YWxpZCBub2RlLlxuXHRcdH1cblx0XHRmdW5jdGlvbiBtYXAodiwgayl7IC8vIHdlIGludmVydCB0aGlzIGJlY2F1c2UgdGhlIHdheSB3ZSBjaGVjayBmb3IgdGhpcyBpcyB2aWEgYSBuZWdhdGlvbi5cblx0XHRcdGlmKGsgPT09IE5vZGUuXyl7IHJldHVybiB9IC8vIHNraXAgb3ZlciB0aGUgbWV0YWRhdGEuXG5cdFx0XHRpZighVmFsLmlzKHYpKXsgcmV0dXJuIHRydWUgfSAvLyBpdCBpcyB0cnVlIHRoYXQgdGhpcyBpcyBhbiBpbnZhbGlkIG5vZGUuXG5cdFx0XHRpZih0aGlzLmNiKXsgdGhpcy5jYi5jYWxsKHRoaXMuYXMsIHYsIGssIHRoaXMubiwgdGhpcy5zKSB9IC8vIG9wdGlvbmFsbHkgY2FsbGJhY2sgZWFjaCBrZXkvdmFsdWUuXG5cdFx0fVxuXHR9KCkpO1xuXHQ7KGZ1bmN0aW9uKCl7XG5cdFx0Tm9kZS5pZnkgPSBmdW5jdGlvbihvYmosIG8sIGFzKXsgREVQKCdub2RlLmlmeScpOyAvLyByZXR1cm5zIGEgbm9kZSBmcm9tIGEgc2hhbGxvdyBvYmplY3QuXG5cdFx0XHRpZighbyl7IG8gPSB7fSB9XG5cdFx0XHRlbHNlIGlmKHR5cGVvZiBvID09PSAnc3RyaW5nJyl7IG8gPSB7c291bDogb30gfVxuXHRcdFx0ZWxzZSBpZignZnVuY3Rpb24nID09IHR5cGVvZiBvKXsgbyA9IHttYXA6IG99IH1cblx0XHRcdGlmKG8ubWFwKXsgby5ub2RlID0gby5tYXAuY2FsbChhcywgb2JqLCB1LCBvLm5vZGUgfHwge30pIH1cblx0XHRcdGlmKG8ubm9kZSA9IE5vZGUuc291bC5pZnkoby5ub2RlIHx8IHt9LCBvKSl7XG5cdFx0XHRcdG9ial9tYXAob2JqLCBtYXAsIHtvOm8sYXM6YXN9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvLm5vZGU7IC8vIFRoaXMgd2lsbCBvbmx5IGJlIGEgdmFsaWQgbm9kZSBpZiB0aGUgb2JqZWN0IHdhc24ndCBhbHJlYWR5IGRlZXAhXG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG1hcCh2LCBrKXsgdmFyIG8gPSB0aGlzLm8sIHRtcCwgdTsgLy8gaXRlcmF0ZSBvdmVyIGVhY2gga2V5L3ZhbHVlLlxuXHRcdFx0aWYoby5tYXApe1xuXHRcdFx0XHR0bXAgPSBvLm1hcC5jYWxsKHRoaXMuYXMsIHYsICcnK2ssIG8ubm9kZSk7XG5cdFx0XHRcdGlmKHUgPT09IHRtcCl7XG5cdFx0XHRcdFx0b2JqX2RlbChvLm5vZGUsIGspO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0aWYoby5ub2RlKXsgby5ub2RlW2tdID0gdG1wIH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoVmFsLmlzKHYpKXtcblx0XHRcdFx0by5ub2RlW2tdID0gdjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSk7XG5cdHZhciBvYmogPSBUeXBlLm9iaiwgb2JqX2lzID0gb2JqLmlzLCBvYmpfZGVsID0gb2JqLmRlbCwgb2JqX21hcCA9IG9iai5tYXA7XG5cdHZhciB0ZXh0ID0gVHlwZS50ZXh0LCB0ZXh0X3JhbmRvbSA9IHRleHQucmFuZG9tO1xuXHR2YXIgc291bF8gPSBOb2RlLnNvdWwuXztcblx0dmFyIHU7XG5cdFR5cGUubm9kZSA9IFR5cGUubm9kZSB8fCBOb2RlO1xuXG5cdHZhciBTdGF0ZSA9IFR5cGUuc3RhdGU7XG5cdFN0YXRlLmxleCA9IGZ1bmN0aW9uKCl7IERFUCgnc3RhdGUubGV4Jyk7IHJldHVybiBTdGF0ZSgpLnRvU3RyaW5nKDM2KS5yZXBsYWNlKCcuJywnJykgfVxuXHRTdGF0ZS50byA9IGZ1bmN0aW9uKGZyb20sIGssIHRvKXsgREVQKCdzdGF0ZS50bycpOyBcblx0XHR2YXIgdmFsID0gKGZyb218fHt9KVtrXTtcblx0XHRpZihvYmpfaXModmFsKSl7XG5cdFx0XHR2YWwgPSBvYmpfY29weSh2YWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gU3RhdGUuaWZ5KHRvLCBrLCBTdGF0ZS5pcyhmcm9tLCBrKSwgdmFsLCBOb2RlLnNvdWwoZnJvbSkpO1xuXHR9XG5cdDsoZnVuY3Rpb24oKXtcblx0XHRTdGF0ZS5tYXAgPSBmdW5jdGlvbihjYiwgcywgYXMpeyBERVAoJ3N0YXRlLm1hcCcpOyB2YXIgdTsgLy8gZm9yIHVzZSB3aXRoIE5vZGUuaWZ5XG5cdFx0XHR2YXIgbyA9IG9ial9pcyhvID0gY2IgfHwgcyk/IG8gOiBudWxsO1xuXHRcdFx0Y2IgPSBmbl9pcyhjYiA9IGNiIHx8IHMpPyBjYiA6IG51bGw7XG5cdFx0XHRpZihvICYmICFjYil7XG5cdFx0XHRcdHMgPSBudW1faXMocyk/IHMgOiBTdGF0ZSgpO1xuXHRcdFx0XHRvW05fXSA9IG9bTl9dIHx8IHt9O1xuXHRcdFx0XHRvYmpfbWFwKG8sIG1hcCwge286byxzOnN9KTtcblx0XHRcdFx0cmV0dXJuIG87XG5cdFx0XHR9XG5cdFx0XHRhcyA9IGFzIHx8IG9ial9pcyhzKT8gcyA6IHU7XG5cdFx0XHRzID0gbnVtX2lzKHMpPyBzIDogU3RhdGUoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbih2LCBrLCBvLCBvcHQpe1xuXHRcdFx0XHRpZighY2Ipe1xuXHRcdFx0XHRcdG1hcC5jYWxsKHtvOiBvLCBzOiBzfSwgdixrKTtcblx0XHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYi5jYWxsKGFzIHx8IHRoaXMgfHwge30sIHYsIGssIG8sIG9wdCk7XG5cdFx0XHRcdGlmKG9ial9oYXMobyxrKSAmJiB1ID09PSBvW2tdKXsgcmV0dXJuIH1cblx0XHRcdFx0bWFwLmNhbGwoe286IG8sIHM6IHN9LCB2LGspO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmdW5jdGlvbiBtYXAodixrKXtcblx0XHRcdGlmKE5fID09PSBrKXsgcmV0dXJuIH1cblx0XHRcdFN0YXRlLmlmeSh0aGlzLm8sIGssIHRoaXMucykgO1xuXHRcdH1cblx0fSgpKTtcblx0dmFyIG9iaiA9IFR5cGUub2JqLCBvYmpfYXMgPSBvYmouYXMsIG9ial9oYXMgPSBvYmouaGFzLCBvYmpfaXMgPSBvYmouaXMsIG9ial9tYXAgPSBvYmoubWFwLCBvYmpfY29weSA9IG9iai5jb3B5O1xuXHR2YXIgbnVtID0gVHlwZS5udW0sIG51bV9pcyA9IG51bS5pcztcblx0dmFyIGZuID0gVHlwZS5mbiwgZm5faXMgPSBmbi5pcztcblx0dmFyIE5fID0gTm9kZS5fLCB1O1xuXG5cdHZhciBHcmFwaCA9IHt9O1xuXHQ7KGZ1bmN0aW9uKCl7XG5cdFx0R3JhcGguaXMgPSBmdW5jdGlvbihnLCBjYiwgZm4sIGFzKXsgREVQKCdncmFwaC5pcycpOyAvLyBjaGVja3MgdG8gc2VlIGlmIGFuIG9iamVjdCBpcyBhIHZhbGlkIGdyYXBoLlxuXHRcdFx0aWYoIWcgfHwgIW9ial9pcyhnKSB8fCBvYmpfZW1wdHkoZykpeyByZXR1cm4gZmFsc2UgfSAvLyBtdXN0IGJlIGFuIG9iamVjdC5cblx0XHRcdHJldHVybiAhb2JqX21hcChnLCBtYXAsIHtjYjpjYixmbjpmbixhczphc30pOyAvLyBtYWtlcyBzdXJlIGl0IHdhc24ndCBhbiBlbXB0eSBvYmplY3QuXG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG1hcChuLCBzKXsgLy8gd2UgaW52ZXJ0IHRoaXMgYmVjYXVzZSB0aGUgd2F5Jz8gd2UgY2hlY2sgZm9yIHRoaXMgaXMgdmlhIGEgbmVnYXRpb24uXG5cdFx0XHRpZighbiB8fCBzICE9PSBOb2RlLnNvdWwobikgfHwgIU5vZGUuaXMobiwgdGhpcy5mbiwgdGhpcy5hcykpeyByZXR1cm4gdHJ1ZSB9IC8vIGl0IGlzIHRydWUgdGhhdCB0aGlzIGlzIGFuIGludmFsaWQgZ3JhcGguXG5cdFx0XHRpZighdGhpcy5jYil7IHJldHVybiB9XG5cdFx0XHRuZi5uID0gbjsgbmYuYXMgPSB0aGlzLmFzOyAvLyBzZXF1ZW50aWFsIHJhY2UgY29uZGl0aW9ucyBhcmVuJ3QgcmFjZXMuXG5cdFx0XHR0aGlzLmNiLmNhbGwobmYuYXMsIG4sIHMsIG5mKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gbmYoZm4peyAvLyBvcHRpb25hbCBjYWxsYmFjayBmb3IgZWFjaCBub2RlLlxuXHRcdFx0aWYoZm4peyBOb2RlLmlzKG5mLm4sIGZuLCBuZi5hcykgfSAvLyB3aGVyZSB3ZSB0aGVuIGhhdmUgYW4gb3B0aW9uYWwgY2FsbGJhY2sgZm9yIGVhY2gga2V5L3ZhbHVlLlxuXHRcdH1cblx0fSgpKTtcblx0OyhmdW5jdGlvbigpe1xuXHRcdEdyYXBoLmlmeSA9IGZ1bmN0aW9uKG9iaiwgZW52LCBhcyl7IERFUCgnZ3JhcGguaWZ5Jyk7IFxuXHRcdFx0dmFyIGF0ID0ge3BhdGg6IFtdLCBvYmo6IG9ian07XG5cdFx0XHRpZighZW52KXtcblx0XHRcdFx0ZW52ID0ge307XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmKHR5cGVvZiBlbnYgPT09ICdzdHJpbmcnKXtcblx0XHRcdFx0ZW52ID0ge3NvdWw6IGVudn07XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmKCdmdW5jdGlvbicgPT0gdHlwZW9mIGVudil7XG5cdFx0XHRcdGVudi5tYXAgPSBlbnY7XG5cdFx0XHR9XG5cdFx0XHRpZih0eXBlb2YgYXMgPT09ICdzdHJpbmcnKXtcblx0XHRcdFx0ZW52LnNvdWwgPSBlbnYuc291bCB8fCBhcztcblx0XHRcdFx0YXMgPSB1O1xuXHRcdFx0fVxuXHRcdFx0aWYoZW52LnNvdWwpe1xuXHRcdFx0XHRhdC5saW5rID0gVmFsLmxpbmsuaWZ5KGVudi5zb3VsKTtcblx0XHRcdH1cblx0XHRcdGVudi5zaGVsbCA9IChhc3x8e30pLnNoZWxsO1xuXHRcdFx0ZW52LmdyYXBoID0gZW52LmdyYXBoIHx8IHt9O1xuXHRcdFx0ZW52LnNlZW4gPSBlbnYuc2VlbiB8fCBbXTtcblx0XHRcdGVudi5hcyA9IGVudi5hcyB8fCBhcztcblx0XHRcdG5vZGUoZW52LCBhdCk7XG5cdFx0XHRlbnYucm9vdCA9IGF0Lm5vZGU7XG5cdFx0XHRyZXR1cm4gZW52LmdyYXBoO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBub2RlKGVudiwgYXQpeyB2YXIgdG1wO1xuXHRcdFx0aWYodG1wID0gc2VlbihlbnYsIGF0KSl7IHJldHVybiB0bXAgfVxuXHRcdFx0YXQuZW52ID0gZW52O1xuXHRcdFx0YXQuc291bCA9IHNvdWw7XG5cdFx0XHRpZihOb2RlLmlmeShhdC5vYmosIG1hcCwgYXQpKXtcblx0XHRcdFx0YXQubGluayA9IGF0LmxpbmsgfHwgVmFsLmxpbmsuaWZ5KE5vZGUuc291bChhdC5ub2RlKSk7XG5cdFx0XHRcdGlmKGF0Lm9iaiAhPT0gZW52LnNoZWxsKXtcblx0XHRcdFx0XHRlbnYuZ3JhcGhbVmFsLmxpbmsuaXMoYXQubGluayldID0gYXQubm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGF0O1xuXHRcdH1cblx0XHRmdW5jdGlvbiBtYXAodixrLG4pe1xuXHRcdFx0dmFyIGF0ID0gdGhpcywgZW52ID0gYXQuZW52LCBpcywgdG1wO1xuXHRcdFx0aWYoTm9kZS5fID09PSBrICYmIG9ial9oYXModixWYWwubGluay5fKSl7XG5cdFx0XHRcdHJldHVybiBuLl87IC8vIFRPRE86IEJ1Zz9cblx0XHRcdH1cblx0XHRcdGlmKCEoaXMgPSB2YWxpZCh2LGssbiwgYXQsZW52KSkpeyByZXR1cm4gfVxuXHRcdFx0aWYoIWspe1xuXHRcdFx0XHRhdC5ub2RlID0gYXQubm9kZSB8fCBuIHx8IHt9O1xuXHRcdFx0XHRpZihvYmpfaGFzKHYsIE5vZGUuXykgJiYgTm9kZS5zb3VsKHYpKXsgLy8gPyBmb3Igc2FmZXR5ID9cblx0XHRcdFx0XHRhdC5ub2RlLl8gPSBvYmpfY29weSh2Ll8pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF0Lm5vZGUgPSBOb2RlLnNvdWwuaWZ5KGF0Lm5vZGUsIFZhbC5saW5rLmlzKGF0LmxpbmspKTtcblx0XHRcdFx0YXQubGluayA9IGF0LmxpbmsgfHwgVmFsLmxpbmsuaWZ5KE5vZGUuc291bChhdC5ub2RlKSk7XG5cdFx0XHR9XG5cdFx0XHRpZih0bXAgPSBlbnYubWFwKXtcblx0XHRcdFx0dG1wLmNhbGwoZW52LmFzIHx8IHt9LCB2LGssbiwgYXQpO1xuXHRcdFx0XHRpZihvYmpfaGFzKG4saykpe1xuXHRcdFx0XHRcdHYgPSBuW2tdO1xuXHRcdFx0XHRcdGlmKHUgPT09IHYpe1xuXHRcdFx0XHRcdFx0b2JqX2RlbChuLCBrKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoIShpcyA9IHZhbGlkKHYsayxuLCBhdCxlbnYpKSl7IHJldHVybiB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKCFrKXsgcmV0dXJuIGF0Lm5vZGUgfVxuXHRcdFx0aWYodHJ1ZSA9PT0gaXMpe1xuXHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdH1cblx0XHRcdHRtcCA9IG5vZGUoZW52LCB7b2JqOiB2LCBwYXRoOiBhdC5wYXRoLmNvbmNhdChrKX0pO1xuXHRcdFx0aWYoIXRtcC5ub2RlKXsgcmV0dXJuIH1cblx0XHRcdHJldHVybiB0bXAubGluazsgLy97JyMnOiBOb2RlLnNvdWwodG1wLm5vZGUpfTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gc291bChpZCl7IHZhciBhdCA9IHRoaXM7XG5cdFx0XHR2YXIgcHJldiA9IFZhbC5saW5rLmlzKGF0LmxpbmspLCBncmFwaCA9IGF0LmVudi5ncmFwaDtcblx0XHRcdGF0LmxpbmsgPSBhdC5saW5rIHx8IFZhbC5saW5rLmlmeShpZCk7XG5cdFx0XHRhdC5saW5rW1ZhbC5saW5rLl9dID0gaWQ7XG5cdFx0XHRpZihhdC5ub2RlICYmIGF0Lm5vZGVbTm9kZS5fXSl7XG5cdFx0XHRcdGF0Lm5vZGVbTm9kZS5fXVtWYWwubGluay5fXSA9IGlkO1xuXHRcdFx0fVxuXHRcdFx0aWYob2JqX2hhcyhncmFwaCwgcHJldikpe1xuXHRcdFx0XHRncmFwaFtpZF0gPSBncmFwaFtwcmV2XTtcblx0XHRcdFx0b2JqX2RlbChncmFwaCwgcHJldik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHZhbGlkKHYsayxuLCBhdCxlbnYpeyB2YXIgdG1wO1xuXHRcdFx0aWYoVmFsLmlzKHYpKXsgcmV0dXJuIHRydWUgfVxuXHRcdFx0aWYob2JqX2lzKHYpKXsgcmV0dXJuIDEgfVxuXHRcdFx0aWYodG1wID0gZW52LmludmFsaWQpe1xuXHRcdFx0XHR2ID0gdG1wLmNhbGwoZW52LmFzIHx8IHt9LCB2LGssbik7XG5cdFx0XHRcdHJldHVybiB2YWxpZCh2LGssbiwgYXQsZW52KTtcblx0XHRcdH1cblx0XHRcdGVudi5lcnIgPSBcIkludmFsaWQgdmFsdWUgYXQgJ1wiICsgYXQucGF0aC5jb25jYXQoaykuam9pbignLicpICsgXCInIVwiO1xuXHRcdFx0aWYoVHlwZS5saXN0LmlzKHYpKXsgZW52LmVyciArPSBcIiBVc2UgYC5zZXQoaXRlbSlgIGluc3RlYWQgb2YgYW4gQXJyYXkuXCIgfVxuXHRcdH1cblx0XHRmdW5jdGlvbiBzZWVuKGVudiwgYXQpe1xuXHRcdFx0dmFyIGFyciA9IGVudi5zZWVuLCBpID0gYXJyLmxlbmd0aCwgaGFzO1xuXHRcdFx0d2hpbGUoaS0tKXsgaGFzID0gYXJyW2ldO1xuXHRcdFx0XHRpZihhdC5vYmogPT09IGhhcy5vYmopeyByZXR1cm4gaGFzIH1cblx0XHRcdH1cblx0XHRcdGFyci5wdXNoKGF0KTtcblx0XHR9XG5cdH0oKSk7XG5cdEdyYXBoLm5vZGUgPSBmdW5jdGlvbihub2RlKXsgREVQKCdncmFwaC5ub2RlJyk7IFxuXHRcdHZhciBzb3VsID0gTm9kZS5zb3VsKG5vZGUpO1xuXHRcdGlmKCFzb3VsKXsgcmV0dXJuIH1cblx0XHRyZXR1cm4gb2JqX3B1dCh7fSwgc291bCwgbm9kZSk7XG5cdH1cblx0OyhmdW5jdGlvbigpe1xuXHRcdEdyYXBoLnRvID0gZnVuY3Rpb24oZ3JhcGgsIHJvb3QsIG9wdCl7IERFUCgnZ3JhcGgudG8nKTsgXG5cdFx0XHRpZighZ3JhcGgpeyByZXR1cm4gfVxuXHRcdFx0dmFyIG9iaiA9IHt9O1xuXHRcdFx0b3B0ID0gb3B0IHx8IHtzZWVuOiB7fX07XG5cdFx0XHRvYmpfbWFwKGdyYXBoW3Jvb3RdLCBtYXAsIHtvYmo6b2JqLCBncmFwaDogZ3JhcGgsIG9wdDogb3B0fSk7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBtYXAodixrKXsgdmFyIHRtcCwgb2JqO1xuXHRcdFx0aWYoTm9kZS5fID09PSBrKXtcblx0XHRcdFx0aWYob2JqX2VtcHR5KHYsIFZhbC5saW5rLl8pKXtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5vYmpba10gPSBvYmpfY29weSh2KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoISh0bXAgPSBWYWwubGluay5pcyh2KSkpe1xuXHRcdFx0XHR0aGlzLm9ialtrXSA9IHY7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKG9iaiA9IHRoaXMub3B0LnNlZW5bdG1wXSl7XG5cdFx0XHRcdHRoaXMub2JqW2tdID0gb2JqO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm9ialtrXSA9IHRoaXMub3B0LnNlZW5bdG1wXSA9IEdyYXBoLnRvKHRoaXMuZ3JhcGgsIHRtcCwgdGhpcy5vcHQpO1xuXHRcdH1cblx0fSgpKTtcblx0dmFyIGZuX2lzID0gVHlwZS5mbi5pcztcblx0dmFyIG9iaiA9IFR5cGUub2JqLCBvYmpfaXMgPSBvYmouaXMsIG9ial9kZWwgPSBvYmouZGVsLCBvYmpfaGFzID0gb2JqLmhhcywgb2JqX2VtcHR5ID0gb2JqLmVtcHR5LCBvYmpfcHV0ID0gb2JqLnB1dCwgb2JqX21hcCA9IG9iai5tYXAsIG9ial9jb3B5ID0gb2JqLmNvcHk7XG5cdHZhciB1O1xuXHRUeXBlLmdyYXBoID0gVHlwZS5ncmFwaCB8fCBHcmFwaDtcbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/gun.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/index.js":
/*!***********************************!*\
  !*** ./node_modules/gun/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/server */ \"(ssr)/./node_modules/gun/lib/server.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGtHQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjMtY2hhdC8uL25vZGVfbW9kdWxlcy9ndW4vaW5kZXguanM/YjE1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3NlcnZlcicpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/axe.js":
/*!*************************************!*\
  !*** ./node_modules/gun/lib/axe.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// I don't quite know where this should go yet, so putting it here\n// what will probably wind up happening is that minimal AXE logic added to end of gun.js\n// and then rest of AXE logic (here) will be moved back to gun/axe.js\n// but for now... I gotta rush this out!\nvar Gun = (typeof window !== \"undefined\")? window.Gun : __webpack_require__(/*! ../gun */ \"(ssr)/./node_modules/gun/gun.js\"), u;\nGun.on('opt', function(at){ start(at); this.to.next(at) }); // make sure to call the \"next\" middleware adapter.\n// TODO: BUG: panic test/panic/1 & test/panic/3 fail when AXE is on.\nfunction start(root){\n\tif(root.axe){ return }\n\tvar opt = root.opt, peers = opt.peers;\n\tif(false === opt.axe){ return }\n\tif((typeof process !== \"undefined\") && 'false' === ''+(process.env||'').AXE){ return }\n\tGun.log.once(\"AXE\", \"AXE relay enabled!\");\n\tvar axe = root.axe = {}, tmp, id;\n\tvar mesh = opt.mesh = opt.mesh || Gun.Mesh(root); // DAM!\n\tvar dup = root.dup;\n\n\tmesh.way = function(msg){\n\t\tif(!msg){ return }\n\t\t//relayUp(msg); // TEMPORARY!!!\n\t\tif(msg.get){ return GET(msg) }\n\t\tif(msg.put){ return }\n\t\tfall(msg);\n\t}\n\n\tfunction GET(msg){\n\t\tif(!msg){ return }\n\t\tvar via = (msg._||'').via, soul, has, tmp, ref;\n\t\tif(!via || !via.id){ return fall(msg) }\n\t\t// SUBSCRIPTION LOGIC MOVED TO GET'S ACK REPLY.\n\t\tif(!(ref = REF(msg)._)){ return fall(msg) }\n\t\tref.asked = +new Date;\n\t\tGET.turn(msg, ref.route, 0);\n\t}\n\tGET.turn = function(msg, route, turn){\n\t\tvar tmp = msg['#'], tag = dup.s[tmp], next; \n\t\tif(!tmp || !tag){ return } // message timed out, GUN may require us to relay, tho AXE does not like that. Rethink?\n\t\t// TOOD: BUG! Handle edge case where live updates occur while these turn hashes are being checked (they'll never be consistent), but we don't want to degrade to O(N), if we know the via asking peer got an update, then we should do something like cancel these turns asking for data.\n\t\t// Ideas: Save a random seed that sorts the route, store it and the index. // Or indexing on lowest latency is probably better.\n\t\tclearTimeout(tag.lack);\n\t\tif(tag.ack && (tmp = tag['##']) && msg['##'] === tmp){ return } // hashes match, stop asking other peers!\n\t\tnext = (Object.maps(route||opt.peers)).slice(turn = turn || 0);\n\t\tif(!next.length){\n\t\t\tif(!route){ return } // asked all peers, stop asking!\n\t\t\tGET.turn(msg, u, 0); // asked all subs, now now ask any peers. (not always the best idea, but stays )\n\t\t\treturn;\n\t\t}\n\t\tsetTimeout.each(next, function(id){\n\t\t\tvar peer = opt.peers[id]; turn++;\n\t\t\tif(!peer || !peer.wire){ route && route.delete(id); return } // bye! // TODO: CHECK IF 0 OTHER PEERS & UNSUBSCRIBE\n\t\t\tif(mesh.say(msg, peer) === false){ return } // was self\n\t\t\tif(0 == (turn % 3)){ return 1 }\n\t\t}, function(){\n\t\t\ttag['##'] = msg['##']; // should probably set this in a more clever manner, do live `in` checks ++ --, etc. but being lazy for now. // TODO: Yes, see `in` TODO, currently this might match against only in-mem cause no other peers reply, which is \"fine\", but could cause a false positive.\n\t\t\ttag.lack = setTimeout(function(){ GET.turn(msg, route, turn) }, 25);\n\t\t}, 3);\n\t}\n\tfunction fall(msg){ mesh.say(msg, opt.peers) }\n\tfunction REF(msg){\n\t\tvar ref = '', soul, has, tmp;\n\t\tif(!msg || !msg.get){ return ref }\n\t\tif('string' == typeof (soul = msg.get['#'])){ ref = root.$.get(soul) }\n\t\tif('string' == typeof (tmp = msg.get['.'])){ has = tmp } else { has = '' }\n\n\t\tvar via = (msg._||'').via, sub = (via.sub || (via.sub = new Object.Map)); (sub.get(soul) || (sub.set(soul, tmp = new Object.Map) && tmp)).set(has, 1); // {soul: {'':1, has: 1}} // TEMPORARILY REVERT AXE TOWER TYING TO SUBSCRIBING TO EVERYTHING. UNDO THIS!\n\t\tvia.id && ref._ && (ref._.route || (ref._.route = new Object.Map)).set(via.id, via); // SAME AS ^\n\n\t\treturn ref;\n\t}\n\tfunction LEX(lex){ return (lex = lex || '')['='] || lex['*'] || lex['>'] || lex }\n\t\n\troot.on('in', function(msg){ var to = this.to, tmp;\n\t\tif((tmp = msg['@']) && (tmp = dup.s[tmp])){\n\t\t\ttmp.ack = (tmp.ack || 0) + 1; // count remote ACKs to GET. // TODO: If mismatch, should trigger next asks.\n\t\t\tif(tmp.it && tmp.it.get && msg.put){ // WHEN SEEING A PUT REPLY TO A GET...\n\t\t\t\tvar get = tmp.it.get||'', ref = REF(tmp.it)._, via = (tmp.it._||'').via||'', sub;\n\t\t\t\tif(via && ref){ // SUBSCRIBE THE PEER WHO ASKED VIA FOR IT:\n\t\t\t\t\t//console.log(\"SUBSCRIBING\", Object.maps(ref.route||''), \"to\", LEX(get['#']));\n\t\t\t\t\tvia.id && (ref.route || (ref.route = new Object.Map)).set(via.id, via);\n\t\t\t\t\tsub = (via.sub || (via.sub = new Object.Map));\n\t\t\t\t\tref && (sub.get(LEX(get['#'])) || (sub.set(LEX(get['#']), sub = new Object.Map) && sub)).set(LEX(get['.']), 1); // {soul: {'':1, has: 1}}\n\n\t\t\t\t\tvia = (msg._||'').via||'';\n\t\t\t\t\tif(via){ // BIDIRECTIONAL SUBSCRIBE: REPLIER IS NOW SUBSCRIBED. DO WE WANT THIS?\n\t\t\t\t\t\tvia.id && (ref.route || (ref.route = new Object.Map)).set(via.id, via);\n\t\t\t\t\t\tsub = (via.sub || (via.sub = new Object.Map));\n\t\t\t\t\t\tif(ref){\n\t\t\t\t\t\t\tvar soul = LEX(get['#']), sift = sub.get(soul), has = LEX(get['.']);\n\t\t\t\t\t\t\tif(has){\n\t\t\t\t\t\t\t\t(sift || (sub.set(soul, sift = new Object.Map) && sift)).set(has, 1);\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tif(!sift){\n\t\t\t\t\t\t\t\tsub.set(soul, sift = new Object.Map);\n\t\t\t\t\t\t\t\tsift.set('', 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif((tmp = tmp.back)){ // backtrack OKs since AXE splits PUTs up.\n\t\t\t\tsetTimeout.each(Object.keys(tmp), function(id){\n\t\t\t\t\tto.next({'#': msg['#'], '@': id, ok: msg.ok});\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tto.next(msg);\n\t});\n\n\troot.on('create', function(root){\n\t\tthis.to.next(root);\n\t\tvar Q = {};\n\t\troot.on('put', function(msg){\n\t\t\tvar eve = this, at = eve.as, put = msg.put, soul = put['#'], has = put['.'], val = put[':'], state = put['>'], q, tmp;\n\t\t\teve.to.next(msg);\n\t\t\tif(msg['@']){ return } // acks send existing data, not updates, so no need to resend to others.\n\t\t\tif(!soul || !has){ return }\n\t\t\tvar ref = root.$.get(soul)._, route = (ref||'').route;\n\t\t\tif(!route){ return }\n\t\t\tif(ref.skip && ref.skip.has == has){ ref.skip.now = msg['#']; return }\n\t\t\t(ref.skip = {now: msg['#'], has: has}).to = setTimeout(function(){\n\t\t\tsetTimeout.each(Object.maps(route), function(pid){ var peer, tmp;\n\t\t\t\tvar skip = ref.skip||''; ref.skip = null;\n\t\t\t\tif(!(peer = route.get(pid))){ return }\n\t\t\t\tif(!peer.wire){ route.delete(pid); return } // bye!\n\t\t\t\tvar sub = (peer.sub || (peer.sub = new Object.Map)).get(soul);\n\t\t\t\tif(!sub){ return }\n\t\t\t\tif(!sub.get(has) && !sub.get('')){ return }\n\t\t\t\tvar put = peer.put || (peer.put = {});\n\t\t\t\tvar node = root.graph[soul], tmp;\n\t\t\t\tif(node && u !== (tmp = node[has])){\n\t\t\t\t\tstate = state_is(node, has);\n\t\t\t\t\tval = tmp;\n\t\t\t\t}\n\t\t\t\tput[soul] = state_ify(put[soul], has, state, val, soul);\n\t\t\t\ttmp = dup.track(peer.next = peer.next || String.random(9));\n\t\t\t\t(tmp.back || (tmp.back = {}))[''+(skip.now||msg['#'])] = 1;\n\t\t\t\tif(peer.to){ return }\n\t\t\t\tpeer.to = setTimeout(function(){ flush(peer) }, opt.gap);\n\t\t\t}) }, 9);\n\t\t});\n\t});\n\n\tfunction flush(peer){\n\t\tvar msg = {'#': peer.next, put: peer.put, ok: {'@': 3, '/': mesh.near}}; // BUG: TODO: sub count!\n\t\t// TODO: what about DAM's >< dedup? Current thinking is, don't use it, however, you could store first msg# & latest msg#, and if here... latest === first then likely it is the same >< thing, so if(firstMsg['><'][peer.id]){ return } don't send.\n\t\tpeer.next = peer.put = peer.to = null;\n\t\tmesh.say(msg, peer);\n\t}\n\tvar state_ify = Gun.state.ify, state_is = Gun.state.is;\n\n\tfunction relayUp(msg){\n\t\tmesh.say(msg, axe.up);\n\t}\n\n\t;(function(){ // THIS IS THE UP MODULE;\n\t\taxe.up = {};\n\t\tvar hi = mesh.hear['?']; // lower-level integration with DAM! This is abnormal but helps performance.\n\t\tmesh.hear['?'] = function(msg, peer){ var p; // deduplicate unnecessary connections:\n\t\t\thi(msg, peer);\n\t\t\tif(!peer.pid){ return }\n\t\t\tif(peer.pid === opt.pid){ mesh.bye(peer); return } // if I connected to myself, drop.\n\t\t\tif(p = axe.up[peer.pid]){ // if we both connected to each other...\n\t\t\t\tif(p === peer){ return } // do nothing if no conflict,\n\t\t\t\tif(opt.pid > peer.pid){ // else deterministically sort\n\t\t\t\t\tp = peer; // so we will wind up choosing the same to keep\n\t\t\t\t\tpeer = axe.up[p.pid]; // and the same to drop.\n\t\t\t\t}\n\t\t\t\tp.url = p.url || peer.url; // copy if not\n\t\t\t\tmesh.bye(peer); // drop\n\t\t\t\taxe.up[p.pid] = p; // update same to be same.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!peer.url){ return }\n\t\t\taxe.up[peer.pid] = peer;\n\t\t\tif(axe.stay){ axe.stay() }\n\t\t};\n\n\t\tmesh.hear['opt'] = function(msg, peer){\n\t\t\tif(msg.ok){ return }\n\t\t\tvar tmp = msg.opt;\n\t\t\tif(!tmp){ return }\n\t\t\ttmp = tmp.peers;\n\t\t\tif(!tmp || 'string' != typeof tmp){ return }\n\t\t\tif(99 <= Object.keys(axe.up).length){ return } // 99 TEMPORARILY UNTIL BENCHMARKED!\n\t\t\tmesh.hi({id: tmp, url: tmp, retry: 9});\n\t\t\tif(peer){ mesh.say({dam: 'opt', ok: 1, '@': msg['#']}, peer) }\n\t\t}\n\n\t\taxe.stay = function(){\n\t\t\tclearTimeout(axe.stay.to);\n\t\t\taxe.stay.to = setTimeout(function(tmp, urls){\n\t\t\t\tif(!(tmp = root.stats && root.stats.stay)){ return }\n\t\t\t\turls = {}; Object.keys(axe.up||'').forEach(function(p){\n\t\t\t\t\tp = (axe.up||'')[p]; if(p.url){ urls[p.url] = {} }\n\t\t\t\t});\n\t\t\t\t(tmp.axe = tmp.axe || {}).up = urls;\n\t\t\t}, 1000 * 9);//1000 * 60);\n\t\t};\n\t\tsetTimeout(function(tmp){\n\t\t\tif(!(tmp = root.stats && root.stats.stay && root.stats.stay.axe)){ return }\n\t\t\tif(!(tmp = tmp.up)){ return }\n\t\t\tif(!(tmp instanceof Array)){ tmp = Object.keys(tmp) }\n\t\t\tsetTimeout.each(tmp||[], function(url){ mesh.hear.opt({opt: {peers: url}}) });\n\t\t},1000);\n\t}());\n\n\t;(function(){ // THIS IS THE MOB MODULE;\n\t\t//return; // WORK IN PROGRESS, TEST FINALIZED, NEED TO MAKE STABLE.\n\t\t/*\n\t\t\tAXE should have a couple of threshold items...\n\t\t\tlet's pretend there is a variable max peers connected\n\t\t\tmob = 10000\n\t\t\tif we get more peers than that...\n\t\t\twe should start sending those peers a remote command\n\t\t\tthat they should connect to this or that other peer\n\t\t\tand then once they (or before they do?) drop them from us.\n\t\t\tsake of the test... gonna set that peer number to 1.\n\t\t\tThe mob threshold might be determined by other factors,\n\t\t\tlike how much RAM or CPU stress we have.\n\t\t*/\n\t\topt.mob = opt.mob || 9900; // should be based on ulimit, some clouds as low as 10K.\n\n\t\t// handle rebalancing a mob of peers:\n\t\troot.on('hi', function(peer){\n\t\t\tthis.to.next(peer);\n\t\t\tif(peer.url){ return } // I am assuming that if we are wanting to make an outbound connection to them, that we don't ever want to drop them unless our actual config settings change.\n\t\t\tvar count = /*Object.keys(opt.peers).length ||*/ mesh.near; // TODO: BUG! This is slow, use .near, but near is buggy right now, fix in DAM.\n\t\t\t//console.log(\"are we mobbed?\", opt.mob, Object.keys(opt.peers).length, mesh.near);\n\t\t\tif(opt.mob >= count){ return }  // TODO: Make dynamic based on RAM/CPU also. Or possibly even weird stuff like opt.mob / axe.up length?\n\t\t\tvar peers = {};Object.keys(axe.up).forEach(function(p){ p = axe.up[p]; p.url && (peers[p.url]={}) });\n\t\t\t// TODO: BUG!!! Infinite reconnection loop happens if not enough relays, or if some are missing. For instance, :8766 says to connect to :8767 which then says to connect to :8766. To not DDoS when system overload, figure clever way to tell peers to retry later, that network does not have enough capacity?\n\t\t\tmesh.say({dam: 'mob', mob: count, peers: peers}, peer);\n\t\t\tsetTimeout(function(){ mesh.bye(peer) }, 9); // something with better perf?\n\t\t});\n\t\troot.on('bye', function(peer){\n\t\t\tthis.to.next(peer);\n\t\t});\n\n\t}());\n}\n\n;(function(){\n\tvar from = Array.from;\n\tObject.maps = function(o){\n\t\tif(from && o instanceof Map){ return from(o.keys()) }\n\t\tif(o instanceof Object.Map){ o = o.s }\n\t\treturn Object.keys(o);\n\t}\n\tif(from){ return Object.Map = Map }\n\t(Object.Map = function(){ this.s = {} }).prototype = {set:function(k,v){this.s[k]=v;return this},get:function(k){return this.s[k]},delete:function(k){delete this.s[k]}};\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUNBQWlDO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxlQUFlO0FBQ2YsMEJBQTBCLFdBQVc7QUFDckMsS0FBSztBQUNMLDRCQUE0QjtBQUM1QixJQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSx3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLDJDQUEyQyxlQUFlLE1BQU0sWUFBWSxHQUFHO0FBQy9FLEdBQUc7QUFDSCxFQUFFOztBQUVGLEVBQUUsYUFBYTtBQUNmLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLCtEQUErRDtBQUMvRDtBQUNBLHlCQUF5QixVQUFVO0FBQ25DLGtCQUFrQix5Q0FBeUMsZUFBZSx5QkFBeUIsR0FBRztBQUN0RztBQUNBLGFBQWEscUNBQXFDO0FBQ2xELDBCQUEwQixnQkFBZ0IsTUFBTTtBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTtBQUNGOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVztBQUNYLDJCQUEyQixhQUFhLGVBQWUsa0JBQWtCLFlBQVksWUFBWSxpQkFBaUIsaUJBQWlCLG9CQUFvQjtBQUN2SixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMy1jaGF0Ly4vbm9kZV9tb2R1bGVzL2d1bi9saWIvYXhlLmpzPzgwMTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSSBkb24ndCBxdWl0ZSBrbm93IHdoZXJlIHRoaXMgc2hvdWxkIGdvIHlldCwgc28gcHV0dGluZyBpdCBoZXJlXG4vLyB3aGF0IHdpbGwgcHJvYmFibHkgd2luZCB1cCBoYXBwZW5pbmcgaXMgdGhhdCBtaW5pbWFsIEFYRSBsb2dpYyBhZGRlZCB0byBlbmQgb2YgZ3VuLmpzXG4vLyBhbmQgdGhlbiByZXN0IG9mIEFYRSBsb2dpYyAoaGVyZSkgd2lsbCBiZSBtb3ZlZCBiYWNrIHRvIGd1bi9heGUuanNcbi8vIGJ1dCBmb3Igbm93Li4uIEkgZ290dGEgcnVzaCB0aGlzIG91dCFcbnZhciBHdW4gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIik/IHdpbmRvdy5HdW4gOiByZXF1aXJlKCcuLi9ndW4nKSwgdTtcbkd1bi5vbignb3B0JywgZnVuY3Rpb24oYXQpeyBzdGFydChhdCk7IHRoaXMudG8ubmV4dChhdCkgfSk7IC8vIG1ha2Ugc3VyZSB0byBjYWxsIHRoZSBcIm5leHRcIiBtaWRkbGV3YXJlIGFkYXB0ZXIuXG4vLyBUT0RPOiBCVUc6IHBhbmljIHRlc3QvcGFuaWMvMSAmIHRlc3QvcGFuaWMvMyBmYWlsIHdoZW4gQVhFIGlzIG9uLlxuZnVuY3Rpb24gc3RhcnQocm9vdCl7XG5cdGlmKHJvb3QuYXhlKXsgcmV0dXJuIH1cblx0dmFyIG9wdCA9IHJvb3Qub3B0LCBwZWVycyA9IG9wdC5wZWVycztcblx0aWYoZmFsc2UgPT09IG9wdC5heGUpeyByZXR1cm4gfVxuXHRpZigodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpICYmICdmYWxzZScgPT09ICcnKyhwcm9jZXNzLmVudnx8JycpLkFYRSl7IHJldHVybiB9XG5cdEd1bi5sb2cub25jZShcIkFYRVwiLCBcIkFYRSByZWxheSBlbmFibGVkIVwiKTtcblx0dmFyIGF4ZSA9IHJvb3QuYXhlID0ge30sIHRtcCwgaWQ7XG5cdHZhciBtZXNoID0gb3B0Lm1lc2ggPSBvcHQubWVzaCB8fCBHdW4uTWVzaChyb290KTsgLy8gREFNIVxuXHR2YXIgZHVwID0gcm9vdC5kdXA7XG5cblx0bWVzaC53YXkgPSBmdW5jdGlvbihtc2cpe1xuXHRcdGlmKCFtc2cpeyByZXR1cm4gfVxuXHRcdC8vcmVsYXlVcChtc2cpOyAvLyBURU1QT1JBUlkhISFcblx0XHRpZihtc2cuZ2V0KXsgcmV0dXJuIEdFVChtc2cpIH1cblx0XHRpZihtc2cucHV0KXsgcmV0dXJuIH1cblx0XHRmYWxsKG1zZyk7XG5cdH1cblxuXHRmdW5jdGlvbiBHRVQobXNnKXtcblx0XHRpZighbXNnKXsgcmV0dXJuIH1cblx0XHR2YXIgdmlhID0gKG1zZy5ffHwnJykudmlhLCBzb3VsLCBoYXMsIHRtcCwgcmVmO1xuXHRcdGlmKCF2aWEgfHwgIXZpYS5pZCl7IHJldHVybiBmYWxsKG1zZykgfVxuXHRcdC8vIFNVQlNDUklQVElPTiBMT0dJQyBNT1ZFRCBUTyBHRVQnUyBBQ0sgUkVQTFkuXG5cdFx0aWYoIShyZWYgPSBSRUYobXNnKS5fKSl7IHJldHVybiBmYWxsKG1zZykgfVxuXHRcdHJlZi5hc2tlZCA9ICtuZXcgRGF0ZTtcblx0XHRHRVQudHVybihtc2csIHJlZi5yb3V0ZSwgMCk7XG5cdH1cblx0R0VULnR1cm4gPSBmdW5jdGlvbihtc2csIHJvdXRlLCB0dXJuKXtcblx0XHR2YXIgdG1wID0gbXNnWycjJ10sIHRhZyA9IGR1cC5zW3RtcF0sIG5leHQ7IFxuXHRcdGlmKCF0bXAgfHwgIXRhZyl7IHJldHVybiB9IC8vIG1lc3NhZ2UgdGltZWQgb3V0LCBHVU4gbWF5IHJlcXVpcmUgdXMgdG8gcmVsYXksIHRobyBBWEUgZG9lcyBub3QgbGlrZSB0aGF0LiBSZXRoaW5rP1xuXHRcdC8vIFRPT0Q6IEJVRyEgSGFuZGxlIGVkZ2UgY2FzZSB3aGVyZSBsaXZlIHVwZGF0ZXMgb2NjdXIgd2hpbGUgdGhlc2UgdHVybiBoYXNoZXMgYXJlIGJlaW5nIGNoZWNrZWQgKHRoZXknbGwgbmV2ZXIgYmUgY29uc2lzdGVudCksIGJ1dCB3ZSBkb24ndCB3YW50IHRvIGRlZ3JhZGUgdG8gTyhOKSwgaWYgd2Uga25vdyB0aGUgdmlhIGFza2luZyBwZWVyIGdvdCBhbiB1cGRhdGUsIHRoZW4gd2Ugc2hvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGNhbmNlbCB0aGVzZSB0dXJucyBhc2tpbmcgZm9yIGRhdGEuXG5cdFx0Ly8gSWRlYXM6IFNhdmUgYSByYW5kb20gc2VlZCB0aGF0IHNvcnRzIHRoZSByb3V0ZSwgc3RvcmUgaXQgYW5kIHRoZSBpbmRleC4gLy8gT3IgaW5kZXhpbmcgb24gbG93ZXN0IGxhdGVuY3kgaXMgcHJvYmFibHkgYmV0dGVyLlxuXHRcdGNsZWFyVGltZW91dCh0YWcubGFjayk7XG5cdFx0aWYodGFnLmFjayAmJiAodG1wID0gdGFnWycjIyddKSAmJiBtc2dbJyMjJ10gPT09IHRtcCl7IHJldHVybiB9IC8vIGhhc2hlcyBtYXRjaCwgc3RvcCBhc2tpbmcgb3RoZXIgcGVlcnMhXG5cdFx0bmV4dCA9IChPYmplY3QubWFwcyhyb3V0ZXx8b3B0LnBlZXJzKSkuc2xpY2UodHVybiA9IHR1cm4gfHwgMCk7XG5cdFx0aWYoIW5leHQubGVuZ3RoKXtcblx0XHRcdGlmKCFyb3V0ZSl7IHJldHVybiB9IC8vIGFza2VkIGFsbCBwZWVycywgc3RvcCBhc2tpbmchXG5cdFx0XHRHRVQudHVybihtc2csIHUsIDApOyAvLyBhc2tlZCBhbGwgc3Vicywgbm93IG5vdyBhc2sgYW55IHBlZXJzLiAobm90IGFsd2F5cyB0aGUgYmVzdCBpZGVhLCBidXQgc3RheXMgKVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRzZXRUaW1lb3V0LmVhY2gobmV4dCwgZnVuY3Rpb24oaWQpe1xuXHRcdFx0dmFyIHBlZXIgPSBvcHQucGVlcnNbaWRdOyB0dXJuKys7XG5cdFx0XHRpZighcGVlciB8fCAhcGVlci53aXJlKXsgcm91dGUgJiYgcm91dGUuZGVsZXRlKGlkKTsgcmV0dXJuIH0gLy8gYnllISAvLyBUT0RPOiBDSEVDSyBJRiAwIE9USEVSIFBFRVJTICYgVU5TVUJTQ1JJQkVcblx0XHRcdGlmKG1lc2guc2F5KG1zZywgcGVlcikgPT09IGZhbHNlKXsgcmV0dXJuIH0gLy8gd2FzIHNlbGZcblx0XHRcdGlmKDAgPT0gKHR1cm4gJSAzKSl7IHJldHVybiAxIH1cblx0XHR9LCBmdW5jdGlvbigpe1xuXHRcdFx0dGFnWycjIyddID0gbXNnWycjIyddOyAvLyBzaG91bGQgcHJvYmFibHkgc2V0IHRoaXMgaW4gYSBtb3JlIGNsZXZlciBtYW5uZXIsIGRvIGxpdmUgYGluYCBjaGVja3MgKysgLS0sIGV0Yy4gYnV0IGJlaW5nIGxhenkgZm9yIG5vdy4gLy8gVE9ETzogWWVzLCBzZWUgYGluYCBUT0RPLCBjdXJyZW50bHkgdGhpcyBtaWdodCBtYXRjaCBhZ2FpbnN0IG9ubHkgaW4tbWVtIGNhdXNlIG5vIG90aGVyIHBlZXJzIHJlcGx5LCB3aGljaCBpcyBcImZpbmVcIiwgYnV0IGNvdWxkIGNhdXNlIGEgZmFsc2UgcG9zaXRpdmUuXG5cdFx0XHR0YWcubGFjayA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgR0VULnR1cm4obXNnLCByb3V0ZSwgdHVybikgfSwgMjUpO1xuXHRcdH0sIDMpO1xuXHR9XG5cdGZ1bmN0aW9uIGZhbGwobXNnKXsgbWVzaC5zYXkobXNnLCBvcHQucGVlcnMpIH1cblx0ZnVuY3Rpb24gUkVGKG1zZyl7XG5cdFx0dmFyIHJlZiA9ICcnLCBzb3VsLCBoYXMsIHRtcDtcblx0XHRpZighbXNnIHx8ICFtc2cuZ2V0KXsgcmV0dXJuIHJlZiB9XG5cdFx0aWYoJ3N0cmluZycgPT0gdHlwZW9mIChzb3VsID0gbXNnLmdldFsnIyddKSl7IHJlZiA9IHJvb3QuJC5nZXQoc291bCkgfVxuXHRcdGlmKCdzdHJpbmcnID09IHR5cGVvZiAodG1wID0gbXNnLmdldFsnLiddKSl7IGhhcyA9IHRtcCB9IGVsc2UgeyBoYXMgPSAnJyB9XG5cblx0XHR2YXIgdmlhID0gKG1zZy5ffHwnJykudmlhLCBzdWIgPSAodmlhLnN1YiB8fCAodmlhLnN1YiA9IG5ldyBPYmplY3QuTWFwKSk7IChzdWIuZ2V0KHNvdWwpIHx8IChzdWIuc2V0KHNvdWwsIHRtcCA9IG5ldyBPYmplY3QuTWFwKSAmJiB0bXApKS5zZXQoaGFzLCAxKTsgLy8ge3NvdWw6IHsnJzoxLCBoYXM6IDF9fSAvLyBURU1QT1JBUklMWSBSRVZFUlQgQVhFIFRPV0VSIFRZSU5HIFRPIFNVQlNDUklCSU5HIFRPIEVWRVJZVEhJTkcuIFVORE8gVEhJUyFcblx0XHR2aWEuaWQgJiYgcmVmLl8gJiYgKHJlZi5fLnJvdXRlIHx8IChyZWYuXy5yb3V0ZSA9IG5ldyBPYmplY3QuTWFwKSkuc2V0KHZpYS5pZCwgdmlhKTsgLy8gU0FNRSBBUyBeXG5cblx0XHRyZXR1cm4gcmVmO1xuXHR9XG5cdGZ1bmN0aW9uIExFWChsZXgpeyByZXR1cm4gKGxleCA9IGxleCB8fCAnJylbJz0nXSB8fCBsZXhbJyonXSB8fCBsZXhbJz4nXSB8fCBsZXggfVxuXHRcblx0cm9vdC5vbignaW4nLCBmdW5jdGlvbihtc2cpeyB2YXIgdG8gPSB0aGlzLnRvLCB0bXA7XG5cdFx0aWYoKHRtcCA9IG1zZ1snQCddKSAmJiAodG1wID0gZHVwLnNbdG1wXSkpe1xuXHRcdFx0dG1wLmFjayA9ICh0bXAuYWNrIHx8IDApICsgMTsgLy8gY291bnQgcmVtb3RlIEFDS3MgdG8gR0VULiAvLyBUT0RPOiBJZiBtaXNtYXRjaCwgc2hvdWxkIHRyaWdnZXIgbmV4dCBhc2tzLlxuXHRcdFx0aWYodG1wLml0ICYmIHRtcC5pdC5nZXQgJiYgbXNnLnB1dCl7IC8vIFdIRU4gU0VFSU5HIEEgUFVUIFJFUExZIFRPIEEgR0VULi4uXG5cdFx0XHRcdHZhciBnZXQgPSB0bXAuaXQuZ2V0fHwnJywgcmVmID0gUkVGKHRtcC5pdCkuXywgdmlhID0gKHRtcC5pdC5ffHwnJykudmlhfHwnJywgc3ViO1xuXHRcdFx0XHRpZih2aWEgJiYgcmVmKXsgLy8gU1VCU0NSSUJFIFRIRSBQRUVSIFdITyBBU0tFRCBWSUEgRk9SIElUOlxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJTVUJTQ1JJQklOR1wiLCBPYmplY3QubWFwcyhyZWYucm91dGV8fCcnKSwgXCJ0b1wiLCBMRVgoZ2V0WycjJ10pKTtcblx0XHRcdFx0XHR2aWEuaWQgJiYgKHJlZi5yb3V0ZSB8fCAocmVmLnJvdXRlID0gbmV3IE9iamVjdC5NYXApKS5zZXQodmlhLmlkLCB2aWEpO1xuXHRcdFx0XHRcdHN1YiA9ICh2aWEuc3ViIHx8ICh2aWEuc3ViID0gbmV3IE9iamVjdC5NYXApKTtcblx0XHRcdFx0XHRyZWYgJiYgKHN1Yi5nZXQoTEVYKGdldFsnIyddKSkgfHwgKHN1Yi5zZXQoTEVYKGdldFsnIyddKSwgc3ViID0gbmV3IE9iamVjdC5NYXApICYmIHN1YikpLnNldChMRVgoZ2V0WycuJ10pLCAxKTsgLy8ge3NvdWw6IHsnJzoxLCBoYXM6IDF9fVxuXG5cdFx0XHRcdFx0dmlhID0gKG1zZy5ffHwnJykudmlhfHwnJztcblx0XHRcdFx0XHRpZih2aWEpeyAvLyBCSURJUkVDVElPTkFMIFNVQlNDUklCRTogUkVQTElFUiBJUyBOT1cgU1VCU0NSSUJFRC4gRE8gV0UgV0FOVCBUSElTP1xuXHRcdFx0XHRcdFx0dmlhLmlkICYmIChyZWYucm91dGUgfHwgKHJlZi5yb3V0ZSA9IG5ldyBPYmplY3QuTWFwKSkuc2V0KHZpYS5pZCwgdmlhKTtcblx0XHRcdFx0XHRcdHN1YiA9ICh2aWEuc3ViIHx8ICh2aWEuc3ViID0gbmV3IE9iamVjdC5NYXApKTtcblx0XHRcdFx0XHRcdGlmKHJlZil7XG5cdFx0XHRcdFx0XHRcdHZhciBzb3VsID0gTEVYKGdldFsnIyddKSwgc2lmdCA9IHN1Yi5nZXQoc291bCksIGhhcyA9IExFWChnZXRbJy4nXSk7XG5cdFx0XHRcdFx0XHRcdGlmKGhhcyl7XG5cdFx0XHRcdFx0XHRcdFx0KHNpZnQgfHwgKHN1Yi5zZXQoc291bCwgc2lmdCA9IG5ldyBPYmplY3QuTWFwKSAmJiBzaWZ0KSkuc2V0KGhhcywgMSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHRpZighc2lmdCl7XG5cdFx0XHRcdFx0XHRcdFx0c3ViLnNldChzb3VsLCBzaWZ0ID0gbmV3IE9iamVjdC5NYXApO1xuXHRcdFx0XHRcdFx0XHRcdHNpZnQuc2V0KCcnLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoKHRtcCA9IHRtcC5iYWNrKSl7IC8vIGJhY2t0cmFjayBPS3Mgc2luY2UgQVhFIHNwbGl0cyBQVVRzIHVwLlxuXHRcdFx0XHRzZXRUaW1lb3V0LmVhY2goT2JqZWN0LmtleXModG1wKSwgZnVuY3Rpb24oaWQpe1xuXHRcdFx0XHRcdHRvLm5leHQoeycjJzogbXNnWycjJ10sICdAJzogaWQsIG9rOiBtc2cub2t9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0dG8ubmV4dChtc2cpO1xuXHR9KTtcblxuXHRyb290Lm9uKCdjcmVhdGUnLCBmdW5jdGlvbihyb290KXtcblx0XHR0aGlzLnRvLm5leHQocm9vdCk7XG5cdFx0dmFyIFEgPSB7fTtcblx0XHRyb290Lm9uKCdwdXQnLCBmdW5jdGlvbihtc2cpe1xuXHRcdFx0dmFyIGV2ZSA9IHRoaXMsIGF0ID0gZXZlLmFzLCBwdXQgPSBtc2cucHV0LCBzb3VsID0gcHV0WycjJ10sIGhhcyA9IHB1dFsnLiddLCB2YWwgPSBwdXRbJzonXSwgc3RhdGUgPSBwdXRbJz4nXSwgcSwgdG1wO1xuXHRcdFx0ZXZlLnRvLm5leHQobXNnKTtcblx0XHRcdGlmKG1zZ1snQCddKXsgcmV0dXJuIH0gLy8gYWNrcyBzZW5kIGV4aXN0aW5nIGRhdGEsIG5vdCB1cGRhdGVzLCBzbyBubyBuZWVkIHRvIHJlc2VuZCB0byBvdGhlcnMuXG5cdFx0XHRpZighc291bCB8fCAhaGFzKXsgcmV0dXJuIH1cblx0XHRcdHZhciByZWYgPSByb290LiQuZ2V0KHNvdWwpLl8sIHJvdXRlID0gKHJlZnx8JycpLnJvdXRlO1xuXHRcdFx0aWYoIXJvdXRlKXsgcmV0dXJuIH1cblx0XHRcdGlmKHJlZi5za2lwICYmIHJlZi5za2lwLmhhcyA9PSBoYXMpeyByZWYuc2tpcC5ub3cgPSBtc2dbJyMnXTsgcmV0dXJuIH1cblx0XHRcdChyZWYuc2tpcCA9IHtub3c6IG1zZ1snIyddLCBoYXM6IGhhc30pLnRvID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0c2V0VGltZW91dC5lYWNoKE9iamVjdC5tYXBzKHJvdXRlKSwgZnVuY3Rpb24ocGlkKXsgdmFyIHBlZXIsIHRtcDtcblx0XHRcdFx0dmFyIHNraXAgPSByZWYuc2tpcHx8Jyc7IHJlZi5za2lwID0gbnVsbDtcblx0XHRcdFx0aWYoIShwZWVyID0gcm91dGUuZ2V0KHBpZCkpKXsgcmV0dXJuIH1cblx0XHRcdFx0aWYoIXBlZXIud2lyZSl7IHJvdXRlLmRlbGV0ZShwaWQpOyByZXR1cm4gfSAvLyBieWUhXG5cdFx0XHRcdHZhciBzdWIgPSAocGVlci5zdWIgfHwgKHBlZXIuc3ViID0gbmV3IE9iamVjdC5NYXApKS5nZXQoc291bCk7XG5cdFx0XHRcdGlmKCFzdWIpeyByZXR1cm4gfVxuXHRcdFx0XHRpZighc3ViLmdldChoYXMpICYmICFzdWIuZ2V0KCcnKSl7IHJldHVybiB9XG5cdFx0XHRcdHZhciBwdXQgPSBwZWVyLnB1dCB8fCAocGVlci5wdXQgPSB7fSk7XG5cdFx0XHRcdHZhciBub2RlID0gcm9vdC5ncmFwaFtzb3VsXSwgdG1wO1xuXHRcdFx0XHRpZihub2RlICYmIHUgIT09ICh0bXAgPSBub2RlW2hhc10pKXtcblx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlX2lzKG5vZGUsIGhhcyk7XG5cdFx0XHRcdFx0dmFsID0gdG1wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB1dFtzb3VsXSA9IHN0YXRlX2lmeShwdXRbc291bF0sIGhhcywgc3RhdGUsIHZhbCwgc291bCk7XG5cdFx0XHRcdHRtcCA9IGR1cC50cmFjayhwZWVyLm5leHQgPSBwZWVyLm5leHQgfHwgU3RyaW5nLnJhbmRvbSg5KSk7XG5cdFx0XHRcdCh0bXAuYmFjayB8fCAodG1wLmJhY2sgPSB7fSkpWycnKyhza2lwLm5vd3x8bXNnWycjJ10pXSA9IDE7XG5cdFx0XHRcdGlmKHBlZXIudG8peyByZXR1cm4gfVxuXHRcdFx0XHRwZWVyLnRvID0gc2V0VGltZW91dChmdW5jdGlvbigpeyBmbHVzaChwZWVyKSB9LCBvcHQuZ2FwKTtcblx0XHRcdH0pIH0sIDkpO1xuXHRcdH0pO1xuXHR9KTtcblxuXHRmdW5jdGlvbiBmbHVzaChwZWVyKXtcblx0XHR2YXIgbXNnID0geycjJzogcGVlci5uZXh0LCBwdXQ6IHBlZXIucHV0LCBvazogeydAJzogMywgJy8nOiBtZXNoLm5lYXJ9fTsgLy8gQlVHOiBUT0RPOiBzdWIgY291bnQhXG5cdFx0Ly8gVE9ETzogd2hhdCBhYm91dCBEQU0ncyA+PCBkZWR1cD8gQ3VycmVudCB0aGlua2luZyBpcywgZG9uJ3QgdXNlIGl0LCBob3dldmVyLCB5b3UgY291bGQgc3RvcmUgZmlyc3QgbXNnIyAmIGxhdGVzdCBtc2cjLCBhbmQgaWYgaGVyZS4uLiBsYXRlc3QgPT09IGZpcnN0IHRoZW4gbGlrZWx5IGl0IGlzIHRoZSBzYW1lID48IHRoaW5nLCBzbyBpZihmaXJzdE1zZ1snPjwnXVtwZWVyLmlkXSl7IHJldHVybiB9IGRvbid0IHNlbmQuXG5cdFx0cGVlci5uZXh0ID0gcGVlci5wdXQgPSBwZWVyLnRvID0gbnVsbDtcblx0XHRtZXNoLnNheShtc2csIHBlZXIpO1xuXHR9XG5cdHZhciBzdGF0ZV9pZnkgPSBHdW4uc3RhdGUuaWZ5LCBzdGF0ZV9pcyA9IEd1bi5zdGF0ZS5pcztcblxuXHRmdW5jdGlvbiByZWxheVVwKG1zZyl7XG5cdFx0bWVzaC5zYXkobXNnLCBheGUudXApO1xuXHR9XG5cblx0OyhmdW5jdGlvbigpeyAvLyBUSElTIElTIFRIRSBVUCBNT0RVTEU7XG5cdFx0YXhlLnVwID0ge307XG5cdFx0dmFyIGhpID0gbWVzaC5oZWFyWyc/J107IC8vIGxvd2VyLWxldmVsIGludGVncmF0aW9uIHdpdGggREFNISBUaGlzIGlzIGFibm9ybWFsIGJ1dCBoZWxwcyBwZXJmb3JtYW5jZS5cblx0XHRtZXNoLmhlYXJbJz8nXSA9IGZ1bmN0aW9uKG1zZywgcGVlcil7IHZhciBwOyAvLyBkZWR1cGxpY2F0ZSB1bm5lY2Vzc2FyeSBjb25uZWN0aW9uczpcblx0XHRcdGhpKG1zZywgcGVlcik7XG5cdFx0XHRpZighcGVlci5waWQpeyByZXR1cm4gfVxuXHRcdFx0aWYocGVlci5waWQgPT09IG9wdC5waWQpeyBtZXNoLmJ5ZShwZWVyKTsgcmV0dXJuIH0gLy8gaWYgSSBjb25uZWN0ZWQgdG8gbXlzZWxmLCBkcm9wLlxuXHRcdFx0aWYocCA9IGF4ZS51cFtwZWVyLnBpZF0peyAvLyBpZiB3ZSBib3RoIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyLi4uXG5cdFx0XHRcdGlmKHAgPT09IHBlZXIpeyByZXR1cm4gfSAvLyBkbyBub3RoaW5nIGlmIG5vIGNvbmZsaWN0LFxuXHRcdFx0XHRpZihvcHQucGlkID4gcGVlci5waWQpeyAvLyBlbHNlIGRldGVybWluaXN0aWNhbGx5IHNvcnRcblx0XHRcdFx0XHRwID0gcGVlcjsgLy8gc28gd2Ugd2lsbCB3aW5kIHVwIGNob29zaW5nIHRoZSBzYW1lIHRvIGtlZXBcblx0XHRcdFx0XHRwZWVyID0gYXhlLnVwW3AucGlkXTsgLy8gYW5kIHRoZSBzYW1lIHRvIGRyb3AuXG5cdFx0XHRcdH1cblx0XHRcdFx0cC51cmwgPSBwLnVybCB8fCBwZWVyLnVybDsgLy8gY29weSBpZiBub3Rcblx0XHRcdFx0bWVzaC5ieWUocGVlcik7IC8vIGRyb3Bcblx0XHRcdFx0YXhlLnVwW3AucGlkXSA9IHA7IC8vIHVwZGF0ZSBzYW1lIHRvIGJlIHNhbWUuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCFwZWVyLnVybCl7IHJldHVybiB9XG5cdFx0XHRheGUudXBbcGVlci5waWRdID0gcGVlcjtcblx0XHRcdGlmKGF4ZS5zdGF5KXsgYXhlLnN0YXkoKSB9XG5cdFx0fTtcblxuXHRcdG1lc2guaGVhclsnb3B0J10gPSBmdW5jdGlvbihtc2csIHBlZXIpe1xuXHRcdFx0aWYobXNnLm9rKXsgcmV0dXJuIH1cblx0XHRcdHZhciB0bXAgPSBtc2cub3B0O1xuXHRcdFx0aWYoIXRtcCl7IHJldHVybiB9XG5cdFx0XHR0bXAgPSB0bXAucGVlcnM7XG5cdFx0XHRpZighdG1wIHx8ICdzdHJpbmcnICE9IHR5cGVvZiB0bXApeyByZXR1cm4gfVxuXHRcdFx0aWYoOTkgPD0gT2JqZWN0LmtleXMoYXhlLnVwKS5sZW5ndGgpeyByZXR1cm4gfSAvLyA5OSBURU1QT1JBUklMWSBVTlRJTCBCRU5DSE1BUktFRCFcblx0XHRcdG1lc2guaGkoe2lkOiB0bXAsIHVybDogdG1wLCByZXRyeTogOX0pO1xuXHRcdFx0aWYocGVlcil7IG1lc2guc2F5KHtkYW06ICdvcHQnLCBvazogMSwgJ0AnOiBtc2dbJyMnXX0sIHBlZXIpIH1cblx0XHR9XG5cblx0XHRheGUuc3RheSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRjbGVhclRpbWVvdXQoYXhlLnN0YXkudG8pO1xuXHRcdFx0YXhlLnN0YXkudG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKHRtcCwgdXJscyl7XG5cdFx0XHRcdGlmKCEodG1wID0gcm9vdC5zdGF0cyAmJiByb290LnN0YXRzLnN0YXkpKXsgcmV0dXJuIH1cblx0XHRcdFx0dXJscyA9IHt9OyBPYmplY3Qua2V5cyhheGUudXB8fCcnKS5mb3JFYWNoKGZ1bmN0aW9uKHApe1xuXHRcdFx0XHRcdHAgPSAoYXhlLnVwfHwnJylbcF07IGlmKHAudXJsKXsgdXJsc1twLnVybF0gPSB7fSB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQodG1wLmF4ZSA9IHRtcC5heGUgfHwge30pLnVwID0gdXJscztcblx0XHRcdH0sIDEwMDAgKiA5KTsvLzEwMDAgKiA2MCk7XG5cdFx0fTtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKHRtcCl7XG5cdFx0XHRpZighKHRtcCA9IHJvb3Quc3RhdHMgJiYgcm9vdC5zdGF0cy5zdGF5ICYmIHJvb3Quc3RhdHMuc3RheS5heGUpKXsgcmV0dXJuIH1cblx0XHRcdGlmKCEodG1wID0gdG1wLnVwKSl7IHJldHVybiB9XG5cdFx0XHRpZighKHRtcCBpbnN0YW5jZW9mIEFycmF5KSl7IHRtcCA9IE9iamVjdC5rZXlzKHRtcCkgfVxuXHRcdFx0c2V0VGltZW91dC5lYWNoKHRtcHx8W10sIGZ1bmN0aW9uKHVybCl7IG1lc2guaGVhci5vcHQoe29wdDoge3BlZXJzOiB1cmx9fSkgfSk7XG5cdFx0fSwxMDAwKTtcblx0fSgpKTtcblxuXHQ7KGZ1bmN0aW9uKCl7IC8vIFRISVMgSVMgVEhFIE1PQiBNT0RVTEU7XG5cdFx0Ly9yZXR1cm47IC8vIFdPUksgSU4gUFJPR1JFU1MsIFRFU1QgRklOQUxJWkVELCBORUVEIFRPIE1BS0UgU1RBQkxFLlxuXHRcdC8qXG5cdFx0XHRBWEUgc2hvdWxkIGhhdmUgYSBjb3VwbGUgb2YgdGhyZXNob2xkIGl0ZW1zLi4uXG5cdFx0XHRsZXQncyBwcmV0ZW5kIHRoZXJlIGlzIGEgdmFyaWFibGUgbWF4IHBlZXJzIGNvbm5lY3RlZFxuXHRcdFx0bW9iID0gMTAwMDBcblx0XHRcdGlmIHdlIGdldCBtb3JlIHBlZXJzIHRoYW4gdGhhdC4uLlxuXHRcdFx0d2Ugc2hvdWxkIHN0YXJ0IHNlbmRpbmcgdGhvc2UgcGVlcnMgYSByZW1vdGUgY29tbWFuZFxuXHRcdFx0dGhhdCB0aGV5IHNob3VsZCBjb25uZWN0IHRvIHRoaXMgb3IgdGhhdCBvdGhlciBwZWVyXG5cdFx0XHRhbmQgdGhlbiBvbmNlIHRoZXkgKG9yIGJlZm9yZSB0aGV5IGRvPykgZHJvcCB0aGVtIGZyb20gdXMuXG5cdFx0XHRzYWtlIG9mIHRoZSB0ZXN0Li4uIGdvbm5hIHNldCB0aGF0IHBlZXIgbnVtYmVyIHRvIDEuXG5cdFx0XHRUaGUgbW9iIHRocmVzaG9sZCBtaWdodCBiZSBkZXRlcm1pbmVkIGJ5IG90aGVyIGZhY3RvcnMsXG5cdFx0XHRsaWtlIGhvdyBtdWNoIFJBTSBvciBDUFUgc3RyZXNzIHdlIGhhdmUuXG5cdFx0Ki9cblx0XHRvcHQubW9iID0gb3B0Lm1vYiB8fCA5OTAwOyAvLyBzaG91bGQgYmUgYmFzZWQgb24gdWxpbWl0LCBzb21lIGNsb3VkcyBhcyBsb3cgYXMgMTBLLlxuXG5cdFx0Ly8gaGFuZGxlIHJlYmFsYW5jaW5nIGEgbW9iIG9mIHBlZXJzOlxuXHRcdHJvb3Qub24oJ2hpJywgZnVuY3Rpb24ocGVlcil7XG5cdFx0XHR0aGlzLnRvLm5leHQocGVlcik7XG5cdFx0XHRpZihwZWVyLnVybCl7IHJldHVybiB9IC8vIEkgYW0gYXNzdW1pbmcgdGhhdCBpZiB3ZSBhcmUgd2FudGluZyB0byBtYWtlIGFuIG91dGJvdW5kIGNvbm5lY3Rpb24gdG8gdGhlbSwgdGhhdCB3ZSBkb24ndCBldmVyIHdhbnQgdG8gZHJvcCB0aGVtIHVubGVzcyBvdXIgYWN0dWFsIGNvbmZpZyBzZXR0aW5ncyBjaGFuZ2UuXG5cdFx0XHR2YXIgY291bnQgPSAvKk9iamVjdC5rZXlzKG9wdC5wZWVycykubGVuZ3RoIHx8Ki8gbWVzaC5uZWFyOyAvLyBUT0RPOiBCVUchIFRoaXMgaXMgc2xvdywgdXNlIC5uZWFyLCBidXQgbmVhciBpcyBidWdneSByaWdodCBub3csIGZpeCBpbiBEQU0uXG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiYXJlIHdlIG1vYmJlZD9cIiwgb3B0Lm1vYiwgT2JqZWN0LmtleXMob3B0LnBlZXJzKS5sZW5ndGgsIG1lc2gubmVhcik7XG5cdFx0XHRpZihvcHQubW9iID49IGNvdW50KXsgcmV0dXJuIH0gIC8vIFRPRE86IE1ha2UgZHluYW1pYyBiYXNlZCBvbiBSQU0vQ1BVIGFsc28uIE9yIHBvc3NpYmx5IGV2ZW4gd2VpcmQgc3R1ZmYgbGlrZSBvcHQubW9iIC8gYXhlLnVwIGxlbmd0aD9cblx0XHRcdHZhciBwZWVycyA9IHt9O09iamVjdC5rZXlzKGF4ZS51cCkuZm9yRWFjaChmdW5jdGlvbihwKXsgcCA9IGF4ZS51cFtwXTsgcC51cmwgJiYgKHBlZXJzW3AudXJsXT17fSkgfSk7XG5cdFx0XHQvLyBUT0RPOiBCVUchISEgSW5maW5pdGUgcmVjb25uZWN0aW9uIGxvb3AgaGFwcGVucyBpZiBub3QgZW5vdWdoIHJlbGF5cywgb3IgaWYgc29tZSBhcmUgbWlzc2luZy4gRm9yIGluc3RhbmNlLCA6ODc2NiBzYXlzIHRvIGNvbm5lY3QgdG8gOjg3Njcgd2hpY2ggdGhlbiBzYXlzIHRvIGNvbm5lY3QgdG8gOjg3NjYuIFRvIG5vdCBERG9TIHdoZW4gc3lzdGVtIG92ZXJsb2FkLCBmaWd1cmUgY2xldmVyIHdheSB0byB0ZWxsIHBlZXJzIHRvIHJldHJ5IGxhdGVyLCB0aGF0IG5ldHdvcmsgZG9lcyBub3QgaGF2ZSBlbm91Z2ggY2FwYWNpdHk/XG5cdFx0XHRtZXNoLnNheSh7ZGFtOiAnbW9iJywgbW9iOiBjb3VudCwgcGVlcnM6IHBlZXJzfSwgcGVlcik7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IG1lc2guYnllKHBlZXIpIH0sIDkpOyAvLyBzb21ldGhpbmcgd2l0aCBiZXR0ZXIgcGVyZj9cblx0XHR9KTtcblx0XHRyb290Lm9uKCdieWUnLCBmdW5jdGlvbihwZWVyKXtcblx0XHRcdHRoaXMudG8ubmV4dChwZWVyKTtcblx0XHR9KTtcblxuXHR9KCkpO1xufVxuXG47KGZ1bmN0aW9uKCl7XG5cdHZhciBmcm9tID0gQXJyYXkuZnJvbTtcblx0T2JqZWN0Lm1hcHMgPSBmdW5jdGlvbihvKXtcblx0XHRpZihmcm9tICYmIG8gaW5zdGFuY2VvZiBNYXApeyByZXR1cm4gZnJvbShvLmtleXMoKSkgfVxuXHRcdGlmKG8gaW5zdGFuY2VvZiBPYmplY3QuTWFwKXsgbyA9IG8ucyB9XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKG8pO1xuXHR9XG5cdGlmKGZyb20peyByZXR1cm4gT2JqZWN0Lk1hcCA9IE1hcCB9XG5cdChPYmplY3QuTWFwID0gZnVuY3Rpb24oKXsgdGhpcy5zID0ge30gfSkucHJvdG90eXBlID0ge3NldDpmdW5jdGlvbihrLHYpe3RoaXMuc1trXT12O3JldHVybiB0aGlzfSxnZXQ6ZnVuY3Rpb24oayl7cmV0dXJuIHRoaXMuc1trXX0sZGVsZXRlOmZ1bmN0aW9uKGspe2RlbGV0ZSB0aGlzLnNba119fTtcbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/axe.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/multicast.js":
/*!*******************************************!*\
  !*** ./node_modules/gun/lib/multicast.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var Gun = (typeof window !== \"undefined\")? window.Gun : __webpack_require__(/*! ../gun */ \"(ssr)/./node_modules/gun/gun.js\");\n\nGun.on('create', function(root){\n\tthis.to.next(root);\n\tvar opt = root.opt;\n  if(false === opt.multicast){ return }\n  if((typeof process !== \"undefined\") && 'false' === ''+(process.env||{}).MULTICAST){ return }\n\t//if(true !== opt.multicast){ return } // disable multicast by default for now.\n\n  var udp = opt.multicast = opt.multicast || {};\n  udp.address = udp.address || '233.255.255.255';\n  udp.pack = udp.pack || 50000; // UDP messages limited to 65KB.\n  udp.port  = udp.port || 8765;\n\n  var noop = function(){}, u;\n  var pid = '2'+Math.random().toString().slice(-8);\n  var mesh = opt.mesh = opt.mesh || Gun.Mesh(root);\n  var dgram;\n\n  try{ dgram = __webpack_require__(/*! dgram */ \"dgram\") }catch(e){ return }\n  var socket = dgram.createSocket({type: \"udp4\", reuseAddr: true});\n  socket.bind({port: udp.port, exclusive: true}, function(){\n    socket.setBroadcast(true);\n    socket.setMulticastTTL(128);\n  });\n\n  socket.on(\"listening\", function(){\n    try { socket.addMembership(udp.address) }catch(e){ console.error(e); return; }\n    udp.peer = {id: udp.address + ':' + udp.port, wire: socket};\n\n    udp.peer.say = function(raw){\n      var buf = Buffer.from(raw, 'utf8');\n      if(udp.pack <= buf.length){ // message too big!!!\n        return;\n      }\n      socket.send(buf, 0, buf.length, udp.port, udp.address, noop);\n    }\n    //opt.mesh.hi(udp.peer);\n\n    Gun.log.once('multi', 'Multicast on '+udp.peer.id);\n    return; // below code only needed for when WebSocket connections desired!\n    setInterval(function broadcast(){\n      port = port || (opt.web && opt.web.address()||{}).port;\n      if(!port){ return }\n      udp.peer.say(JSON.stringify({id: opt.pid || (opt.pid = Math.random().toString(36).slice(2)), port: port}));\n    }, 1000);\n  });\n\n  socket.on(\"message\", function(raw, info) { try {\n    if(!raw){ return }\n    raw = raw.toString('utf8');\n    if('2'===raw[0]){ return check(raw, info) }\n    opt.mesh.hear(raw, udp.peer);\n\n    return; // below code only needed for when WebSocket connections desired!\n    var message;\n    message = JSON.parse(raw.toString('utf8'));\n\n    if(opt.pid === message.id){ return } // ignore self\n\n    var url = 'http://' + info.address + ':' + (port || (opt.web && opt.web.address()||{}).port) + '/gun';\n    if(root.opt.peers[url]){ return }\n\n    //console.log('discovered', url, message, info);\n    root.$.opt(url);\n\n  } catch(e){\n    //console.log('multicast error', e, raw);\n    return;\n  } });\n\n  function say(msg){\n    this.to.next(msg);\n    if(!udp.peer){ return }\n    mesh.say(msg, udp.peer);\n  }\n\n  function check(id, info){ var tmp;\n    if(!udp.peer){ return }\n    if(!id){\n      id = check.id = check.id || Buffer.from(pid, 'utf8');\n      socket.send(id, 0, id.length, udp.port, udp.address, noop);\n      return;\n    }\n    if((tmp = root.stats) && (tmp = tmp.gap) && info){ (tmp.near || (tmp.near = {}))[info.address] = info.port || 1 } // STATS!\n    if(check.on || id === pid){ return }\n    root.on('out', check.on = say); // TODO: MULTICAST NEEDS TO BE CHECKED FOR NEW CODE SYSTEM!!!!!!!!!! // TODO: This approach seems interferes with other relays, below does not but...\n    //opt.mesh.hi(udp.peer); //  IS THIS CORRECT?\n  }\n\n  setInterval(check, 1000 * 1);\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9tdWx0aWNhc3QuanMiLCJtYXBwaW5ncyI6IkFBQUEsd0RBQXdELG1CQUFPLENBQUMsK0NBQVE7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix3RUFBd0UsY0FBYztBQUN0RiwrQkFBK0IsU0FBUzs7QUFFeEM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBLE9BQU8sUUFBUSxtQkFBTyxDQUFDLG9CQUFPLEdBQUcsVUFBVTtBQUMzQyxtQ0FBbUMsOEJBQThCO0FBQ2pFLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsVUFBVSxtQ0FBbUMsVUFBVSxrQkFBa0I7QUFDekUsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQSxzREFBc0Q7QUFDdEQsaUJBQWlCO0FBQ2pCLG1DQUFtQywyRUFBMkU7QUFDOUcsS0FBSztBQUNMLEdBQUc7O0FBRUgsNkNBQTZDO0FBQzdDLGNBQWM7QUFDZDtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQSxnQ0FBZ0MsU0FBUzs7QUFFekMseUZBQXlGO0FBQ3pGLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkIsb0NBQW9DO0FBQ3RILGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIzLWNoYXQvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9tdWx0aWNhc3QuanM/NzJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgR3VuID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpPyB3aW5kb3cuR3VuIDogcmVxdWlyZSgnLi4vZ3VuJyk7XG5cbkd1bi5vbignY3JlYXRlJywgZnVuY3Rpb24ocm9vdCl7XG5cdHRoaXMudG8ubmV4dChyb290KTtcblx0dmFyIG9wdCA9IHJvb3Qub3B0O1xuICBpZihmYWxzZSA9PT0gb3B0Lm11bHRpY2FzdCl7IHJldHVybiB9XG4gIGlmKCh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikgJiYgJ2ZhbHNlJyA9PT0gJycrKHByb2Nlc3MuZW52fHx7fSkuTVVMVElDQVNUKXsgcmV0dXJuIH1cblx0Ly9pZih0cnVlICE9PSBvcHQubXVsdGljYXN0KXsgcmV0dXJuIH0gLy8gZGlzYWJsZSBtdWx0aWNhc3QgYnkgZGVmYXVsdCBmb3Igbm93LlxuXG4gIHZhciB1ZHAgPSBvcHQubXVsdGljYXN0ID0gb3B0Lm11bHRpY2FzdCB8fCB7fTtcbiAgdWRwLmFkZHJlc3MgPSB1ZHAuYWRkcmVzcyB8fCAnMjMzLjI1NS4yNTUuMjU1JztcbiAgdWRwLnBhY2sgPSB1ZHAucGFjayB8fCA1MDAwMDsgLy8gVURQIG1lc3NhZ2VzIGxpbWl0ZWQgdG8gNjVLQi5cbiAgdWRwLnBvcnQgID0gdWRwLnBvcnQgfHwgODc2NTtcblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCl7fSwgdTtcbiAgdmFyIHBpZCA9ICcyJytNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc2xpY2UoLTgpO1xuICB2YXIgbWVzaCA9IG9wdC5tZXNoID0gb3B0Lm1lc2ggfHwgR3VuLk1lc2gocm9vdCk7XG4gIHZhciBkZ3JhbTtcblxuICB0cnl7IGRncmFtID0gcmVxdWlyZShcImRncmFtXCIpIH1jYXRjaChlKXsgcmV0dXJuIH1cbiAgdmFyIHNvY2tldCA9IGRncmFtLmNyZWF0ZVNvY2tldCh7dHlwZTogXCJ1ZHA0XCIsIHJldXNlQWRkcjogdHJ1ZX0pO1xuICBzb2NrZXQuYmluZCh7cG9ydDogdWRwLnBvcnQsIGV4Y2x1c2l2ZTogdHJ1ZX0sIGZ1bmN0aW9uKCl7XG4gICAgc29ja2V0LnNldEJyb2FkY2FzdCh0cnVlKTtcbiAgICBzb2NrZXQuc2V0TXVsdGljYXN0VFRMKDEyOCk7XG4gIH0pO1xuXG4gIHNvY2tldC5vbihcImxpc3RlbmluZ1wiLCBmdW5jdGlvbigpe1xuICAgIHRyeSB7IHNvY2tldC5hZGRNZW1iZXJzaGlwKHVkcC5hZGRyZXNzKSB9Y2F0Y2goZSl7IGNvbnNvbGUuZXJyb3IoZSk7IHJldHVybjsgfVxuICAgIHVkcC5wZWVyID0ge2lkOiB1ZHAuYWRkcmVzcyArICc6JyArIHVkcC5wb3J0LCB3aXJlOiBzb2NrZXR9O1xuXG4gICAgdWRwLnBlZXIuc2F5ID0gZnVuY3Rpb24ocmF3KXtcbiAgICAgIHZhciBidWYgPSBCdWZmZXIuZnJvbShyYXcsICd1dGY4Jyk7XG4gICAgICBpZih1ZHAucGFjayA8PSBidWYubGVuZ3RoKXsgLy8gbWVzc2FnZSB0b28gYmlnISEhXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNvY2tldC5zZW5kKGJ1ZiwgMCwgYnVmLmxlbmd0aCwgdWRwLnBvcnQsIHVkcC5hZGRyZXNzLCBub29wKTtcbiAgICB9XG4gICAgLy9vcHQubWVzaC5oaSh1ZHAucGVlcik7XG5cbiAgICBHdW4ubG9nLm9uY2UoJ211bHRpJywgJ011bHRpY2FzdCBvbiAnK3VkcC5wZWVyLmlkKTtcbiAgICByZXR1cm47IC8vIGJlbG93IGNvZGUgb25seSBuZWVkZWQgZm9yIHdoZW4gV2ViU29ja2V0IGNvbm5lY3Rpb25zIGRlc2lyZWQhXG4gICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gYnJvYWRjYXN0KCl7XG4gICAgICBwb3J0ID0gcG9ydCB8fCAob3B0LndlYiAmJiBvcHQud2ViLmFkZHJlc3MoKXx8e30pLnBvcnQ7XG4gICAgICBpZighcG9ydCl7IHJldHVybiB9XG4gICAgICB1ZHAucGVlci5zYXkoSlNPTi5zdHJpbmdpZnkoe2lkOiBvcHQucGlkIHx8IChvcHQucGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMikpLCBwb3J0OiBwb3J0fSkpO1xuICAgIH0sIDEwMDApO1xuICB9KTtcblxuICBzb2NrZXQub24oXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKHJhdywgaW5mbykgeyB0cnkge1xuICAgIGlmKCFyYXcpeyByZXR1cm4gfVxuICAgIHJhdyA9IHJhdy50b1N0cmluZygndXRmOCcpO1xuICAgIGlmKCcyJz09PXJhd1swXSl7IHJldHVybiBjaGVjayhyYXcsIGluZm8pIH1cbiAgICBvcHQubWVzaC5oZWFyKHJhdywgdWRwLnBlZXIpO1xuXG4gICAgcmV0dXJuOyAvLyBiZWxvdyBjb2RlIG9ubHkgbmVlZGVkIGZvciB3aGVuIFdlYlNvY2tldCBjb25uZWN0aW9ucyBkZXNpcmVkIVxuICAgIHZhciBtZXNzYWdlO1xuICAgIG1lc3NhZ2UgPSBKU09OLnBhcnNlKHJhdy50b1N0cmluZygndXRmOCcpKTtcblxuICAgIGlmKG9wdC5waWQgPT09IG1lc3NhZ2UuaWQpeyByZXR1cm4gfSAvLyBpZ25vcmUgc2VsZlxuXG4gICAgdmFyIHVybCA9ICdodHRwOi8vJyArIGluZm8uYWRkcmVzcyArICc6JyArIChwb3J0IHx8IChvcHQud2ViICYmIG9wdC53ZWIuYWRkcmVzcygpfHx7fSkucG9ydCkgKyAnL2d1bic7XG4gICAgaWYocm9vdC5vcHQucGVlcnNbdXJsXSl7IHJldHVybiB9XG5cbiAgICAvL2NvbnNvbGUubG9nKCdkaXNjb3ZlcmVkJywgdXJsLCBtZXNzYWdlLCBpbmZvKTtcbiAgICByb290LiQub3B0KHVybCk7XG5cbiAgfSBjYXRjaChlKXtcbiAgICAvL2NvbnNvbGUubG9nKCdtdWx0aWNhc3QgZXJyb3InLCBlLCByYXcpO1xuICAgIHJldHVybjtcbiAgfSB9KTtcblxuICBmdW5jdGlvbiBzYXkobXNnKXtcbiAgICB0aGlzLnRvLm5leHQobXNnKTtcbiAgICBpZighdWRwLnBlZXIpeyByZXR1cm4gfVxuICAgIG1lc2guc2F5KG1zZywgdWRwLnBlZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2soaWQsIGluZm8peyB2YXIgdG1wO1xuICAgIGlmKCF1ZHAucGVlcil7IHJldHVybiB9XG4gICAgaWYoIWlkKXtcbiAgICAgIGlkID0gY2hlY2suaWQgPSBjaGVjay5pZCB8fCBCdWZmZXIuZnJvbShwaWQsICd1dGY4Jyk7XG4gICAgICBzb2NrZXQuc2VuZChpZCwgMCwgaWQubGVuZ3RoLCB1ZHAucG9ydCwgdWRwLmFkZHJlc3MsIG5vb3ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZigodG1wID0gcm9vdC5zdGF0cykgJiYgKHRtcCA9IHRtcC5nYXApICYmIGluZm8peyAodG1wLm5lYXIgfHwgKHRtcC5uZWFyID0ge30pKVtpbmZvLmFkZHJlc3NdID0gaW5mby5wb3J0IHx8IDEgfSAvLyBTVEFUUyFcbiAgICBpZihjaGVjay5vbiB8fCBpZCA9PT0gcGlkKXsgcmV0dXJuIH1cbiAgICByb290Lm9uKCdvdXQnLCBjaGVjay5vbiA9IHNheSk7IC8vIFRPRE86IE1VTFRJQ0FTVCBORUVEUyBUTyBCRSBDSEVDS0VEIEZPUiBORVcgQ09ERSBTWVNURU0hISEhISEhISEhIC8vIFRPRE86IFRoaXMgYXBwcm9hY2ggc2VlbXMgaW50ZXJmZXJlcyB3aXRoIG90aGVyIHJlbGF5cywgYmVsb3cgZG9lcyBub3QgYnV0Li4uXG4gICAgLy9vcHQubWVzaC5oaSh1ZHAucGVlcik7IC8vICBJUyBUSElTIENPUlJFQ1Q/XG4gIH1cblxuICBzZXRJbnRlcnZhbChjaGVjaywgMTAwMCAqIDEpO1xuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/multicast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/radisk.js":
/*!****************************************!*\
  !*** ./node_modules/gun/lib/radisk.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(";(function(){\n\n\tfunction Radisk(opt){\n\n\t\topt = opt || {};\n\t\topt.log = opt.log || console.log;\n\t\topt.file = String(opt.file || 'radata');\n\t\tvar has = (Radisk.has || (Radisk.has = {}))[opt.file];\n\t\tif(has){ return has }\n\n\t\topt.max = opt.max || (opt.memory? (opt.memory * 999 * 999) : 300000000) * 0.3;\n\t\topt.until = opt.until || opt.wait || 250;\n\t\topt.batch = opt.batch || (10 * 1000);\n\t\topt.chunk = opt.chunk || (1024 * 1024 * 1); // 1MB\n\t\topt.code = opt.code || {};\n\t\topt.code.from = opt.code.from || '!';\n\t\topt.jsonify = true;\n\n\n\t\tfunction ename(t){ return encodeURIComponent(t).replace(/\\*/g, '%2A') } // TODO: Hash this also, but allow migration!\n\t\tfunction atomic(v){ return u !== v && (!v || 'object' != typeof v) }\n\t\tvar timediate = (''+u === typeof setImmediate)? setTimeout : setImmediate;\n\t\tvar puff = setTimeout.turn || timediate, u;\n\t\tvar map = Radix.object;\n\t\tvar ST = 0;\n\n\t\tif(!opt.store){\n\t\t\treturn opt.log(\"ERROR: Radisk needs `opt.store` interface with `{get: fn, put: fn (, list: fn)}`!\");\n\t\t}\n\t\tif(!opt.store.put){\n\t\t\treturn opt.log(\"ERROR: Radisk needs `store.put` interface with `(file, data, cb)`!\");\n\t\t}\n\t\tif(!opt.store.get){\n\t\t\treturn opt.log(\"ERROR: Radisk needs `store.get` interface with `(file, cb)`!\");\n\t\t}\n\t\tif(!opt.store.list){\n\t\t\t//opt.log(\"WARNING: `store.list` interface might be needed!\");\n\t\t}\n\n\t\tif(''+u != \"function\"){ __webpack_require__(/*! ./yson */ \"(ssr)/./node_modules/gun/lib/yson.js\") }\n\t\tvar parse = JSON.parseAsync || function(t,cb,r){ var u; try{ cb(u, JSON.parse(t,r)) }catch(e){ cb(e) } }\n\t\tvar json = JSON.stringifyAsync || function(v,cb,r,s){ var u; try{ cb(u, JSON.stringify(v,r,s)) }catch(e){ cb(e) } }\n\t\t/*\n\t\t\tAny and all storage adapters should...\n\t\t\t1. Because writing to disk takes time, we should batch data to disk. This improves performance, and reduces potential disk corruption.\n\t\t\t2. If a batch exceeds a certain number of writes, we should immediately write to disk when physically possible. This caps total performance, but reduces potential loss.\n\t\t*/\n\t\tvar r = function(key, data, cb, tag, DBG){\n\t\t\tif('function' === typeof data){\n\t\t\t\tvar o = cb || {};\n\t\t\t\tcb = data;\n\t\t\t\tr.read(key, cb, o, DBG || tag);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//var tmp = (tmp = r.batch = r.batch || {})[key] = tmp[key] || {};\n\t\t\t//var tmp = (tmp = r.batch = r.batch || {})[key] = data;\n\t\t\tr.save(key, data, cb, tag, DBG);\n\t\t}\n\t\tr.save = function(key, data, cb, tag, DBG){\n\t\t\tvar s = {key: key}, tags, f, d, q;\n\t\t\ts.find = function(file){ var tmp;\n\t\t\t\ts.file = file || (file = opt.code.from);\n\t\t\t\tDBG && (DBG = DBG[file] = DBG[file] || {});\n\t\t\t\tDBG && (DBG.sf = DBG.sf || +new Date);\n\t\t\t\t//console.only.i && console.log('found', file);\n\t\t\t\tif(tmp = r.disk[file]){ s.mix(u, tmp); return }\n\t\t\t\tr.parse(file, s.mix, u, DBG);\n\t\t\t}\n\t\t\ts.mix = function(err, disk){\n\t\t\t\tDBG && (DBG.sml = +new Date);\n\t\t\t\tDBG && (DBG.sm = DBG.sm || +new Date);\n\t\t\t\tif(s.err = err || s.err){ cb(err); return } // TODO: HANDLE BATCH EMIT\n\t\t\t\tvar file = s.file = (disk||'').file || s.file, tmp;\n\t\t\t\tif(!disk && file !== opt.code.from){ // corrupt file?\n\t\t\t\t\tr.find.bad(file); // remove from dir list\n\t\t\t\t\tr.save(key, data, cb, tag); // try again\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t(disk = r.disk[file] || (r.disk[file] = disk || Radix())).file || (disk.file = file);\n\t\t\t\tif(opt.compare){\n\t\t\t\t\tdata = opt.compare(disk(key), data, key, file);\n\t\t\t\t\tif(u === data){ cb(err, -1); return } // TODO: HANDLE BATCH EMIT\n\t\t\t\t}\n\t\t\t\t(s.disk = disk)(key, data);\n\t\t\t\tif(tag){\n\t\t\t\t\t(tmp = (tmp = disk.tags || (disk.tags = {}))[tag] || (tmp[tag] = r.tags[tag] || (r.tags[tag] = {})))[file] || (tmp[file] = r.one[tag] || (r.one[tag] = cb));\n\t\t\t\t\tcb = null;\n\t\t\t\t}\n\t\t\t\tDBG && (DBG.st = DBG.st || +new Date);\n\t\t\t\t//console.only.i && console.log('mix', disk.Q);\n\t\t\t\tif(disk.Q){ cb && disk.Q.push(cb); return } disk.Q = (cb? [cb] : []);\n\t\t\t\tdisk.to = setTimeout(s.write, opt.until);\n\t\t\t}\n\t\t\ts.write = function(){\n\t\t\t\tDBG && (DBG.sto = DBG.sto || +new Date);\n\t\t\t\tvar file = f = s.file, disk = d = s.disk;\n\t\t\t\tq = s.q = disk.Q;\n\t\t\t\ttags = s.tags = disk.tags;\n\t\t\t\tdelete disk.Q;\n\t\t\t\tdelete r.disk[file];\n\t\t\t\tdelete disk.tags;\n\t\t\t\t//console.only.i && console.log('write', file, disk, 'was saving:', key, data);\n\t\t\t\tr.write(file, disk, s.ack, u, DBG);\n\t\t\t}\n\t\t\ts.ack = function(err, ok){\n\t\t\t\tDBG && (DBG.sa = DBG.sa || +new Date);\n\t\t\t\tDBG && (DBG.sal = q.length);\n\t\t\t\tvar ack, tmp;\n\t\t\t\t// TODO!!!! CHANGE THIS INTO PUFF!!!!!!!!!!!!!!!!\n\t\t\t\tfor(var id in r.tags){\n\t\t\t\t\tif(!r.tags.hasOwnProperty(id)){ continue } var tag = r.tags[id];\n\t\t\t\t\tif((tmp = r.disk[f]) && (tmp = tmp.tags) && tmp[tag]){ continue }\n\t\t\t\t\tack = tag[f];\n\t\t\t\t\tdelete tag[f];\n\t\t\t\t\tvar ne; for(var k in tag){ if(tag.hasOwnProperty(k)){ ne = true; break } } // is not empty?\n\t\t\t\t\tif(ne){ continue } //if(!obj_empty(tag)){ continue }\n\t\t\t\t\tdelete r.tags[tag];\n\t\t\t\t\tack && ack(err, ok);\n\t\t\t\t}\n\t\t\t\t!q && (q = '');\n\t\t\t\tvar l = q.length, i = 0;\n\t\t\t\t// TODO: PERF: Why is acks so slow, what work do they do??? CHECK THIS!!\n\t\t\t\t// TODO: PERF: Why is acks so slow, what work do they do??? CHECK THIS!!\n\t\t\t\t// TODO: PERF: Why is acks so slow, what work do they do??? CHECK THIS!!\n\t\t\t\t// TODO: PERF: Why is acks so slow, what work do they do??? CHECK THIS!!\n\t\t\t\t// TODO: PERF: Why is acks so slow, what work do they do??? CHECK THIS!!\n\t\t\t\t// TODO: PERF: Why is acks so slow, what work do they do??? CHECK THIS!!\n\t\t\t\t// TODO: PERF: Why is acks so slow, what work do they do??? CHECK THIS!!\n\t\t\t\tvar S = +new Date;\n\t\t\t\tfor(;i < l; i++){ (ack = q[i]) && ack(err, ok) }\n\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'rad acks', ename(s.file));\n\t\t\t\tconsole.STAT && console.STAT(S, q.length, 'rad acks #', ename(s.file));\n\t\t\t}\n\t\t\tcb || (cb = function(err, ok){ // test delete!\n\t\t\t\tif(!err){ return }\n\t\t\t});\n\t\t\t//console.only.i && console.log('save', key);\n\t\t\tr.find(key, s.find);\n    }\n    r.disk = {};\n    r.one = {};\n    r.tags = {};\n\n\t\t/*\n\t\t\tAny storage engine at some point will have to do a read in order to write.\n\t\t\tThis is true of even systems that use an append only log, if they support updates.\n\t\t\tTherefore it is unavoidable that a read will have to happen,\n\t\t\tthe question is just how long you delay it.\n\t\t*/\n\t\tvar RWC = 0;\n\t\tr.write = function(file, rad, cb, o, DBG){\n\t\t\tif(!rad){ cb('No radix!'); return }\n\t\t\to = ('object' == typeof o)? o : {force: o};\n\t\t\tvar f = function Fractal(){}, a, b;\n\t\t\tf.text = '';\n\t\t\tf.file = file = rad.file || (rad.file = file);\n\t\t\tif(!file){ cb('What file?'); return }\n\t\t\tf.write = function(){\n\t\t\t\tvar text = rad.raw = f.text;\n\t\t\t\tr.disk[file = rad.file || f.file || file] = rad;\n\t\t\t\tvar S = +new Date;\n\t\t\t\tDBG && (DBG.wd = S);\n\t\t\t\t//console.only.i && console.log('add', file);\n\t\t\t\tr.find.add(file, function add(err){\n\t\t\t\t\tDBG && (DBG.wa = +new Date);\n\t\t\t\t\tif(err){ cb(err); return }\n\t\t\t\t\t//console.only.i && console.log('disk', file, text);\n\t\t\t\t\topt.store.put(ename(file), text, function safe(err, ok){\n\t\t\t\t\t\tDBG && (DBG.wp = +new Date);\n\t\t\t\t\t\tconsole.STAT && console.STAT(S, ST = +new Date - S, \"wrote disk\", JSON.stringify(file), ++RWC, 'total all writes.');\n\t\t\t\t\t\t//console.only.i && console.log('done', err, ok || 1, cb);\n\t\t\t\t\t\tcb(err, ok || 1);\n\t\t\t\t\t\tif(!rad.Q){ delete r.disk[file] } // VERY IMPORTANT! Clean up memory, but not if there is already queued writes on it!\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\tf.split = function(){\n\t\t\t\tvar S = +new Date;\n\t\t\t\tDBG && (DBG.wf = S);\n\t\t\t\tf.text = '';\n\t\t\t\tif(!f.count){ f.count = 0;\n\t\t\t\t\tRadix.map(rad, function count(){ f.count++ }); // TODO: Perf? Any faster way to get total length?\n\t\t\t\t}\n\t\t\t\tDBG && (DBG.wfc = f.count);\n\t\t\t\tf.limit = Math.ceil(f.count/2);\n\t\t\t\tvar SC = f.count;\n\t\t\t\tf.count = 0;\n\t\t\t\tDBG && (DBG.wf1 = +new Date);\n\t\t\t\tf.sub = Radix();\n\t\t\t\tRadix.map(rad, f.slice, {reverse: 1}); // IMPORTANT: DO THIS IN REVERSE, SO LAST HALF OF DATA MOVED TO NEW FILE BEFORE DROPPING FROM CURRENT FILE.\n\t\t\t\tDBG && (DBG.wf2 = +new Date);\n\t\t\t\tr.write(f.end, f.sub, f.both, o);\n\t\t\t\tDBG && (DBG.wf3 = +new Date);\n\t\t\t\tf.hub = Radix();\n\t\t\t\tRadix.map(rad, f.stop);\n\t\t\t\tDBG && (DBG.wf4 = +new Date);\n\t\t\t\tr.write(rad.file, f.hub, f.both, o);\n\t\t\t\tDBG && (DBG.wf5 = +new Date);\n\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, \"rad split\", ename(rad.file), SC);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tf.slice = function(val, key){\n\t\t\t\tf.sub(f.end = key, val);\n\t\t\t\tif(f.limit <= (++f.count)){ return true }\n\t\t\t}\n\t\t\tf.stop = function(val, key){\n\t\t\t\tif(key >= f.end){ return true }\n\t\t\t\tf.hub(key, val);\n\t\t\t}\n\t\t\tf.both = function(err, ok){\n\t\t\t\tDBG && (DBG.wfd = +new Date);\n\t\t\t\tif(b){ cb(err || b); return }\n\t\t\t\tif(a){ cb(err, ok); return }\n\t\t\t\ta = true;\n\t\t\t\tb = err;\n\t\t\t}\n\t\t\tf.each = function(val, key, k, pre){\n\t\t\t\tif(u !== val){ f.count++ }\n\t\t\t\tif(opt.max <= (val||'').length){ return cb(\"Data too big!\"), true }\n\t\t\t\tvar enc = Radisk.encode(pre.length) +'#'+ Radisk.encode(k) + (u === val? '' : ':'+ Radisk.encode(val)) +'\\n';\n\t\t\t\tif((opt.chunk < f.text.length + enc.length) && (1 < f.count) && !o.force){\n\t\t\t\t\treturn f.split();\n\t\t\t\t}\n\t\t\t\tf.text += enc;\n\t\t\t}\n\t\t\t//console.only.i && console.log('writing');\n\t\t\tif(opt.jsonify){ r.write.jsonify(f, rad, cb, o, DBG); return } // temporary testing idea\n\t\t\tif(!Radix.map(rad, f.each, true)){ f.write() }\n\t\t}\n\n\t\tr.write.jsonify = function(f, rad, cb, o, DBG){\n\t\t\tvar raw;\n\t\t\tvar S = +new Date;\n\t\t\tDBG && (DBG.w = S);\n\t\t\ttry{raw = JSON.stringify(rad.$);\n\t\t\t}catch(e){ cb(\"Cannot radisk!\"); return }\n\t\t\tDBG && (DBG.ws = +new Date);\n\t\t\tconsole.STAT && console.STAT(S, +new Date - S, \"rad stringified JSON\");\n\t\t\tif(opt.chunk < raw.length && !o.force){\n\t\t\t\tvar c = 0;\n\t\t\t\tRadix.map(rad, function(){\n\t\t\t\t\tif(c++){ return true } // more than 1 item\n\t\t\t\t});\n\t\t\t\tif(c > 1){\n\t\t\t\t\treturn f.split();\n\t\t\t\t}\n\t\t\t}\n\t\t\tf.text = raw;\n\t\t\tf.write();\n\t\t}\n\n\t\tr.range = function(tree, o){\n\t\t\tif(!tree || !o){ return }\n\t\t\tif(u === o.start && u === o.end){ return tree }\n\t\t\tif(atomic(tree)){ return tree }\n\t\t\tvar sub = Radix();\n\t\t\tRadix.map(tree, function(v,k){ sub(k,v) }, o); // ONLY PLACE THAT TAKES TREE, maybe reduce API for better perf?\n\t\t\treturn sub('');\n\t\t}\n\n\t\t;(function(){\n\t\t\tr.read = function(key, cb, o, DBG){\n\t\t\t\to = o || {};\n\t\t\t\tvar g = {key: key};\n\t\t\t\tg.find = function(file){ var tmp;\n\t\t\t\t\tg.file = file || (file = opt.code.from);\n\t\t\t\t\tDBG && (DBG = DBG[file] = DBG[file] || {});\n\t\t\t\t\tDBG && (DBG.rf = DBG.rf || +new Date);\n\t\t\t\t\tif(tmp = r.disk[g.file = file]){ g.check(u, tmp); return }\n\t\t\t\t\tr.parse(file, g.check, u, DBG);\n\t\t\t\t}\n\t\t\t\tg.get = function(err, disk, info){\n\t\t\t\t\tDBG && (DBG.rgl = +new Date);\n\t\t\t\t\tDBG && (DBG.rg = DBG.rg || +new Date);\n\t\t\t\t\tif(g.err = err || g.err){ cb(err); return }\n\t\t\t\t\tvar file = g.file = (disk||'').file || g.file;\n\t\t\t\t\tif(!disk && file !== opt.code.from){ // corrupt file?\n\t\t\t\t\t\tr.find.bad(file); // remove from dir list\n\t\t\t\t\t\tr.read(key, cb, o); // try again\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisk = r.disk[file] || (r.disk[file] = disk);\n\t\t\t\t\tif(!disk){ cb(file === opt.code.from? u : \"No file!\"); return }\n\t\t\t\t\tdisk.file || (disk.file = file);\n\t\t\t\t\tvar data = r.range(disk(key), o);\n\t\t\t\t\tDBG && (DBG.rr = +new Date);\n\t\t\t\t\to.unit = disk.unit;\n\t\t\t\t\to.chunks = (o.chunks || 0) + 1;\n\t\t\t\t\to.parsed = (o.parsed || 0) + ((info||'').parsed||(o.chunks*opt.chunk));\n\t\t\t\t\to.more = 1;\n\t\t\t\t\to.next = u;\n\t\t\t\t\tRadix.map(r.list, function next(v,f){\n\t\t\t\t\t\tif(!v || file === f){ return }\n\t\t\t\t\t\to.next = f;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}, o.reverse? {reverse: 1, end: file} : {start: file});\n\t\t\t\t\tDBG && (DBG.rl = +new Date);\n\t\t\t\t\tif(!o.next){ o.more = 0 }\n\t\t\t\t\tif(o.next){\n\t\t\t\t\t\tif(!o.reverse && ((key < o.next && 0 != o.next.indexOf(key)) || (u !== o.end && (o.end || '\\uffff') < o.next))){ o.more = 0 }\n\t\t\t\t\t\tif(o.reverse && ((key > o.next && 0 != key.indexOf(o.next)) || ((u !== o.start && (o.start || '') > o.next && file <= o.start)))){ o.more = 0 }\n\t\t\t\t\t}\n\t\t\t\t\t//console.log(5, process.memoryUsage().heapUsed);\n\t\t\t\t\tif(!o.more){ cb(g.err, data, o); return }\n\t\t\t\t\tif(data){ cb(g.err, data, o) }\n\t\t\t\t\tif(o.parsed >= o.limit){ return }\n\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\tDBG && (DBG.rm = S);\n\t\t\t\t\tvar next = o.next;\n\t\t\t\t\ttimediate(function(){\n\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'rad more');\n\t\t\t\t\t\tr.parse(next, g.check);\n\t\t\t\t\t},0);\n\t\t\t\t}\n\t\t\t\tg.check = function(err, disk, info){\n\t\t\t\t\t//console.log(4, process.memoryUsage().heapUsed);\n\t\t\t\t\tg.get(err, disk, info);\n\t\t\t\t\tif(!disk || disk.check){ return } disk.check = 1;\n\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\t(info || (info = {})).file || (info.file = g.file);\n\t\t\t\t\tRadix.map(disk, function(val, key){\n\t\t\t\t\t\t// assume in memory for now, since both write/read already call r.find which will init it.\n\t\t\t\t\t\tr.find(key, function(file){\n\t\t\t\t\t\t\tif((file || (file = opt.code.from)) === info.file){ return }\n\t\t\t\t\t\t\tvar id = (''+Math.random()).slice(-3);\n\t\t\t\t\t\t\tpuff(function(){\n\t\t\t\t\t\t\tr.save(key, val, function ack(err, ok){\n\t\t\t\t\t\t\t\tif(err){ r.save(key, val, ack); return } // ad infinitum???\n\t\t\t\t\t\t\t\t// TODO: NOTE!!! Mislocated data could be because of a synchronous `put` from the `g.get(` other than perf shouldn't we do the check first before acking?\n\t\t\t\t\t\t\t\tconsole.STAT && console.STAT(\"MISLOCATED DATA CORRECTED\", id, ename(key), ename(info.file), ename(file));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t},0);\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, \"rad check\");\n\t\t\t\t}\n\t\t\t\tr.find(key || (o.reverse? (o.end||'') : (o.start||'')), g.find); \n\t\t\t}\n\t\t\tfunction rev(a,b){ return b }\n\t\t\tvar revo = {reverse: true};\n\t\t}());\n\n\t\t;(function(){\n\t\t\t/*\n\t\t\t\tLet us start by assuming we are the only process that is\n\t\t\t\tchanging the directory or bucket. Not because we do not want\n\t\t\t\tto be multi-process/machine, but because we want to experiment\n\t\t\t\twith how much performance and scale we can get out of only one.\n\t\t\t\tThen we can work on the harder problem of being multi-process.\n\t\t\t*/\n\t\t\tvar RPC = 0;\n\t\t\tvar Q = {}, s = String.fromCharCode(31);\n\t\t\tr.parse = function(file, cb, raw, DBG){ var q;\n\t\t\t\tif(!file){ return cb(); }\n\t\t\t\tif(q = Q[file]){ q.push(cb); return } q = Q[file] = [cb];\n\t\t\t\tvar p = function Parse(){}, info = {file: file};\n\t\t\t\t(p.disk = Radix()).file = file;\n\t\t\t\tp.read = function(err, data){ var tmp;\n\t\t\t\t\tDBG && (DBG.rpg = +new Date);\n\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'read disk', JSON.stringify(file), ++RPC, 'total all parses.');\n\t\t\t\t\t//console.log(2, process.memoryUsage().heapUsed);\n\t\t\t\t\tif((p.err = err) || (p.not = !data)){\n\t\t\t\t\t\tdelete Q[file];\n\t\t\t\t\t\tp.map(q, p.ack);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif('string' !== typeof data){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\tif(opt.max <= data.length){\n\t\t\t\t\t\t\t\tp.err = \"Chunk too big!\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata = data.toString(); // If it crashes, it crashes here. How!?? We check size first!\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}catch(e){ p.err = e }\n\t\t\t\t\t\tif(p.err){\n\t\t\t\t\t\t\tdelete Q[file];\n\t\t\t\t\t\t\tp.map(q, p.ack);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinfo.parsed = data.length;\n\t\t\t\t\tDBG && (DBG.rpl = info.parsed);\n\t\t\t\t\tDBG && (DBG.rpa = q.length);\n\t\t\t\t\tS = +new Date;\n\t\t\t\t\tif(!(opt.jsonify || '{' === data[0])){\n\t\t\t\t\t\tp.radec(err, data);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tparse(data, function(err, tree){\n\t\t\t\t\t\t//console.log(3, process.memoryUsage().heapUsed);\n\t\t\t\t\t\tif(!err){\n\t\t\t\t\t\t\tdelete Q[file];\n\t\t\t\t\t\t\tp.disk.$ = tree;\n\t\t\t\t\t\t\tconsole.STAT && (ST = +new Date - S) > 9 && console.STAT(S, ST, 'rad parsed JSON');\n\t\t\t\t\t\t\tDBG && (DBG.rpd = +new Date);\n\t\t\t\t\t\t\tp.map(q, p.ack); // hmmm, v8 profiler can't see into this cause of try/catch?\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif('{' === data[0]){\n\t\t\t\t\t\t\tdelete Q[file];\n\t\t\t\t\t\t\tp.err = tmp || \"JSON error!\";\n\t\t\t\t\t\t\tp.map(q, p.ack);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp.radec(err, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tp.map = function(){ // switch to setTimeout.each now?\n\t\t\t\t\tif(!q || !q.length){ return }\n\t\t\t\t\t//var i = 0, l = q.length, ack;\n\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\tvar err = p.err, data = p.not? u : p.disk;\n\t\t\t\t\tvar i = 0, ack; while(i < 9 && (ack = q[i++])){ ack(err, data, info) } // too much?\n\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'rad packs', ename(file));\n\t\t\t\t\tconsole.STAT && console.STAT(S, i, 'rad packs #', ename(file)); \n\t\t\t\t\tif(!(q = q.slice(i)).length){ return }\n\t\t\t\t\tpuff(p.map, 0);\n\t\t\t\t}\n\t\t\t\tp.ack = function(cb){\n\t\t\t\t\tif(!cb){ return }\n\t\t\t\t\tif(p.err || p.not){\n\t\t\t\t\t\tcb(p.err, u, info);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcb(u, p.disk, info);\n\t\t\t\t}\n\t\t\t\tp.radec = function(err, data){\n\t\t\t\t\tdelete Q[file];\n\t\t\t\t\tS = +new Date;\n\t\t\t\t\tvar tmp = p.split(data), pre = [], i, k, v;\n\t\t\t\t\tif(!tmp || 0 !== tmp[1]){\n\t\t\t\t\t\tp.err = \"File '\"+file+\"' does not have root radix! \";\n\t\t\t\t\t\tp.map(q, p.ack);\n\t\t\t\t\t\treturn; \n\t\t\t\t\t}\n\t\t\t\t\twhile(tmp){\n\t\t\t\t\t\tk = v = u;\n\t\t\t\t\t\ti = tmp[1];\n\t\t\t\t\t\ttmp = p.split(tmp[2])||'';\n\t\t\t\t\t\tif('#' == tmp[0]){\n\t\t\t\t\t\t\tk = tmp[1];\n\t\t\t\t\t\t\tpre = pre.slice(0,i);\n\t\t\t\t\t\t\tif(i <= pre.length){\n\t\t\t\t\t\t\t\tpre.push(k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp = p.split(tmp[2])||'';\n\t\t\t\t\t\tif('\\n' == tmp[0]){ continue }\n\t\t\t\t\t\tif('=' == tmp[0] || ':' == tmp[0]){ v = tmp[1] }\n\t\t\t\t\t\tif(u !== k && u !== v){ p.disk(pre.join(''), v) }\n\t\t\t\t\t\ttmp = p.split(tmp[2]);\n\t\t\t\t\t}\n\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'parsed RAD');\n\t\t\t\t\tp.map(q, p.ack);\n\t\t\t\t};\n\t\t\t\tp.split = function(t){\n\t\t\t\t\tif(!t){ return }\n\t\t\t\t\tvar l = [], o = {}, i = -1, a = '', b, c;\n\t\t\t\t\ti = t.indexOf(s);\n\t\t\t\t\tif(!t[i]){ return }\n\t\t\t\t\ta = t.slice(0, i);\n\t\t\t\t\tl[0] = a;\n\t\t\t\t\tl[1] = b = Radisk.decode(t.slice(i), o);\n\t\t\t\t\tl[2] = t.slice(i + o.i);\n\t\t\t\t\treturn l;\n\t\t\t\t}\n\t\t\t\tif(r.disk){ raw || (raw = (r.disk[file]||'').raw) }\n\t\t\t\tvar S = +new Date, SM, SL;\n\t\t\t\tDBG && (DBG.rp = S);\n\t\t\t\tif(raw){ return puff(function(){ p.read(u, raw) }, 0) }\n\t\t\t\topt.store.get(ename(file), p.read);\n\t\t\t\t// TODO: What if memory disk gets filled with updates, and we get an old one back?\n\t\t\t}\n\t\t}());\n\n\t\t;(function(){\n\t\t\tvar dir, f = String.fromCharCode(28), Q;\n\t\t\tr.find = function(key, cb){\n\t\t\t\tif(!dir){\n\t\t\t\t\tif(Q){ Q.push([key, cb]); return } Q = [[key, cb]];\n\t\t\t\t\tr.parse(f, init);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tRadix.map(r.list = dir, function(val, key){\n\t\t\t\t\tif(!val){ return }\n\t\t\t\t\treturn cb(key) || true;\n\t\t\t\t}, {reverse: 1, end: key}) || cb(opt.code.from);\n\t\t\t}\n\t\t\tr.find.add = function(file, cb){\n\t\t\t\tvar has = dir(file);\n\t\t\t\tif(has || file === f){ cb(u, 1); return }\n\t\t\t\tdir(file, 1);\n\t\t\t\tcb.found = (cb.found || 0) + 1;\n\t\t\t\tr.write(f, dir, function(err, ok){\n\t\t\t\t\tif(err){ cb(err); return }\n\t\t\t\t\tcb.found = (cb.found || 0) - 1;\n\t\t\t\t\tif(0 !== cb.found){ return }\n\t\t\t\t\tcb(u, 1);\n\t\t\t\t}, true);\n\t\t\t}\n\t\t\tr.find.bad = function(file, cb){\n\t\t\t\tdir(file, 0);\n\t\t\t\tr.write(f, dir, cb||noop);\n\t\t\t}\n\t\t\tfunction init(err, disk){\n\t\t\t\tif(err){\n\t\t\t\t\topt.log('list', err);\n\t\t\t\t\tsetTimeout(function(){ r.parse(f, init) }, 1000);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(disk){ drain(disk); return }\n\t\t\t\tdir = dir || disk || Radix();\n\t\t\t\tif(!opt.store.list){ drain(dir); return }\n\t\t\t\t// import directory.\n\t\t\t\topt.store.list(function(file){\n\t\t\t\t\tif(!file){ drain(dir); return }\n\t\t\t\t\tr.find.add(file, noop);\n\t\t\t\t});\n\t\t\t}\n\t\t\tfunction drain(rad, tmp){\n\t\t\t\tdir = dir || rad;\n\t\t\t\tdir.file = f;\n\t\t\t\ttmp = Q; Q = null;\n\t\t\t\tmap(tmp, function(arg){\n\t\t\t\t\tr.find(arg[0], arg[1]);\n\t\t\t\t});\n\t\t\t}\n\t\t}());\n\n\t\ttry{ !Gun.window && __webpack_require__(/*! ./radmigtmp */ \"(ssr)/./node_modules/gun/lib/radmigtmp.js\")(r) }catch(e){}\n\n\t\tvar noop = function(){}, RAD, u;\n\t\tRadisk.has[opt.file] = r;\n\t\treturn r;\n\t}\n\n\t;(function(){\n\t\tvar _ = String.fromCharCode(31), u;\n\t\tRadisk.encode = function(d, o, s){ s = s || _;\n\t\t\tvar t = s, tmp;\n\t\t\tif(typeof d == 'string'){\n\t\t\t\tvar i = d.indexOf(s);\n\t\t\t\twhile(i != -1){ t += s; i = d.indexOf(s, i+1) }\n\t\t\t\treturn t + '\"' + d + s;\n\t\t\t} else\n\t\t\tif(d && d['#'] && 1 == Object.keys(d).length){\n\t\t\t\treturn t + '#' + tmp + t;\n\t\t\t} else\n\t\t\tif('number' == typeof d){\n\t\t\t\treturn t + '+' + (d||0) + t;\n\t\t\t} else\n\t\t\tif(null === d){\n\t\t\t\treturn t + ' ' + t;\n\t\t\t} else\n\t\t\tif(true === d){\n\t\t\t\treturn t + '+' + t;\n\t\t\t} else\n\t\t\tif(false === d){\n\t\t\t\treturn t + '-' + t;\n\t\t\t}// else\n\t\t\t//if(binary){}\n\t\t}\n\t\tRadisk.decode = function(t, o, s){ s = s || _;\n\t\t\tvar d = '', i = -1, n = 0, c, p;\n\t\t\tif(s !== t[0]){ return }\n\t\t\twhile(s === t[++i]){ ++n }\n\t\t\tp = t[c = n] || true;\n\t\t\twhile(--n >= 0){ i = t.indexOf(s, i+1) }\n\t\t\tif(i == -1){ i = t.length }\n\t\t\td = t.slice(c+1, i);\n\t\t\tif(o){ o.i = i+1 }\n\t\t\tif('\"' === p){\n\t\t\t\treturn d;\n\t\t\t} else\n\t\t\tif('#' === p){\n\t\t\t\treturn {'#':d};\n\t\t\t} else\n\t\t\tif('+' === p){\n\t\t\t\tif(0 === d.length){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn parseFloat(d);\n\t\t\t} else\n\t\t\tif(' ' === p){\n\t\t\t\treturn null;\n\t\t\t} else\n\t\t\tif('-' === p){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}());\n\n\tif(typeof window !== \"undefined\"){\n\t  var Gun = window.Gun;\n\t  var Radix = window.Radix;\n\t  window.Radisk = Radisk;\n\t} else { \n\t  var Gun = __webpack_require__(/*! ../gun */ \"(ssr)/./node_modules/gun/gun.js\");\n\t\tvar Radix = __webpack_require__(/*! ./radix */ \"(ssr)/./node_modules/gun/lib/radix.js\");\n\t\t//var Radix = require('./radix2'); Radisk = require('./radisk2');\n\t\ttry{ module.exports = Radisk }catch(e){}\n\t}\n\n\tRadisk.Radix = Radix;\n\n}());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9yYWRpc2suanMiLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOzs7QUFHQSxxQkFBcUIscURBQXFEO0FBQzFFLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRSw4QkFBOEI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxVQUFjLEdBQUcsbUJBQU8sQ0FBQyxvREFBUTtBQUM5QyxtREFBbUQsT0FBTyxLQUFLLHdCQUF3QixVQUFVO0FBQ2pHLHdEQUF3RCxPQUFPLEtBQUssOEJBQThCLFVBQVU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsNEJBQTRCO0FBQzVCO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVMsU0FBUztBQUNoRDtBQUNBLHlDQUF5QztBQUN6Qyx1QkFBdUI7QUFDdkIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYSxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1REFBdUQ7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGFBQWEsbUJBQU8sQ0FBQywrQ0FBUTtBQUM3QixjQUFjLG1CQUFPLENBQUMsc0RBQVM7QUFDL0IscUNBQXFDO0FBQ3JDLE9BQU8seUJBQXlCO0FBQ2hDOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIzLWNoYXQvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9yYWRpc2suanM/YzA2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyI7KGZ1bmN0aW9uKCl7XG5cblx0ZnVuY3Rpb24gUmFkaXNrKG9wdCl7XG5cblx0XHRvcHQgPSBvcHQgfHwge307XG5cdFx0b3B0LmxvZyA9IG9wdC5sb2cgfHwgY29uc29sZS5sb2c7XG5cdFx0b3B0LmZpbGUgPSBTdHJpbmcob3B0LmZpbGUgfHwgJ3JhZGF0YScpO1xuXHRcdHZhciBoYXMgPSAoUmFkaXNrLmhhcyB8fCAoUmFkaXNrLmhhcyA9IHt9KSlbb3B0LmZpbGVdO1xuXHRcdGlmKGhhcyl7IHJldHVybiBoYXMgfVxuXG5cdFx0b3B0Lm1heCA9IG9wdC5tYXggfHwgKG9wdC5tZW1vcnk/IChvcHQubWVtb3J5ICogOTk5ICogOTk5KSA6IDMwMDAwMDAwMCkgKiAwLjM7XG5cdFx0b3B0LnVudGlsID0gb3B0LnVudGlsIHx8IG9wdC53YWl0IHx8IDI1MDtcblx0XHRvcHQuYmF0Y2ggPSBvcHQuYmF0Y2ggfHwgKDEwICogMTAwMCk7XG5cdFx0b3B0LmNodW5rID0gb3B0LmNodW5rIHx8ICgxMDI0ICogMTAyNCAqIDEpOyAvLyAxTUJcblx0XHRvcHQuY29kZSA9IG9wdC5jb2RlIHx8IHt9O1xuXHRcdG9wdC5jb2RlLmZyb20gPSBvcHQuY29kZS5mcm9tIHx8ICchJztcblx0XHRvcHQuanNvbmlmeSA9IHRydWU7XG5cblxuXHRcdGZ1bmN0aW9uIGVuYW1lKHQpeyByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHQpLnJlcGxhY2UoL1xcKi9nLCAnJTJBJykgfSAvLyBUT0RPOiBIYXNoIHRoaXMgYWxzbywgYnV0IGFsbG93IG1pZ3JhdGlvbiFcblx0XHRmdW5jdGlvbiBhdG9taWModil7IHJldHVybiB1ICE9PSB2ICYmICghdiB8fCAnb2JqZWN0JyAhPSB0eXBlb2YgdikgfVxuXHRcdHZhciB0aW1lZGlhdGUgPSAoJycrdSA9PT0gdHlwZW9mIHNldEltbWVkaWF0ZSk/IHNldFRpbWVvdXQgOiBzZXRJbW1lZGlhdGU7XG5cdFx0dmFyIHB1ZmYgPSBzZXRUaW1lb3V0LnR1cm4gfHwgdGltZWRpYXRlLCB1O1xuXHRcdHZhciBtYXAgPSBSYWRpeC5vYmplY3Q7XG5cdFx0dmFyIFNUID0gMDtcblxuXHRcdGlmKCFvcHQuc3RvcmUpe1xuXHRcdFx0cmV0dXJuIG9wdC5sb2coXCJFUlJPUjogUmFkaXNrIG5lZWRzIGBvcHQuc3RvcmVgIGludGVyZmFjZSB3aXRoIGB7Z2V0OiBmbiwgcHV0OiBmbiAoLCBsaXN0OiBmbil9YCFcIik7XG5cdFx0fVxuXHRcdGlmKCFvcHQuc3RvcmUucHV0KXtcblx0XHRcdHJldHVybiBvcHQubG9nKFwiRVJST1I6IFJhZGlzayBuZWVkcyBgc3RvcmUucHV0YCBpbnRlcmZhY2Ugd2l0aCBgKGZpbGUsIGRhdGEsIGNiKWAhXCIpO1xuXHRcdH1cblx0XHRpZighb3B0LnN0b3JlLmdldCl7XG5cdFx0XHRyZXR1cm4gb3B0LmxvZyhcIkVSUk9SOiBSYWRpc2sgbmVlZHMgYHN0b3JlLmdldGAgaW50ZXJmYWNlIHdpdGggYChmaWxlLCBjYilgIVwiKTtcblx0XHR9XG5cdFx0aWYoIW9wdC5zdG9yZS5saXN0KXtcblx0XHRcdC8vb3B0LmxvZyhcIldBUk5JTkc6IGBzdG9yZS5saXN0YCBpbnRlcmZhY2UgbWlnaHQgYmUgbmVlZGVkIVwiKTtcblx0XHR9XG5cblx0XHRpZignJyt1ICE9IHR5cGVvZiByZXF1aXJlKXsgcmVxdWlyZSgnLi95c29uJykgfVxuXHRcdHZhciBwYXJzZSA9IEpTT04ucGFyc2VBc3luYyB8fCBmdW5jdGlvbih0LGNiLHIpeyB2YXIgdTsgdHJ5eyBjYih1LCBKU09OLnBhcnNlKHQscikpIH1jYXRjaChlKXsgY2IoZSkgfSB9XG5cdFx0dmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeUFzeW5jIHx8IGZ1bmN0aW9uKHYsY2IscixzKXsgdmFyIHU7IHRyeXsgY2IodSwgSlNPTi5zdHJpbmdpZnkodixyLHMpKSB9Y2F0Y2goZSl7IGNiKGUpIH0gfVxuXHRcdC8qXG5cdFx0XHRBbnkgYW5kIGFsbCBzdG9yYWdlIGFkYXB0ZXJzIHNob3VsZC4uLlxuXHRcdFx0MS4gQmVjYXVzZSB3cml0aW5nIHRvIGRpc2sgdGFrZXMgdGltZSwgd2Ugc2hvdWxkIGJhdGNoIGRhdGEgdG8gZGlzay4gVGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSwgYW5kIHJlZHVjZXMgcG90ZW50aWFsIGRpc2sgY29ycnVwdGlvbi5cblx0XHRcdDIuIElmIGEgYmF0Y2ggZXhjZWVkcyBhIGNlcnRhaW4gbnVtYmVyIG9mIHdyaXRlcywgd2Ugc2hvdWxkIGltbWVkaWF0ZWx5IHdyaXRlIHRvIGRpc2sgd2hlbiBwaHlzaWNhbGx5IHBvc3NpYmxlLiBUaGlzIGNhcHMgdG90YWwgcGVyZm9ybWFuY2UsIGJ1dCByZWR1Y2VzIHBvdGVudGlhbCBsb3NzLlxuXHRcdCovXG5cdFx0dmFyIHIgPSBmdW5jdGlvbihrZXksIGRhdGEsIGNiLCB0YWcsIERCRyl7XG5cdFx0XHRpZignZnVuY3Rpb24nID09PSB0eXBlb2YgZGF0YSl7XG5cdFx0XHRcdHZhciBvID0gY2IgfHwge307XG5cdFx0XHRcdGNiID0gZGF0YTtcblx0XHRcdFx0ci5yZWFkKGtleSwgY2IsIG8sIERCRyB8fCB0YWcpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvL3ZhciB0bXAgPSAodG1wID0gci5iYXRjaCA9IHIuYmF0Y2ggfHwge30pW2tleV0gPSB0bXBba2V5XSB8fCB7fTtcblx0XHRcdC8vdmFyIHRtcCA9ICh0bXAgPSByLmJhdGNoID0gci5iYXRjaCB8fCB7fSlba2V5XSA9IGRhdGE7XG5cdFx0XHRyLnNhdmUoa2V5LCBkYXRhLCBjYiwgdGFnLCBEQkcpO1xuXHRcdH1cblx0XHRyLnNhdmUgPSBmdW5jdGlvbihrZXksIGRhdGEsIGNiLCB0YWcsIERCRyl7XG5cdFx0XHR2YXIgcyA9IHtrZXk6IGtleX0sIHRhZ3MsIGYsIGQsIHE7XG5cdFx0XHRzLmZpbmQgPSBmdW5jdGlvbihmaWxlKXsgdmFyIHRtcDtcblx0XHRcdFx0cy5maWxlID0gZmlsZSB8fCAoZmlsZSA9IG9wdC5jb2RlLmZyb20pO1xuXHRcdFx0XHREQkcgJiYgKERCRyA9IERCR1tmaWxlXSA9IERCR1tmaWxlXSB8fCB7fSk7XG5cdFx0XHRcdERCRyAmJiAoREJHLnNmID0gREJHLnNmIHx8ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdC8vY29uc29sZS5vbmx5LmkgJiYgY29uc29sZS5sb2coJ2ZvdW5kJywgZmlsZSk7XG5cdFx0XHRcdGlmKHRtcCA9IHIuZGlza1tmaWxlXSl7IHMubWl4KHUsIHRtcCk7IHJldHVybiB9XG5cdFx0XHRcdHIucGFyc2UoZmlsZSwgcy5taXgsIHUsIERCRyk7XG5cdFx0XHR9XG5cdFx0XHRzLm1peCA9IGZ1bmN0aW9uKGVyciwgZGlzayl7XG5cdFx0XHRcdERCRyAmJiAoREJHLnNtbCA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdERCRyAmJiAoREJHLnNtID0gREJHLnNtIHx8ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdGlmKHMuZXJyID0gZXJyIHx8IHMuZXJyKXsgY2IoZXJyKTsgcmV0dXJuIH0gLy8gVE9ETzogSEFORExFIEJBVENIIEVNSVRcblx0XHRcdFx0dmFyIGZpbGUgPSBzLmZpbGUgPSAoZGlza3x8JycpLmZpbGUgfHwgcy5maWxlLCB0bXA7XG5cdFx0XHRcdGlmKCFkaXNrICYmIGZpbGUgIT09IG9wdC5jb2RlLmZyb20peyAvLyBjb3JydXB0IGZpbGU/XG5cdFx0XHRcdFx0ci5maW5kLmJhZChmaWxlKTsgLy8gcmVtb3ZlIGZyb20gZGlyIGxpc3Rcblx0XHRcdFx0XHRyLnNhdmUoa2V5LCBkYXRhLCBjYiwgdGFnKTsgLy8gdHJ5IGFnYWluXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdChkaXNrID0gci5kaXNrW2ZpbGVdIHx8IChyLmRpc2tbZmlsZV0gPSBkaXNrIHx8IFJhZGl4KCkpKS5maWxlIHx8IChkaXNrLmZpbGUgPSBmaWxlKTtcblx0XHRcdFx0aWYob3B0LmNvbXBhcmUpe1xuXHRcdFx0XHRcdGRhdGEgPSBvcHQuY29tcGFyZShkaXNrKGtleSksIGRhdGEsIGtleSwgZmlsZSk7XG5cdFx0XHRcdFx0aWYodSA9PT0gZGF0YSl7IGNiKGVyciwgLTEpOyByZXR1cm4gfSAvLyBUT0RPOiBIQU5ETEUgQkFUQ0ggRU1JVFxuXHRcdFx0XHR9XG5cdFx0XHRcdChzLmRpc2sgPSBkaXNrKShrZXksIGRhdGEpO1xuXHRcdFx0XHRpZih0YWcpe1xuXHRcdFx0XHRcdCh0bXAgPSAodG1wID0gZGlzay50YWdzIHx8IChkaXNrLnRhZ3MgPSB7fSkpW3RhZ10gfHwgKHRtcFt0YWddID0gci50YWdzW3RhZ10gfHwgKHIudGFnc1t0YWddID0ge30pKSlbZmlsZV0gfHwgKHRtcFtmaWxlXSA9IHIub25lW3RhZ10gfHwgKHIub25lW3RhZ10gPSBjYikpO1xuXHRcdFx0XHRcdGNiID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHREQkcgJiYgKERCRy5zdCA9IERCRy5zdCB8fCArbmV3IERhdGUpO1xuXHRcdFx0XHQvL2NvbnNvbGUub25seS5pICYmIGNvbnNvbGUubG9nKCdtaXgnLCBkaXNrLlEpO1xuXHRcdFx0XHRpZihkaXNrLlEpeyBjYiAmJiBkaXNrLlEucHVzaChjYik7IHJldHVybiB9IGRpc2suUSA9IChjYj8gW2NiXSA6IFtdKTtcblx0XHRcdFx0ZGlzay50byA9IHNldFRpbWVvdXQocy53cml0ZSwgb3B0LnVudGlsKTtcblx0XHRcdH1cblx0XHRcdHMud3JpdGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHREQkcgJiYgKERCRy5zdG8gPSBEQkcuc3RvIHx8ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdHZhciBmaWxlID0gZiA9IHMuZmlsZSwgZGlzayA9IGQgPSBzLmRpc2s7XG5cdFx0XHRcdHEgPSBzLnEgPSBkaXNrLlE7XG5cdFx0XHRcdHRhZ3MgPSBzLnRhZ3MgPSBkaXNrLnRhZ3M7XG5cdFx0XHRcdGRlbGV0ZSBkaXNrLlE7XG5cdFx0XHRcdGRlbGV0ZSByLmRpc2tbZmlsZV07XG5cdFx0XHRcdGRlbGV0ZSBkaXNrLnRhZ3M7XG5cdFx0XHRcdC8vY29uc29sZS5vbmx5LmkgJiYgY29uc29sZS5sb2coJ3dyaXRlJywgZmlsZSwgZGlzaywgJ3dhcyBzYXZpbmc6Jywga2V5LCBkYXRhKTtcblx0XHRcdFx0ci53cml0ZShmaWxlLCBkaXNrLCBzLmFjaywgdSwgREJHKTtcblx0XHRcdH1cblx0XHRcdHMuYWNrID0gZnVuY3Rpb24oZXJyLCBvayl7XG5cdFx0XHRcdERCRyAmJiAoREJHLnNhID0gREJHLnNhIHx8ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdERCRyAmJiAoREJHLnNhbCA9IHEubGVuZ3RoKTtcblx0XHRcdFx0dmFyIGFjaywgdG1wO1xuXHRcdFx0XHQvLyBUT0RPISEhISBDSEFOR0UgVEhJUyBJTlRPIFBVRkYhISEhISEhISEhISEhISEhXG5cdFx0XHRcdGZvcih2YXIgaWQgaW4gci50YWdzKXtcblx0XHRcdFx0XHRpZighci50YWdzLmhhc093blByb3BlcnR5KGlkKSl7IGNvbnRpbnVlIH0gdmFyIHRhZyA9IHIudGFnc1tpZF07XG5cdFx0XHRcdFx0aWYoKHRtcCA9IHIuZGlza1tmXSkgJiYgKHRtcCA9IHRtcC50YWdzKSAmJiB0bXBbdGFnXSl7IGNvbnRpbnVlIH1cblx0XHRcdFx0XHRhY2sgPSB0YWdbZl07XG5cdFx0XHRcdFx0ZGVsZXRlIHRhZ1tmXTtcblx0XHRcdFx0XHR2YXIgbmU7IGZvcih2YXIgayBpbiB0YWcpeyBpZih0YWcuaGFzT3duUHJvcGVydHkoaykpeyBuZSA9IHRydWU7IGJyZWFrIH0gfSAvLyBpcyBub3QgZW1wdHk/XG5cdFx0XHRcdFx0aWYobmUpeyBjb250aW51ZSB9IC8vaWYoIW9ial9lbXB0eSh0YWcpKXsgY29udGludWUgfVxuXHRcdFx0XHRcdGRlbGV0ZSByLnRhZ3NbdGFnXTtcblx0XHRcdFx0XHRhY2sgJiYgYWNrKGVyciwgb2spO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCFxICYmIChxID0gJycpO1xuXHRcdFx0XHR2YXIgbCA9IHEubGVuZ3RoLCBpID0gMDtcblx0XHRcdFx0Ly8gVE9ETzogUEVSRjogV2h5IGlzIGFja3Mgc28gc2xvdywgd2hhdCB3b3JrIGRvIHRoZXkgZG8/Pz8gQ0hFQ0sgVEhJUyEhXG5cdFx0XHRcdC8vIFRPRE86IFBFUkY6IFdoeSBpcyBhY2tzIHNvIHNsb3csIHdoYXQgd29yayBkbyB0aGV5IGRvPz8/IENIRUNLIFRISVMhIVxuXHRcdFx0XHQvLyBUT0RPOiBQRVJGOiBXaHkgaXMgYWNrcyBzbyBzbG93LCB3aGF0IHdvcmsgZG8gdGhleSBkbz8/PyBDSEVDSyBUSElTISFcblx0XHRcdFx0Ly8gVE9ETzogUEVSRjogV2h5IGlzIGFja3Mgc28gc2xvdywgd2hhdCB3b3JrIGRvIHRoZXkgZG8/Pz8gQ0hFQ0sgVEhJUyEhXG5cdFx0XHRcdC8vIFRPRE86IFBFUkY6IFdoeSBpcyBhY2tzIHNvIHNsb3csIHdoYXQgd29yayBkbyB0aGV5IGRvPz8/IENIRUNLIFRISVMhIVxuXHRcdFx0XHQvLyBUT0RPOiBQRVJGOiBXaHkgaXMgYWNrcyBzbyBzbG93LCB3aGF0IHdvcmsgZG8gdGhleSBkbz8/PyBDSEVDSyBUSElTISFcblx0XHRcdFx0Ly8gVE9ETzogUEVSRjogV2h5IGlzIGFja3Mgc28gc2xvdywgd2hhdCB3b3JrIGRvIHRoZXkgZG8/Pz8gQ0hFQ0sgVEhJUyEhXG5cdFx0XHRcdHZhciBTID0gK25ldyBEYXRlO1xuXHRcdFx0XHRmb3IoO2kgPCBsOyBpKyspeyAoYWNrID0gcVtpXSkgJiYgYWNrKGVyciwgb2spIH1cblx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAncmFkIGFja3MnLCBlbmFtZShzLmZpbGUpKTtcblx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCBxLmxlbmd0aCwgJ3JhZCBhY2tzICMnLCBlbmFtZShzLmZpbGUpKTtcblx0XHRcdH1cblx0XHRcdGNiIHx8IChjYiA9IGZ1bmN0aW9uKGVyciwgb2speyAvLyB0ZXN0IGRlbGV0ZSFcblx0XHRcdFx0aWYoIWVycil7IHJldHVybiB9XG5cdFx0XHR9KTtcblx0XHRcdC8vY29uc29sZS5vbmx5LmkgJiYgY29uc29sZS5sb2coJ3NhdmUnLCBrZXkpO1xuXHRcdFx0ci5maW5kKGtleSwgcy5maW5kKTtcbiAgICB9XG4gICAgci5kaXNrID0ge307XG4gICAgci5vbmUgPSB7fTtcbiAgICByLnRhZ3MgPSB7fTtcblxuXHRcdC8qXG5cdFx0XHRBbnkgc3RvcmFnZSBlbmdpbmUgYXQgc29tZSBwb2ludCB3aWxsIGhhdmUgdG8gZG8gYSByZWFkIGluIG9yZGVyIHRvIHdyaXRlLlxuXHRcdFx0VGhpcyBpcyB0cnVlIG9mIGV2ZW4gc3lzdGVtcyB0aGF0IHVzZSBhbiBhcHBlbmQgb25seSBsb2csIGlmIHRoZXkgc3VwcG9ydCB1cGRhdGVzLlxuXHRcdFx0VGhlcmVmb3JlIGl0IGlzIHVuYXZvaWRhYmxlIHRoYXQgYSByZWFkIHdpbGwgaGF2ZSB0byBoYXBwZW4sXG5cdFx0XHR0aGUgcXVlc3Rpb24gaXMganVzdCBob3cgbG9uZyB5b3UgZGVsYXkgaXQuXG5cdFx0Ki9cblx0XHR2YXIgUldDID0gMDtcblx0XHRyLndyaXRlID0gZnVuY3Rpb24oZmlsZSwgcmFkLCBjYiwgbywgREJHKXtcblx0XHRcdGlmKCFyYWQpeyBjYignTm8gcmFkaXghJyk7IHJldHVybiB9XG5cdFx0XHRvID0gKCdvYmplY3QnID09IHR5cGVvZiBvKT8gbyA6IHtmb3JjZTogb307XG5cdFx0XHR2YXIgZiA9IGZ1bmN0aW9uIEZyYWN0YWwoKXt9LCBhLCBiO1xuXHRcdFx0Zi50ZXh0ID0gJyc7XG5cdFx0XHRmLmZpbGUgPSBmaWxlID0gcmFkLmZpbGUgfHwgKHJhZC5maWxlID0gZmlsZSk7XG5cdFx0XHRpZighZmlsZSl7IGNiKCdXaGF0IGZpbGU/Jyk7IHJldHVybiB9XG5cdFx0XHRmLndyaXRlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFyIHRleHQgPSByYWQucmF3ID0gZi50ZXh0O1xuXHRcdFx0XHRyLmRpc2tbZmlsZSA9IHJhZC5maWxlIHx8IGYuZmlsZSB8fCBmaWxlXSA9IHJhZDtcblx0XHRcdFx0dmFyIFMgPSArbmV3IERhdGU7XG5cdFx0XHRcdERCRyAmJiAoREJHLndkID0gUyk7XG5cdFx0XHRcdC8vY29uc29sZS5vbmx5LmkgJiYgY29uc29sZS5sb2coJ2FkZCcsIGZpbGUpO1xuXHRcdFx0XHRyLmZpbmQuYWRkKGZpbGUsIGZ1bmN0aW9uIGFkZChlcnIpe1xuXHRcdFx0XHRcdERCRyAmJiAoREJHLndhID0gK25ldyBEYXRlKTtcblx0XHRcdFx0XHRpZihlcnIpeyBjYihlcnIpOyByZXR1cm4gfVxuXHRcdFx0XHRcdC8vY29uc29sZS5vbmx5LmkgJiYgY29uc29sZS5sb2coJ2Rpc2snLCBmaWxlLCB0ZXh0KTtcblx0XHRcdFx0XHRvcHQuc3RvcmUucHV0KGVuYW1lKGZpbGUpLCB0ZXh0LCBmdW5jdGlvbiBzYWZlKGVyciwgb2spe1xuXHRcdFx0XHRcdFx0REJHICYmIChEQkcud3AgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCBTVCA9ICtuZXcgRGF0ZSAtIFMsIFwid3JvdGUgZGlza1wiLCBKU09OLnN0cmluZ2lmeShmaWxlKSwgKytSV0MsICd0b3RhbCBhbGwgd3JpdGVzLicpO1xuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLm9ubHkuaSAmJiBjb25zb2xlLmxvZygnZG9uZScsIGVyciwgb2sgfHwgMSwgY2IpO1xuXHRcdFx0XHRcdFx0Y2IoZXJyLCBvayB8fCAxKTtcblx0XHRcdFx0XHRcdGlmKCFyYWQuUSl7IGRlbGV0ZSByLmRpc2tbZmlsZV0gfSAvLyBWRVJZIElNUE9SVEFOVCEgQ2xlYW4gdXAgbWVtb3J5LCBidXQgbm90IGlmIHRoZXJlIGlzIGFscmVhZHkgcXVldWVkIHdyaXRlcyBvbiBpdCFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRmLnNwbGl0ID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFyIFMgPSArbmV3IERhdGU7XG5cdFx0XHRcdERCRyAmJiAoREJHLndmID0gUyk7XG5cdFx0XHRcdGYudGV4dCA9ICcnO1xuXHRcdFx0XHRpZighZi5jb3VudCl7IGYuY291bnQgPSAwO1xuXHRcdFx0XHRcdFJhZGl4Lm1hcChyYWQsIGZ1bmN0aW9uIGNvdW50KCl7IGYuY291bnQrKyB9KTsgLy8gVE9ETzogUGVyZj8gQW55IGZhc3RlciB3YXkgdG8gZ2V0IHRvdGFsIGxlbmd0aD9cblx0XHRcdFx0fVxuXHRcdFx0XHREQkcgJiYgKERCRy53ZmMgPSBmLmNvdW50KTtcblx0XHRcdFx0Zi5saW1pdCA9IE1hdGguY2VpbChmLmNvdW50LzIpO1xuXHRcdFx0XHR2YXIgU0MgPSBmLmNvdW50O1xuXHRcdFx0XHRmLmNvdW50ID0gMDtcblx0XHRcdFx0REJHICYmIChEQkcud2YxID0gK25ldyBEYXRlKTtcblx0XHRcdFx0Zi5zdWIgPSBSYWRpeCgpO1xuXHRcdFx0XHRSYWRpeC5tYXAocmFkLCBmLnNsaWNlLCB7cmV2ZXJzZTogMX0pOyAvLyBJTVBPUlRBTlQ6IERPIFRISVMgSU4gUkVWRVJTRSwgU08gTEFTVCBIQUxGIE9GIERBVEEgTU9WRUQgVE8gTkVXIEZJTEUgQkVGT1JFIERST1BQSU5HIEZST00gQ1VSUkVOVCBGSUxFLlxuXHRcdFx0XHREQkcgJiYgKERCRy53ZjIgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRyLndyaXRlKGYuZW5kLCBmLnN1YiwgZi5ib3RoLCBvKTtcblx0XHRcdFx0REJHICYmIChEQkcud2YzID0gK25ldyBEYXRlKTtcblx0XHRcdFx0Zi5odWIgPSBSYWRpeCgpO1xuXHRcdFx0XHRSYWRpeC5tYXAocmFkLCBmLnN0b3ApO1xuXHRcdFx0XHREQkcgJiYgKERCRy53ZjQgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRyLndyaXRlKHJhZC5maWxlLCBmLmh1YiwgZi5ib3RoLCBvKTtcblx0XHRcdFx0REJHICYmIChEQkcud2Y1ID0gK25ldyBEYXRlKTtcblx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCBcInJhZCBzcGxpdFwiLCBlbmFtZShyYWQuZmlsZSksIFNDKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRmLnNsaWNlID0gZnVuY3Rpb24odmFsLCBrZXkpe1xuXHRcdFx0XHRmLnN1YihmLmVuZCA9IGtleSwgdmFsKTtcblx0XHRcdFx0aWYoZi5saW1pdCA8PSAoKytmLmNvdW50KSl7IHJldHVybiB0cnVlIH1cblx0XHRcdH1cblx0XHRcdGYuc3RvcCA9IGZ1bmN0aW9uKHZhbCwga2V5KXtcblx0XHRcdFx0aWYoa2V5ID49IGYuZW5kKXsgcmV0dXJuIHRydWUgfVxuXHRcdFx0XHRmLmh1YihrZXksIHZhbCk7XG5cdFx0XHR9XG5cdFx0XHRmLmJvdGggPSBmdW5jdGlvbihlcnIsIG9rKXtcblx0XHRcdFx0REJHICYmIChEQkcud2ZkID0gK25ldyBEYXRlKTtcblx0XHRcdFx0aWYoYil7IGNiKGVyciB8fCBiKTsgcmV0dXJuIH1cblx0XHRcdFx0aWYoYSl7IGNiKGVyciwgb2spOyByZXR1cm4gfVxuXHRcdFx0XHRhID0gdHJ1ZTtcblx0XHRcdFx0YiA9IGVycjtcblx0XHRcdH1cblx0XHRcdGYuZWFjaCA9IGZ1bmN0aW9uKHZhbCwga2V5LCBrLCBwcmUpe1xuXHRcdFx0XHRpZih1ICE9PSB2YWwpeyBmLmNvdW50KysgfVxuXHRcdFx0XHRpZihvcHQubWF4IDw9ICh2YWx8fCcnKS5sZW5ndGgpeyByZXR1cm4gY2IoXCJEYXRhIHRvbyBiaWchXCIpLCB0cnVlIH1cblx0XHRcdFx0dmFyIGVuYyA9IFJhZGlzay5lbmNvZGUocHJlLmxlbmd0aCkgKycjJysgUmFkaXNrLmVuY29kZShrKSArICh1ID09PSB2YWw/ICcnIDogJzonKyBSYWRpc2suZW5jb2RlKHZhbCkpICsnXFxuJztcblx0XHRcdFx0aWYoKG9wdC5jaHVuayA8IGYudGV4dC5sZW5ndGggKyBlbmMubGVuZ3RoKSAmJiAoMSA8IGYuY291bnQpICYmICFvLmZvcmNlKXtcblx0XHRcdFx0XHRyZXR1cm4gZi5zcGxpdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGYudGV4dCArPSBlbmM7XG5cdFx0XHR9XG5cdFx0XHQvL2NvbnNvbGUub25seS5pICYmIGNvbnNvbGUubG9nKCd3cml0aW5nJyk7XG5cdFx0XHRpZihvcHQuanNvbmlmeSl7IHIud3JpdGUuanNvbmlmeShmLCByYWQsIGNiLCBvLCBEQkcpOyByZXR1cm4gfSAvLyB0ZW1wb3JhcnkgdGVzdGluZyBpZGVhXG5cdFx0XHRpZighUmFkaXgubWFwKHJhZCwgZi5lYWNoLCB0cnVlKSl7IGYud3JpdGUoKSB9XG5cdFx0fVxuXG5cdFx0ci53cml0ZS5qc29uaWZ5ID0gZnVuY3Rpb24oZiwgcmFkLCBjYiwgbywgREJHKXtcblx0XHRcdHZhciByYXc7XG5cdFx0XHR2YXIgUyA9ICtuZXcgRGF0ZTtcblx0XHRcdERCRyAmJiAoREJHLncgPSBTKTtcblx0XHRcdHRyeXtyYXcgPSBKU09OLnN0cmluZ2lmeShyYWQuJCk7XG5cdFx0XHR9Y2F0Y2goZSl7IGNiKFwiQ2Fubm90IHJhZGlzayFcIik7IHJldHVybiB9XG5cdFx0XHREQkcgJiYgKERCRy53cyA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKFMsICtuZXcgRGF0ZSAtIFMsIFwicmFkIHN0cmluZ2lmaWVkIEpTT05cIik7XG5cdFx0XHRpZihvcHQuY2h1bmsgPCByYXcubGVuZ3RoICYmICFvLmZvcmNlKXtcblx0XHRcdFx0dmFyIGMgPSAwO1xuXHRcdFx0XHRSYWRpeC5tYXAocmFkLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmKGMrKyl7IHJldHVybiB0cnVlIH0gLy8gbW9yZSB0aGFuIDEgaXRlbVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYoYyA+IDEpe1xuXHRcdFx0XHRcdHJldHVybiBmLnNwbGl0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGYudGV4dCA9IHJhdztcblx0XHRcdGYud3JpdGUoKTtcblx0XHR9XG5cblx0XHRyLnJhbmdlID0gZnVuY3Rpb24odHJlZSwgbyl7XG5cdFx0XHRpZighdHJlZSB8fCAhbyl7IHJldHVybiB9XG5cdFx0XHRpZih1ID09PSBvLnN0YXJ0ICYmIHUgPT09IG8uZW5kKXsgcmV0dXJuIHRyZWUgfVxuXHRcdFx0aWYoYXRvbWljKHRyZWUpKXsgcmV0dXJuIHRyZWUgfVxuXHRcdFx0dmFyIHN1YiA9IFJhZGl4KCk7XG5cdFx0XHRSYWRpeC5tYXAodHJlZSwgZnVuY3Rpb24odixrKXsgc3ViKGssdikgfSwgbyk7IC8vIE9OTFkgUExBQ0UgVEhBVCBUQUtFUyBUUkVFLCBtYXliZSByZWR1Y2UgQVBJIGZvciBiZXR0ZXIgcGVyZj9cblx0XHRcdHJldHVybiBzdWIoJycpO1xuXHRcdH1cblxuXHRcdDsoZnVuY3Rpb24oKXtcblx0XHRcdHIucmVhZCA9IGZ1bmN0aW9uKGtleSwgY2IsIG8sIERCRyl7XG5cdFx0XHRcdG8gPSBvIHx8IHt9O1xuXHRcdFx0XHR2YXIgZyA9IHtrZXk6IGtleX07XG5cdFx0XHRcdGcuZmluZCA9IGZ1bmN0aW9uKGZpbGUpeyB2YXIgdG1wO1xuXHRcdFx0XHRcdGcuZmlsZSA9IGZpbGUgfHwgKGZpbGUgPSBvcHQuY29kZS5mcm9tKTtcblx0XHRcdFx0XHREQkcgJiYgKERCRyA9IERCR1tmaWxlXSA9IERCR1tmaWxlXSB8fCB7fSk7XG5cdFx0XHRcdFx0REJHICYmIChEQkcucmYgPSBEQkcucmYgfHwgK25ldyBEYXRlKTtcblx0XHRcdFx0XHRpZih0bXAgPSByLmRpc2tbZy5maWxlID0gZmlsZV0peyBnLmNoZWNrKHUsIHRtcCk7IHJldHVybiB9XG5cdFx0XHRcdFx0ci5wYXJzZShmaWxlLCBnLmNoZWNrLCB1LCBEQkcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGcuZ2V0ID0gZnVuY3Rpb24oZXJyLCBkaXNrLCBpbmZvKXtcblx0XHRcdFx0XHREQkcgJiYgKERCRy5yZ2wgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRcdERCRyAmJiAoREJHLnJnID0gREJHLnJnIHx8ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdFx0aWYoZy5lcnIgPSBlcnIgfHwgZy5lcnIpeyBjYihlcnIpOyByZXR1cm4gfVxuXHRcdFx0XHRcdHZhciBmaWxlID0gZy5maWxlID0gKGRpc2t8fCcnKS5maWxlIHx8IGcuZmlsZTtcblx0XHRcdFx0XHRpZighZGlzayAmJiBmaWxlICE9PSBvcHQuY29kZS5mcm9tKXsgLy8gY29ycnVwdCBmaWxlP1xuXHRcdFx0XHRcdFx0ci5maW5kLmJhZChmaWxlKTsgLy8gcmVtb3ZlIGZyb20gZGlyIGxpc3Rcblx0XHRcdFx0XHRcdHIucmVhZChrZXksIGNiLCBvKTsgLy8gdHJ5IGFnYWluXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRpc2sgPSByLmRpc2tbZmlsZV0gfHwgKHIuZGlza1tmaWxlXSA9IGRpc2spO1xuXHRcdFx0XHRcdGlmKCFkaXNrKXsgY2IoZmlsZSA9PT0gb3B0LmNvZGUuZnJvbT8gdSA6IFwiTm8gZmlsZSFcIik7IHJldHVybiB9XG5cdFx0XHRcdFx0ZGlzay5maWxlIHx8IChkaXNrLmZpbGUgPSBmaWxlKTtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IHIucmFuZ2UoZGlzayhrZXkpLCBvKTtcblx0XHRcdFx0XHREQkcgJiYgKERCRy5yciA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdFx0by51bml0ID0gZGlzay51bml0O1xuXHRcdFx0XHRcdG8uY2h1bmtzID0gKG8uY2h1bmtzIHx8IDApICsgMTtcblx0XHRcdFx0XHRvLnBhcnNlZCA9IChvLnBhcnNlZCB8fCAwKSArICgoaW5mb3x8JycpLnBhcnNlZHx8KG8uY2h1bmtzKm9wdC5jaHVuaykpO1xuXHRcdFx0XHRcdG8ubW9yZSA9IDE7XG5cdFx0XHRcdFx0by5uZXh0ID0gdTtcblx0XHRcdFx0XHRSYWRpeC5tYXAoci5saXN0LCBmdW5jdGlvbiBuZXh0KHYsZil7XG5cdFx0XHRcdFx0XHRpZighdiB8fCBmaWxlID09PSBmKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRcdG8ubmV4dCA9IGY7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0XHR9LCBvLnJldmVyc2U/IHtyZXZlcnNlOiAxLCBlbmQ6IGZpbGV9IDoge3N0YXJ0OiBmaWxlfSk7XG5cdFx0XHRcdFx0REJHICYmIChEQkcucmwgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRcdGlmKCFvLm5leHQpeyBvLm1vcmUgPSAwIH1cblx0XHRcdFx0XHRpZihvLm5leHQpe1xuXHRcdFx0XHRcdFx0aWYoIW8ucmV2ZXJzZSAmJiAoKGtleSA8IG8ubmV4dCAmJiAwICE9IG8ubmV4dC5pbmRleE9mKGtleSkpIHx8ICh1ICE9PSBvLmVuZCAmJiAoby5lbmQgfHwgJ1xcdWZmZmYnKSA8IG8ubmV4dCkpKXsgby5tb3JlID0gMCB9XG5cdFx0XHRcdFx0XHRpZihvLnJldmVyc2UgJiYgKChrZXkgPiBvLm5leHQgJiYgMCAhPSBrZXkuaW5kZXhPZihvLm5leHQpKSB8fCAoKHUgIT09IG8uc3RhcnQgJiYgKG8uc3RhcnQgfHwgJycpID4gby5uZXh0ICYmIGZpbGUgPD0gby5zdGFydCkpKSl7IG8ubW9yZSA9IDAgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKDUsIHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZCk7XG5cdFx0XHRcdFx0aWYoIW8ubW9yZSl7IGNiKGcuZXJyLCBkYXRhLCBvKTsgcmV0dXJuIH1cblx0XHRcdFx0XHRpZihkYXRhKXsgY2IoZy5lcnIsIGRhdGEsIG8pIH1cblx0XHRcdFx0XHRpZihvLnBhcnNlZCA+PSBvLmxpbWl0KXsgcmV0dXJuIH1cblx0XHRcdFx0XHR2YXIgUyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0XHREQkcgJiYgKERCRy5ybSA9IFMpO1xuXHRcdFx0XHRcdHZhciBuZXh0ID0gby5uZXh0O1xuXHRcdFx0XHRcdHRpbWVkaWF0ZShmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAncmFkIG1vcmUnKTtcblx0XHRcdFx0XHRcdHIucGFyc2UobmV4dCwgZy5jaGVjayk7XG5cdFx0XHRcdFx0fSwwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRnLmNoZWNrID0gZnVuY3Rpb24oZXJyLCBkaXNrLCBpbmZvKXtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKDQsIHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZCk7XG5cdFx0XHRcdFx0Zy5nZXQoZXJyLCBkaXNrLCBpbmZvKTtcblx0XHRcdFx0XHRpZighZGlzayB8fCBkaXNrLmNoZWNrKXsgcmV0dXJuIH0gZGlzay5jaGVjayA9IDE7XG5cdFx0XHRcdFx0dmFyIFMgPSArbmV3IERhdGU7XG5cdFx0XHRcdFx0KGluZm8gfHwgKGluZm8gPSB7fSkpLmZpbGUgfHwgKGluZm8uZmlsZSA9IGcuZmlsZSk7XG5cdFx0XHRcdFx0UmFkaXgubWFwKGRpc2ssIGZ1bmN0aW9uKHZhbCwga2V5KXtcblx0XHRcdFx0XHRcdC8vIGFzc3VtZSBpbiBtZW1vcnkgZm9yIG5vdywgc2luY2UgYm90aCB3cml0ZS9yZWFkIGFscmVhZHkgY2FsbCByLmZpbmQgd2hpY2ggd2lsbCBpbml0IGl0LlxuXHRcdFx0XHRcdFx0ci5maW5kKGtleSwgZnVuY3Rpb24oZmlsZSl7XG5cdFx0XHRcdFx0XHRcdGlmKChmaWxlIHx8IChmaWxlID0gb3B0LmNvZGUuZnJvbSkpID09PSBpbmZvLmZpbGUpeyByZXR1cm4gfVxuXHRcdFx0XHRcdFx0XHR2YXIgaWQgPSAoJycrTWF0aC5yYW5kb20oKSkuc2xpY2UoLTMpO1xuXHRcdFx0XHRcdFx0XHRwdWZmKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdHIuc2F2ZShrZXksIHZhbCwgZnVuY3Rpb24gYWNrKGVyciwgb2spe1xuXHRcdFx0XHRcdFx0XHRcdGlmKGVycil7IHIuc2F2ZShrZXksIHZhbCwgYWNrKTsgcmV0dXJuIH0gLy8gYWQgaW5maW5pdHVtPz8/XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogTk9URSEhISBNaXNsb2NhdGVkIGRhdGEgY291bGQgYmUgYmVjYXVzZSBvZiBhIHN5bmNocm9ub3VzIGBwdXRgIGZyb20gdGhlIGBnLmdldChgIG90aGVyIHRoYW4gcGVyZiBzaG91bGRuJ3Qgd2UgZG8gdGhlIGNoZWNrIGZpcnN0IGJlZm9yZSBhY2tpbmc/XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChcIk1JU0xPQ0FURUQgREFUQSBDT1JSRUNURURcIiwgaWQsIGVuYW1lKGtleSksIGVuYW1lKGluZm8uZmlsZSksIGVuYW1lKGZpbGUpKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH0sMCk7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgK25ldyBEYXRlIC0gUywgXCJyYWQgY2hlY2tcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ci5maW5kKGtleSB8fCAoby5yZXZlcnNlPyAoby5lbmR8fCcnKSA6IChvLnN0YXJ0fHwnJykpLCBnLmZpbmQpOyBcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIHJldihhLGIpeyByZXR1cm4gYiB9XG5cdFx0XHR2YXIgcmV2byA9IHtyZXZlcnNlOiB0cnVlfTtcblx0XHR9KCkpO1xuXG5cdFx0OyhmdW5jdGlvbigpe1xuXHRcdFx0Lypcblx0XHRcdFx0TGV0IHVzIHN0YXJ0IGJ5IGFzc3VtaW5nIHdlIGFyZSB0aGUgb25seSBwcm9jZXNzIHRoYXQgaXNcblx0XHRcdFx0Y2hhbmdpbmcgdGhlIGRpcmVjdG9yeSBvciBidWNrZXQuIE5vdCBiZWNhdXNlIHdlIGRvIG5vdCB3YW50XG5cdFx0XHRcdHRvIGJlIG11bHRpLXByb2Nlc3MvbWFjaGluZSwgYnV0IGJlY2F1c2Ugd2Ugd2FudCB0byBleHBlcmltZW50XG5cdFx0XHRcdHdpdGggaG93IG11Y2ggcGVyZm9ybWFuY2UgYW5kIHNjYWxlIHdlIGNhbiBnZXQgb3V0IG9mIG9ubHkgb25lLlxuXHRcdFx0XHRUaGVuIHdlIGNhbiB3b3JrIG9uIHRoZSBoYXJkZXIgcHJvYmxlbSBvZiBiZWluZyBtdWx0aS1wcm9jZXNzLlxuXHRcdFx0Ki9cblx0XHRcdHZhciBSUEMgPSAwO1xuXHRcdFx0dmFyIFEgPSB7fSwgcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzEpO1xuXHRcdFx0ci5wYXJzZSA9IGZ1bmN0aW9uKGZpbGUsIGNiLCByYXcsIERCRyl7IHZhciBxO1xuXHRcdFx0XHRpZighZmlsZSl7IHJldHVybiBjYigpOyB9XG5cdFx0XHRcdGlmKHEgPSBRW2ZpbGVdKXsgcS5wdXNoKGNiKTsgcmV0dXJuIH0gcSA9IFFbZmlsZV0gPSBbY2JdO1xuXHRcdFx0XHR2YXIgcCA9IGZ1bmN0aW9uIFBhcnNlKCl7fSwgaW5mbyA9IHtmaWxlOiBmaWxlfTtcblx0XHRcdFx0KHAuZGlzayA9IFJhZGl4KCkpLmZpbGUgPSBmaWxlO1xuXHRcdFx0XHRwLnJlYWQgPSBmdW5jdGlvbihlcnIsIGRhdGEpeyB2YXIgdG1wO1xuXHRcdFx0XHRcdERCRyAmJiAoREJHLnJwZyA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAncmVhZCBkaXNrJywgSlNPTi5zdHJpbmdpZnkoZmlsZSksICsrUlBDLCAndG90YWwgYWxsIHBhcnNlcy4nKTtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKDIsIHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZCk7XG5cdFx0XHRcdFx0aWYoKHAuZXJyID0gZXJyKSB8fCAocC5ub3QgPSAhZGF0YSkpe1xuXHRcdFx0XHRcdFx0ZGVsZXRlIFFbZmlsZV07XG5cdFx0XHRcdFx0XHRwLm1hcChxLCBwLmFjayk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCdzdHJpbmcnICE9PSB0eXBlb2YgZGF0YSl7XG5cdFx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHRcdGlmKG9wdC5tYXggPD0gZGF0YS5sZW5ndGgpe1xuXHRcdFx0XHRcdFx0XHRcdHAuZXJyID0gXCJDaHVuayB0b28gYmlnIVwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7IC8vIElmIGl0IGNyYXNoZXMsIGl0IGNyYXNoZXMgaGVyZS4gSG93IT8/IFdlIGNoZWNrIHNpemUgZmlyc3QhXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1jYXRjaChlKXsgcC5lcnIgPSBlIH1cblx0XHRcdFx0XHRcdGlmKHAuZXJyKXtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIFFbZmlsZV07XG5cdFx0XHRcdFx0XHRcdHAubWFwKHEsIHAuYWNrKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbmZvLnBhcnNlZCA9IGRhdGEubGVuZ3RoO1xuXHRcdFx0XHRcdERCRyAmJiAoREJHLnJwbCA9IGluZm8ucGFyc2VkKTtcblx0XHRcdFx0XHREQkcgJiYgKERCRy5ycGEgPSBxLmxlbmd0aCk7XG5cdFx0XHRcdFx0UyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0XHRpZighKG9wdC5qc29uaWZ5IHx8ICd7JyA9PT0gZGF0YVswXSkpe1xuXHRcdFx0XHRcdFx0cC5yYWRlYyhlcnIsIGRhdGEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJzZShkYXRhLCBmdW5jdGlvbihlcnIsIHRyZWUpe1xuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygzLCBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQpO1xuXHRcdFx0XHRcdFx0aWYoIWVycil7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBRW2ZpbGVdO1xuXHRcdFx0XHRcdFx0XHRwLmRpc2suJCA9IHRyZWU7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiAoU1QgPSArbmV3IERhdGUgLSBTKSA+IDkgJiYgY29uc29sZS5TVEFUKFMsIFNULCAncmFkIHBhcnNlZCBKU09OJyk7XG5cdFx0XHRcdFx0XHRcdERCRyAmJiAoREJHLnJwZCA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdFx0XHRcdHAubWFwKHEsIHAuYWNrKTsgLy8gaG1tbSwgdjggcHJvZmlsZXIgY2FuJ3Qgc2VlIGludG8gdGhpcyBjYXVzZSBvZiB0cnkvY2F0Y2g/XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCd7JyA9PT0gZGF0YVswXSl7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBRW2ZpbGVdO1xuXHRcdFx0XHRcdFx0XHRwLmVyciA9IHRtcCB8fCBcIkpTT04gZXJyb3IhXCI7XG5cdFx0XHRcdFx0XHRcdHAubWFwKHEsIHAuYWNrKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cC5yYWRlYyhlcnIsIGRhdGEpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHAubWFwID0gZnVuY3Rpb24oKXsgLy8gc3dpdGNoIHRvIHNldFRpbWVvdXQuZWFjaCBub3c/XG5cdFx0XHRcdFx0aWYoIXEgfHwgIXEubGVuZ3RoKXsgcmV0dXJuIH1cblx0XHRcdFx0XHQvL3ZhciBpID0gMCwgbCA9IHEubGVuZ3RoLCBhY2s7XG5cdFx0XHRcdFx0dmFyIFMgPSArbmV3IERhdGU7XG5cdFx0XHRcdFx0dmFyIGVyciA9IHAuZXJyLCBkYXRhID0gcC5ub3Q/IHUgOiBwLmRpc2s7XG5cdFx0XHRcdFx0dmFyIGkgPSAwLCBhY2s7IHdoaWxlKGkgPCA5ICYmIChhY2sgPSBxW2krK10pKXsgYWNrKGVyciwgZGF0YSwgaW5mbykgfSAvLyB0b28gbXVjaD9cblx0XHRcdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKFMsICtuZXcgRGF0ZSAtIFMsICdyYWQgcGFja3MnLCBlbmFtZShmaWxlKSk7XG5cdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCBpLCAncmFkIHBhY2tzICMnLCBlbmFtZShmaWxlKSk7IFxuXHRcdFx0XHRcdGlmKCEocSA9IHEuc2xpY2UoaSkpLmxlbmd0aCl7IHJldHVybiB9XG5cdFx0XHRcdFx0cHVmZihwLm1hcCwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cC5hY2sgPSBmdW5jdGlvbihjYil7XG5cdFx0XHRcdFx0aWYoIWNiKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRpZihwLmVyciB8fCBwLm5vdCl7XG5cdFx0XHRcdFx0XHRjYihwLmVyciwgdSwgaW5mbyk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNiKHUsIHAuZGlzaywgaW5mbyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cC5yYWRlYyA9IGZ1bmN0aW9uKGVyciwgZGF0YSl7XG5cdFx0XHRcdFx0ZGVsZXRlIFFbZmlsZV07XG5cdFx0XHRcdFx0UyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0XHR2YXIgdG1wID0gcC5zcGxpdChkYXRhKSwgcHJlID0gW10sIGksIGssIHY7XG5cdFx0XHRcdFx0aWYoIXRtcCB8fCAwICE9PSB0bXBbMV0pe1xuXHRcdFx0XHRcdFx0cC5lcnIgPSBcIkZpbGUgJ1wiK2ZpbGUrXCInIGRvZXMgbm90IGhhdmUgcm9vdCByYWRpeCEgXCI7XG5cdFx0XHRcdFx0XHRwLm1hcChxLCBwLmFjayk7XG5cdFx0XHRcdFx0XHRyZXR1cm47IFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSh0bXApe1xuXHRcdFx0XHRcdFx0ayA9IHYgPSB1O1xuXHRcdFx0XHRcdFx0aSA9IHRtcFsxXTtcblx0XHRcdFx0XHRcdHRtcCA9IHAuc3BsaXQodG1wWzJdKXx8Jyc7XG5cdFx0XHRcdFx0XHRpZignIycgPT0gdG1wWzBdKXtcblx0XHRcdFx0XHRcdFx0ayA9IHRtcFsxXTtcblx0XHRcdFx0XHRcdFx0cHJlID0gcHJlLnNsaWNlKDAsaSk7XG5cdFx0XHRcdFx0XHRcdGlmKGkgPD0gcHJlLmxlbmd0aCl7XG5cdFx0XHRcdFx0XHRcdFx0cHJlLnB1c2goayk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRtcCA9IHAuc3BsaXQodG1wWzJdKXx8Jyc7XG5cdFx0XHRcdFx0XHRpZignXFxuJyA9PSB0bXBbMF0peyBjb250aW51ZSB9XG5cdFx0XHRcdFx0XHRpZignPScgPT0gdG1wWzBdIHx8ICc6JyA9PSB0bXBbMF0peyB2ID0gdG1wWzFdIH1cblx0XHRcdFx0XHRcdGlmKHUgIT09IGsgJiYgdSAhPT0gdil7IHAuZGlzayhwcmUuam9pbignJyksIHYpIH1cblx0XHRcdFx0XHRcdHRtcCA9IHAuc3BsaXQodG1wWzJdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAncGFyc2VkIFJBRCcpO1xuXHRcdFx0XHRcdHAubWFwKHEsIHAuYWNrKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cC5zcGxpdCA9IGZ1bmN0aW9uKHQpe1xuXHRcdFx0XHRcdGlmKCF0KXsgcmV0dXJuIH1cblx0XHRcdFx0XHR2YXIgbCA9IFtdLCBvID0ge30sIGkgPSAtMSwgYSA9ICcnLCBiLCBjO1xuXHRcdFx0XHRcdGkgPSB0LmluZGV4T2Yocyk7XG5cdFx0XHRcdFx0aWYoIXRbaV0peyByZXR1cm4gfVxuXHRcdFx0XHRcdGEgPSB0LnNsaWNlKDAsIGkpO1xuXHRcdFx0XHRcdGxbMF0gPSBhO1xuXHRcdFx0XHRcdGxbMV0gPSBiID0gUmFkaXNrLmRlY29kZSh0LnNsaWNlKGkpLCBvKTtcblx0XHRcdFx0XHRsWzJdID0gdC5zbGljZShpICsgby5pKTtcblx0XHRcdFx0XHRyZXR1cm4gbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihyLmRpc2speyByYXcgfHwgKHJhdyA9IChyLmRpc2tbZmlsZV18fCcnKS5yYXcpIH1cblx0XHRcdFx0dmFyIFMgPSArbmV3IERhdGUsIFNNLCBTTDtcblx0XHRcdFx0REJHICYmIChEQkcucnAgPSBTKTtcblx0XHRcdFx0aWYocmF3KXsgcmV0dXJuIHB1ZmYoZnVuY3Rpb24oKXsgcC5yZWFkKHUsIHJhdykgfSwgMCkgfVxuXHRcdFx0XHRvcHQuc3RvcmUuZ2V0KGVuYW1lKGZpbGUpLCBwLnJlYWQpO1xuXHRcdFx0XHQvLyBUT0RPOiBXaGF0IGlmIG1lbW9yeSBkaXNrIGdldHMgZmlsbGVkIHdpdGggdXBkYXRlcywgYW5kIHdlIGdldCBhbiBvbGQgb25lIGJhY2s/XG5cdFx0XHR9XG5cdFx0fSgpKTtcblxuXHRcdDsoZnVuY3Rpb24oKXtcblx0XHRcdHZhciBkaXIsIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI4KSwgUTtcblx0XHRcdHIuZmluZCA9IGZ1bmN0aW9uKGtleSwgY2Ipe1xuXHRcdFx0XHRpZighZGlyKXtcblx0XHRcdFx0XHRpZihRKXsgUS5wdXNoKFtrZXksIGNiXSk7IHJldHVybiB9IFEgPSBbW2tleSwgY2JdXTtcblx0XHRcdFx0XHRyLnBhcnNlKGYsIGluaXQpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRSYWRpeC5tYXAoci5saXN0ID0gZGlyLCBmdW5jdGlvbih2YWwsIGtleSl7XG5cdFx0XHRcdFx0aWYoIXZhbCl7IHJldHVybiB9XG5cdFx0XHRcdFx0cmV0dXJuIGNiKGtleSkgfHwgdHJ1ZTtcblx0XHRcdFx0fSwge3JldmVyc2U6IDEsIGVuZDoga2V5fSkgfHwgY2Iob3B0LmNvZGUuZnJvbSk7XG5cdFx0XHR9XG5cdFx0XHRyLmZpbmQuYWRkID0gZnVuY3Rpb24oZmlsZSwgY2Ipe1xuXHRcdFx0XHR2YXIgaGFzID0gZGlyKGZpbGUpO1xuXHRcdFx0XHRpZihoYXMgfHwgZmlsZSA9PT0gZil7IGNiKHUsIDEpOyByZXR1cm4gfVxuXHRcdFx0XHRkaXIoZmlsZSwgMSk7XG5cdFx0XHRcdGNiLmZvdW5kID0gKGNiLmZvdW5kIHx8IDApICsgMTtcblx0XHRcdFx0ci53cml0ZShmLCBkaXIsIGZ1bmN0aW9uKGVyciwgb2spe1xuXHRcdFx0XHRcdGlmKGVycil7IGNiKGVycik7IHJldHVybiB9XG5cdFx0XHRcdFx0Y2IuZm91bmQgPSAoY2IuZm91bmQgfHwgMCkgLSAxO1xuXHRcdFx0XHRcdGlmKDAgIT09IGNiLmZvdW5kKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRjYih1LCAxKTtcblx0XHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyLmZpbmQuYmFkID0gZnVuY3Rpb24oZmlsZSwgY2Ipe1xuXHRcdFx0XHRkaXIoZmlsZSwgMCk7XG5cdFx0XHRcdHIud3JpdGUoZiwgZGlyLCBjYnx8bm9vcCk7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBpbml0KGVyciwgZGlzayl7XG5cdFx0XHRcdGlmKGVycil7XG5cdFx0XHRcdFx0b3B0LmxvZygnbGlzdCcsIGVycik7XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpeyByLnBhcnNlKGYsIGluaXQpIH0sIDEwMDApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihkaXNrKXsgZHJhaW4oZGlzayk7IHJldHVybiB9XG5cdFx0XHRcdGRpciA9IGRpciB8fCBkaXNrIHx8IFJhZGl4KCk7XG5cdFx0XHRcdGlmKCFvcHQuc3RvcmUubGlzdCl7IGRyYWluKGRpcik7IHJldHVybiB9XG5cdFx0XHRcdC8vIGltcG9ydCBkaXJlY3RvcnkuXG5cdFx0XHRcdG9wdC5zdG9yZS5saXN0KGZ1bmN0aW9uKGZpbGUpe1xuXHRcdFx0XHRcdGlmKCFmaWxlKXsgZHJhaW4oZGlyKTsgcmV0dXJuIH1cblx0XHRcdFx0XHRyLmZpbmQuYWRkKGZpbGUsIG5vb3ApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIGRyYWluKHJhZCwgdG1wKXtcblx0XHRcdFx0ZGlyID0gZGlyIHx8IHJhZDtcblx0XHRcdFx0ZGlyLmZpbGUgPSBmO1xuXHRcdFx0XHR0bXAgPSBROyBRID0gbnVsbDtcblx0XHRcdFx0bWFwKHRtcCwgZnVuY3Rpb24oYXJnKXtcblx0XHRcdFx0XHRyLmZpbmQoYXJnWzBdLCBhcmdbMV0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KCkpO1xuXG5cdFx0dHJ5eyAhR3VuLndpbmRvdyAmJiByZXF1aXJlKCcuL3JhZG1pZ3RtcCcpKHIpIH1jYXRjaChlKXt9XG5cblx0XHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCl7fSwgUkFELCB1O1xuXHRcdFJhZGlzay5oYXNbb3B0LmZpbGVdID0gcjtcblx0XHRyZXR1cm4gcjtcblx0fVxuXG5cdDsoZnVuY3Rpb24oKXtcblx0XHR2YXIgXyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzEpLCB1O1xuXHRcdFJhZGlzay5lbmNvZGUgPSBmdW5jdGlvbihkLCBvLCBzKXsgcyA9IHMgfHwgXztcblx0XHRcdHZhciB0ID0gcywgdG1wO1xuXHRcdFx0aWYodHlwZW9mIGQgPT0gJ3N0cmluZycpe1xuXHRcdFx0XHR2YXIgaSA9IGQuaW5kZXhPZihzKTtcblx0XHRcdFx0d2hpbGUoaSAhPSAtMSl7IHQgKz0gczsgaSA9IGQuaW5kZXhPZihzLCBpKzEpIH1cblx0XHRcdFx0cmV0dXJuIHQgKyAnXCInICsgZCArIHM7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmKGQgJiYgZFsnIyddICYmIDEgPT0gT2JqZWN0LmtleXMoZCkubGVuZ3RoKXtcblx0XHRcdFx0cmV0dXJuIHQgKyAnIycgKyB0bXAgKyB0O1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRpZignbnVtYmVyJyA9PSB0eXBlb2YgZCl7XG5cdFx0XHRcdHJldHVybiB0ICsgJysnICsgKGR8fDApICsgdDtcblx0XHRcdH0gZWxzZVxuXHRcdFx0aWYobnVsbCA9PT0gZCl7XG5cdFx0XHRcdHJldHVybiB0ICsgJyAnICsgdDtcblx0XHRcdH0gZWxzZVxuXHRcdFx0aWYodHJ1ZSA9PT0gZCl7XG5cdFx0XHRcdHJldHVybiB0ICsgJysnICsgdDtcblx0XHRcdH0gZWxzZVxuXHRcdFx0aWYoZmFsc2UgPT09IGQpe1xuXHRcdFx0XHRyZXR1cm4gdCArICctJyArIHQ7XG5cdFx0XHR9Ly8gZWxzZVxuXHRcdFx0Ly9pZihiaW5hcnkpe31cblx0XHR9XG5cdFx0UmFkaXNrLmRlY29kZSA9IGZ1bmN0aW9uKHQsIG8sIHMpeyBzID0gcyB8fCBfO1xuXHRcdFx0dmFyIGQgPSAnJywgaSA9IC0xLCBuID0gMCwgYywgcDtcblx0XHRcdGlmKHMgIT09IHRbMF0peyByZXR1cm4gfVxuXHRcdFx0d2hpbGUocyA9PT0gdFsrK2ldKXsgKytuIH1cblx0XHRcdHAgPSB0W2MgPSBuXSB8fCB0cnVlO1xuXHRcdFx0d2hpbGUoLS1uID49IDApeyBpID0gdC5pbmRleE9mKHMsIGkrMSkgfVxuXHRcdFx0aWYoaSA9PSAtMSl7IGkgPSB0Lmxlbmd0aCB9XG5cdFx0XHRkID0gdC5zbGljZShjKzEsIGkpO1xuXHRcdFx0aWYobyl7IG8uaSA9IGkrMSB9XG5cdFx0XHRpZignXCInID09PSBwKXtcblx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmKCcjJyA9PT0gcCl7XG5cdFx0XHRcdHJldHVybiB7JyMnOmR9O1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRpZignKycgPT09IHApe1xuXHRcdFx0XHRpZigwID09PSBkLmxlbmd0aCl7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQoZCk7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmKCcgJyA9PT0gcCl7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRpZignLScgPT09IHApe1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpO1xuXG5cdGlmKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpe1xuXHQgIHZhciBHdW4gPSB3aW5kb3cuR3VuO1xuXHQgIHZhciBSYWRpeCA9IHdpbmRvdy5SYWRpeDtcblx0ICB3aW5kb3cuUmFkaXNrID0gUmFkaXNrO1xuXHR9IGVsc2UgeyBcblx0ICB2YXIgR3VuID0gcmVxdWlyZSgnLi4vZ3VuJyk7XG5cdFx0dmFyIFJhZGl4ID0gcmVxdWlyZSgnLi9yYWRpeCcpO1xuXHRcdC8vdmFyIFJhZGl4ID0gcmVxdWlyZSgnLi9yYWRpeDInKTsgUmFkaXNrID0gcmVxdWlyZSgnLi9yYWRpc2syJyk7XG5cdFx0dHJ5eyBtb2R1bGUuZXhwb3J0cyA9IFJhZGlzayB9Y2F0Y2goZSl7fVxuXHR9XG5cblx0UmFkaXNrLlJhZGl4ID0gUmFkaXg7XG5cbn0oKSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/radisk.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/radix.js":
/*!***************************************!*\
  !*** ./node_modules/gun/lib/radix.js ***!
  \***************************************/
/***/ ((module) => {

eval(";(function(){\n\n\tfunction Radix(){\n\t\tvar radix = function(key, val, t){\n\t\t\tradix.unit = 0;\n\t\t\tif(!t && u !== val){ \n\t\t\t\tradix.last = (''+key < radix.last)? radix.last : ''+key;\n\t\t\t\tdelete (radix.$||{})[_];\n\t\t\t}\n\t\t\tt = t || radix.$ || (radix.$ = {});\n\t\t\tif(!key && Object.keys(t).length){ return t }\n\t\t\tkey = ''+key;\n\t\t\tvar i = 0, l = key.length-1, k = key[i], at, tmp;\n\t\t\twhile(!(at = t[k]) && i < l){\n\t\t\t\tk += key[++i];\n\t\t\t}\n\t\t\tif(!at){\n\t\t\t\tif(!each(t, function(r, s){\n\t\t\t\t\tvar ii = 0, kk = '';\n\t\t\t\t\tif((s||'').length){ while(s[ii] == key[ii]){\n\t\t\t\t\t\tkk += s[ii++];\n\t\t\t\t\t} }\n\t\t\t\t\tif(kk){\n\t\t\t\t\t\tif(u === val){\n\t\t\t\t\t\t\tif(ii <= l){ return }\n\t\t\t\t\t\t\t(tmp || (tmp = {}))[s.slice(ii)] = r;\n\t\t\t\t\t\t\t//(tmp[_] = function $(){ $.sort = Object.keys(tmp).sort(); return $ }()); // get rid of this one, cause it is on read?\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar __ = {};\n\t\t\t\t\t\t__[s.slice(ii)] = r;\n\t\t\t\t\t\tii = key.slice(ii);\n\t\t\t\t\t\t('' === ii)? (__[''] = val) : ((__[ii] = {})[''] = val);\n\t\t\t\t\t\t//(__[_] = function $(){ $.sort = Object.keys(__).sort(); return $ }());\n\t\t\t\t\t\tt[kk] = __;\n\t\t\t\t\t\tif(Radix.debug && 'undefined' === ''+kk){ console.log(0, kk); debugger }\n\t\t\t\t\t\tdelete t[s];\n\t\t\t\t\t\t//(t[_] = function $(){ $.sort = Object.keys(t).sort(); return $ }());\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t})){\n\t\t\t\t\tif(u === val){ return; }\n\t\t\t\t\t(t[k] || (t[k] = {}))[''] = val;\n\t\t\t\t\tif(Radix.debug && 'undefined' === ''+k){ console.log(1, k); debugger }\n\t\t\t\t\t//(t[_] = function $(){ $.sort = Object.keys(t).sort(); return $ }());\n\t\t\t\t}\n\t\t\t\tif(u === val){\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t} else \n\t\t\tif(i == l){\n\t\t\t\t//if(u === val){ return (u === (tmp = at['']))? at : tmp } // THIS CODE IS CORRECT, below is\n\t\t\t\tif(u === val){ return (u === (tmp = at['']))? at : ((radix.unit = 1) && tmp) } // temporary help??\n\t\t\t\tat[''] = val;\n\t\t\t\t//(at[_] = function $(){ $.sort = Object.keys(at).sort(); return $ }());\n\t\t\t} else {\n\t\t\t\tif(u !== val){ delete at[_] }\n\t\t\t\t//at && (at[_] = function $(){ $.sort = Object.keys(at).sort(); return $ }());\n\t\t\t\treturn radix(key.slice(++i), val, at || (at = {}));\n\t\t\t}\n\t\t}\n\t\treturn radix;\n\t};\n\n\tRadix.map = function rap(radix, cb, opt, pre){\n\t\ttry {\n\t\t\tpre = pre || []; // TODO: BUG: most out-of-memory crashes come from here.\n\t\t\tvar t = ('function' == typeof radix)? radix.$ || {} : radix;\n\t\t\t//!opt && console.log(\"WHAT IS T?\", JSON.stringify(t).length);\n\t\t\tif(!t){ return }\n\t\t\tif('string' == typeof t){ if(Radix.debug){ throw ['BUG:', radix, cb, opt, pre] } return; }\n\t\t\tvar keys = (t[_]||no).sort || (t[_] = function $(){ $.sort = Object.keys(t).sort(); return $ }()).sort, rev; // ONLY 17% of ops are pre-sorted!\n\t\t\t//var keys = Object.keys(t).sort();\n\t\t\topt = (true === opt)? {branch: true} : (opt || {});\n\t\t\tif(rev = opt.reverse){ keys = keys.slice(0).reverse() }\n\t\t\tvar start = opt.start, end = opt.end, END = '\\uffff';\n\t\t\tvar i = 0, l = keys.length;\n\t\t\tfor(;i < l; i++){ var key = keys[i], tree = t[key], tmp, p, pt;\n\t\t\t\tif(!tree || '' === key || _ === key || 'undefined' === key){ continue }\n\t\t\t\tp = pre.slice(0); p.push(key);\n\t\t\t\tpt = p.join('');\n\t\t\t\tif(u !== start && pt < (start||'').slice(0,pt.length)){ continue }\n\t\t\t\tif(u !== end && (end || END) < pt){ continue }\n\t\t\t\tif(rev){ // children must be checked first when going in reverse.\n\t\t\t\t\ttmp = rap(tree, cb, opt, p);\n\t\t\t\t\tif(u !== tmp){ return tmp }\n\t\t\t\t}\n\t\t\t\tif(u !== (tmp = tree[''])){\n\t\t\t\t\tvar yes = 1;\n\t\t\t\t\tif(u !== start && pt < (start||'')){ yes = 0 }\n\t\t\t\t\tif(u !== end && pt > (end || END)){ yes = 0 }\n\t\t\t\t\tif(yes){\n\t\t\t\t\t\ttmp = cb(tmp, pt, key, pre);\n\t\t\t\t\t\tif(u !== tmp){ return tmp }\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\tif(opt.branch){\n\t\t\t\t\ttmp = cb(u, pt, key, pre);\n\t\t\t\t\tif(u !== tmp){ return tmp }\n\t\t\t\t}\n\t\t\t\tpre = p;\n\t\t\t\tif(!rev){\n\t\t\t\t\ttmp = rap(tree, cb, opt, pre);\n\t\t\t\t\tif(u !== tmp){ return tmp }\n\t\t\t\t}\n\t\t\t\tpre.pop();\n\t\t\t}\n\t\t} catch (e) { console.error(e); }\n\t};\n\n\tif(typeof window !== \"undefined\"){\n\t  window.Radix = Radix;\n\t} else { \n\t\ttry{ module.exports = Radix }catch(e){}\n\t}\n\tvar each = Radix.object = function(o, f, r){\n\t\tfor(var k in o){\n\t\t\tif(!o.hasOwnProperty(k)){ continue }\n\t\t\tif((r = f(o[k], k)) !== u){ return r }\n\t\t}\n\t}, no = {}, u;\n\tvar _ = String.fromCharCode(24);\n\t\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9yYWRpeC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLGlDQUFpQyxrQ0FBa0MsVUFBVSxLQUFLO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsK0JBQStCLGlDQUFpQyxVQUFVO0FBQzFFO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBLDhCQUE4QixnQ0FBZ0MsVUFBVTtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsOENBQThDLG1CQUFtQjtBQUNqRSw2QkFBNkIsZ0NBQWdDLFVBQVU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9ELG1CQUFtQixnRUFBZ0U7QUFDbkY7QUFDQSw2QkFBNkIsaUNBQWlDLFVBQVU7QUFDeEUsS0FBSztBQUNMLG1CQUFtQjtBQUNuQixtQ0FBbUMsaUNBQWlDLFVBQVU7QUFDOUUsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsdURBQXVEO0FBQ3ZEO0FBQ0EsV0FBVztBQUNYLDZCQUE2QixpQkFBaUIsc0NBQXNDO0FBQ3BGLHVEQUF1RCxnQ0FBZ0MsVUFBVSxlQUFlO0FBQ2hIO0FBQ0EsMEJBQTBCLGNBQWMsWUFBWTtBQUNwRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLFFBQVEsT0FBTyxNQUFNO0FBQ3JCLGlFQUFpRTtBQUNqRSxzQkFBc0I7QUFDdEI7QUFDQSw0REFBNEQ7QUFDNUQsd0NBQXdDO0FBQ3hDLGFBQWE7QUFDYjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQVk7QUFDaEI7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxPQUFPLHdCQUF3QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CO0FBQ0EsRUFBRSxTQUFTO0FBQ1g7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIzLWNoYXQvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9yYWRpeC5qcz83NjVkIl0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24oKXtcblxuXHRmdW5jdGlvbiBSYWRpeCgpe1xuXHRcdHZhciByYWRpeCA9IGZ1bmN0aW9uKGtleSwgdmFsLCB0KXtcblx0XHRcdHJhZGl4LnVuaXQgPSAwO1xuXHRcdFx0aWYoIXQgJiYgdSAhPT0gdmFsKXsgXG5cdFx0XHRcdHJhZGl4Lmxhc3QgPSAoJycra2V5IDwgcmFkaXgubGFzdCk/IHJhZGl4Lmxhc3QgOiAnJytrZXk7XG5cdFx0XHRcdGRlbGV0ZSAocmFkaXguJHx8e30pW19dO1xuXHRcdFx0fVxuXHRcdFx0dCA9IHQgfHwgcmFkaXguJCB8fCAocmFkaXguJCA9IHt9KTtcblx0XHRcdGlmKCFrZXkgJiYgT2JqZWN0LmtleXModCkubGVuZ3RoKXsgcmV0dXJuIHQgfVxuXHRcdFx0a2V5ID0gJycra2V5O1xuXHRcdFx0dmFyIGkgPSAwLCBsID0ga2V5Lmxlbmd0aC0xLCBrID0ga2V5W2ldLCBhdCwgdG1wO1xuXHRcdFx0d2hpbGUoIShhdCA9IHRba10pICYmIGkgPCBsKXtcblx0XHRcdFx0ayArPSBrZXlbKytpXTtcblx0XHRcdH1cblx0XHRcdGlmKCFhdCl7XG5cdFx0XHRcdGlmKCFlYWNoKHQsIGZ1bmN0aW9uKHIsIHMpe1xuXHRcdFx0XHRcdHZhciBpaSA9IDAsIGtrID0gJyc7XG5cdFx0XHRcdFx0aWYoKHN8fCcnKS5sZW5ndGgpeyB3aGlsZShzW2lpXSA9PSBrZXlbaWldKXtcblx0XHRcdFx0XHRcdGtrICs9IHNbaWkrK107XG5cdFx0XHRcdFx0fSB9XG5cdFx0XHRcdFx0aWYoa2spe1xuXHRcdFx0XHRcdFx0aWYodSA9PT0gdmFsKXtcblx0XHRcdFx0XHRcdFx0aWYoaWkgPD0gbCl7IHJldHVybiB9XG5cdFx0XHRcdFx0XHRcdCh0bXAgfHwgKHRtcCA9IHt9KSlbcy5zbGljZShpaSldID0gcjtcblx0XHRcdFx0XHRcdFx0Ly8odG1wW19dID0gZnVuY3Rpb24gJCgpeyAkLnNvcnQgPSBPYmplY3Qua2V5cyh0bXApLnNvcnQoKTsgcmV0dXJuICQgfSgpKTsgLy8gZ2V0IHJpZCBvZiB0aGlzIG9uZSwgY2F1c2UgaXQgaXMgb24gcmVhZD9cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgX18gPSB7fTtcblx0XHRcdFx0XHRcdF9fW3Muc2xpY2UoaWkpXSA9IHI7XG5cdFx0XHRcdFx0XHRpaSA9IGtleS5zbGljZShpaSk7XG5cdFx0XHRcdFx0XHQoJycgPT09IGlpKT8gKF9fWycnXSA9IHZhbCkgOiAoKF9fW2lpXSA9IHt9KVsnJ10gPSB2YWwpO1xuXHRcdFx0XHRcdFx0Ly8oX19bX10gPSBmdW5jdGlvbiAkKCl7ICQuc29ydCA9IE9iamVjdC5rZXlzKF9fKS5zb3J0KCk7IHJldHVybiAkIH0oKSk7XG5cdFx0XHRcdFx0XHR0W2trXSA9IF9fO1xuXHRcdFx0XHRcdFx0aWYoUmFkaXguZGVidWcgJiYgJ3VuZGVmaW5lZCcgPT09ICcnK2trKXsgY29uc29sZS5sb2coMCwga2spOyBkZWJ1Z2dlciB9XG5cdFx0XHRcdFx0XHRkZWxldGUgdFtzXTtcblx0XHRcdFx0XHRcdC8vKHRbX10gPSBmdW5jdGlvbiAkKCl7ICQuc29ydCA9IE9iamVjdC5rZXlzKHQpLnNvcnQoKTsgcmV0dXJuICQgfSgpKTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpe1xuXHRcdFx0XHRcdGlmKHUgPT09IHZhbCl7IHJldHVybjsgfVxuXHRcdFx0XHRcdCh0W2tdIHx8ICh0W2tdID0ge30pKVsnJ10gPSB2YWw7XG5cdFx0XHRcdFx0aWYoUmFkaXguZGVidWcgJiYgJ3VuZGVmaW5lZCcgPT09ICcnK2speyBjb25zb2xlLmxvZygxLCBrKTsgZGVidWdnZXIgfVxuXHRcdFx0XHRcdC8vKHRbX10gPSBmdW5jdGlvbiAkKCl7ICQuc29ydCA9IE9iamVjdC5rZXlzKHQpLnNvcnQoKTsgcmV0dXJuICQgfSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih1ID09PSB2YWwpe1xuXHRcdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBcblx0XHRcdGlmKGkgPT0gbCl7XG5cdFx0XHRcdC8vaWYodSA9PT0gdmFsKXsgcmV0dXJuICh1ID09PSAodG1wID0gYXRbJyddKSk/IGF0IDogdG1wIH0gLy8gVEhJUyBDT0RFIElTIENPUlJFQ1QsIGJlbG93IGlzXG5cdFx0XHRcdGlmKHUgPT09IHZhbCl7IHJldHVybiAodSA9PT0gKHRtcCA9IGF0WycnXSkpPyBhdCA6ICgocmFkaXgudW5pdCA9IDEpICYmIHRtcCkgfSAvLyB0ZW1wb3JhcnkgaGVscD8/XG5cdFx0XHRcdGF0WycnXSA9IHZhbDtcblx0XHRcdFx0Ly8oYXRbX10gPSBmdW5jdGlvbiAkKCl7ICQuc29ydCA9IE9iamVjdC5rZXlzKGF0KS5zb3J0KCk7IHJldHVybiAkIH0oKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih1ICE9PSB2YWwpeyBkZWxldGUgYXRbX10gfVxuXHRcdFx0XHQvL2F0ICYmIChhdFtfXSA9IGZ1bmN0aW9uICQoKXsgJC5zb3J0ID0gT2JqZWN0LmtleXMoYXQpLnNvcnQoKTsgcmV0dXJuICQgfSgpKTtcblx0XHRcdFx0cmV0dXJuIHJhZGl4KGtleS5zbGljZSgrK2kpLCB2YWwsIGF0IHx8IChhdCA9IHt9KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByYWRpeDtcblx0fTtcblxuXHRSYWRpeC5tYXAgPSBmdW5jdGlvbiByYXAocmFkaXgsIGNiLCBvcHQsIHByZSl7XG5cdFx0dHJ5IHtcblx0XHRcdHByZSA9IHByZSB8fCBbXTsgLy8gVE9ETzogQlVHOiBtb3N0IG91dC1vZi1tZW1vcnkgY3Jhc2hlcyBjb21lIGZyb20gaGVyZS5cblx0XHRcdHZhciB0ID0gKCdmdW5jdGlvbicgPT0gdHlwZW9mIHJhZGl4KT8gcmFkaXguJCB8fCB7fSA6IHJhZGl4O1xuXHRcdFx0Ly8hb3B0ICYmIGNvbnNvbGUubG9nKFwiV0hBVCBJUyBUP1wiLCBKU09OLnN0cmluZ2lmeSh0KS5sZW5ndGgpO1xuXHRcdFx0aWYoIXQpeyByZXR1cm4gfVxuXHRcdFx0aWYoJ3N0cmluZycgPT0gdHlwZW9mIHQpeyBpZihSYWRpeC5kZWJ1Zyl7IHRocm93IFsnQlVHOicsIHJhZGl4LCBjYiwgb3B0LCBwcmVdIH0gcmV0dXJuOyB9XG5cdFx0XHR2YXIga2V5cyA9ICh0W19dfHxubykuc29ydCB8fCAodFtfXSA9IGZ1bmN0aW9uICQoKXsgJC5zb3J0ID0gT2JqZWN0LmtleXModCkuc29ydCgpOyByZXR1cm4gJCB9KCkpLnNvcnQsIHJldjsgLy8gT05MWSAxNyUgb2Ygb3BzIGFyZSBwcmUtc29ydGVkIVxuXHRcdFx0Ly92YXIga2V5cyA9IE9iamVjdC5rZXlzKHQpLnNvcnQoKTtcblx0XHRcdG9wdCA9ICh0cnVlID09PSBvcHQpPyB7YnJhbmNoOiB0cnVlfSA6IChvcHQgfHwge30pO1xuXHRcdFx0aWYocmV2ID0gb3B0LnJldmVyc2UpeyBrZXlzID0ga2V5cy5zbGljZSgwKS5yZXZlcnNlKCkgfVxuXHRcdFx0dmFyIHN0YXJ0ID0gb3B0LnN0YXJ0LCBlbmQgPSBvcHQuZW5kLCBFTkQgPSAnXFx1ZmZmZic7XG5cdFx0XHR2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDtcblx0XHRcdGZvcig7aSA8IGw7IGkrKyl7IHZhciBrZXkgPSBrZXlzW2ldLCB0cmVlID0gdFtrZXldLCB0bXAsIHAsIHB0O1xuXHRcdFx0XHRpZighdHJlZSB8fCAnJyA9PT0ga2V5IHx8IF8gPT09IGtleSB8fCAndW5kZWZpbmVkJyA9PT0ga2V5KXsgY29udGludWUgfVxuXHRcdFx0XHRwID0gcHJlLnNsaWNlKDApOyBwLnB1c2goa2V5KTtcblx0XHRcdFx0cHQgPSBwLmpvaW4oJycpO1xuXHRcdFx0XHRpZih1ICE9PSBzdGFydCAmJiBwdCA8IChzdGFydHx8JycpLnNsaWNlKDAscHQubGVuZ3RoKSl7IGNvbnRpbnVlIH1cblx0XHRcdFx0aWYodSAhPT0gZW5kICYmIChlbmQgfHwgRU5EKSA8IHB0KXsgY29udGludWUgfVxuXHRcdFx0XHRpZihyZXYpeyAvLyBjaGlsZHJlbiBtdXN0IGJlIGNoZWNrZWQgZmlyc3Qgd2hlbiBnb2luZyBpbiByZXZlcnNlLlxuXHRcdFx0XHRcdHRtcCA9IHJhcCh0cmVlLCBjYiwgb3B0LCBwKTtcblx0XHRcdFx0XHRpZih1ICE9PSB0bXApeyByZXR1cm4gdG1wIH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZih1ICE9PSAodG1wID0gdHJlZVsnJ10pKXtcblx0XHRcdFx0XHR2YXIgeWVzID0gMTtcblx0XHRcdFx0XHRpZih1ICE9PSBzdGFydCAmJiBwdCA8IChzdGFydHx8JycpKXsgeWVzID0gMCB9XG5cdFx0XHRcdFx0aWYodSAhPT0gZW5kICYmIHB0ID4gKGVuZCB8fCBFTkQpKXsgeWVzID0gMCB9XG5cdFx0XHRcdFx0aWYoeWVzKXtcblx0XHRcdFx0XHRcdHRtcCA9IGNiKHRtcCwgcHQsIGtleSwgcHJlKTtcblx0XHRcdFx0XHRcdGlmKHUgIT09IHRtcCl7IHJldHVybiB0bXAgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdGlmKG9wdC5icmFuY2gpe1xuXHRcdFx0XHRcdHRtcCA9IGNiKHUsIHB0LCBrZXksIHByZSk7XG5cdFx0XHRcdFx0aWYodSAhPT0gdG1wKXsgcmV0dXJuIHRtcCB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJlID0gcDtcblx0XHRcdFx0aWYoIXJldil7XG5cdFx0XHRcdFx0dG1wID0gcmFwKHRyZWUsIGNiLCBvcHQsIHByZSk7XG5cdFx0XHRcdFx0aWYodSAhPT0gdG1wKXsgcmV0dXJuIHRtcCB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJlLnBvcCgpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHsgY29uc29sZS5lcnJvcihlKTsgfVxuXHR9O1xuXG5cdGlmKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpe1xuXHQgIHdpbmRvdy5SYWRpeCA9IFJhZGl4O1xuXHR9IGVsc2UgeyBcblx0XHR0cnl7IG1vZHVsZS5leHBvcnRzID0gUmFkaXggfWNhdGNoKGUpe31cblx0fVxuXHR2YXIgZWFjaCA9IFJhZGl4Lm9iamVjdCA9IGZ1bmN0aW9uKG8sIGYsIHIpe1xuXHRcdGZvcih2YXIgayBpbiBvKXtcblx0XHRcdGlmKCFvLmhhc093blByb3BlcnR5KGspKXsgY29udGludWUgfVxuXHRcdFx0aWYoKHIgPSBmKG9ba10sIGspKSAhPT0gdSl7IHJldHVybiByIH1cblx0XHR9XG5cdH0sIG5vID0ge30sIHU7XG5cdHZhciBfID0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNCk7XG5cdFxufSgpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/radix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/radmigtmp.js":
/*!*******************************************!*\
  !*** ./node_modules/gun/lib/radmigtmp.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = function(r){\n\tvar Radix = __webpack_require__(/*! ./radix */ \"(ssr)/./node_modules/gun/lib/radix.js\");\n\tr.find('a', function(){\n\t\tvar l = [];\n\t\tRadix.map(r.list, function(v,f){\n\t\t\tif(!(f.indexOf('%1B') + 1)){ return }\n\t\t\tif(!v){ return }\n\t\t\tl.push([f,v]);\n\t\t});\n\t\tif(l.length){\n\t\t\tconsole.log(\"\\n! ! ! WARNING ! ! !\\nRAD v0.2020.x has detected OLD v0.2019.x data & automatically migrating. Automatic migration will be turned OFF in future versions! If you are just developing/testing, we recommend you reset your data. Please contact us if you have any concerns.\\nThis message should only log once.\")\n\t\t}\n\t\tvar f, v;\n\t\tl.forEach(function(a){\n\t\t\tf = a[0]; v = a[1];\n\t\t\tr.list(decodeURIComponent(f), v);\n\t\t\tr.list(f, 0);\n\t\t});\n\t\tif(!f){ return }\n\t\tr.find.bad(f);\n\t})\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9yYWRtaWd0bXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0RBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLFdBQVc7QUFDWDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVTtBQUNWO0FBQ0EsRUFBRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMy1jaGF0Ly4vbm9kZV9tb2R1bGVzL2d1bi9saWIvcmFkbWlndG1wLmpzPzA5MzUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyKXtcblx0dmFyIFJhZGl4ID0gcmVxdWlyZSgnLi9yYWRpeCcpO1xuXHRyLmZpbmQoJ2EnLCBmdW5jdGlvbigpe1xuXHRcdHZhciBsID0gW107XG5cdFx0UmFkaXgubWFwKHIubGlzdCwgZnVuY3Rpb24odixmKXtcblx0XHRcdGlmKCEoZi5pbmRleE9mKCclMUInKSArIDEpKXsgcmV0dXJuIH1cblx0XHRcdGlmKCF2KXsgcmV0dXJuIH1cblx0XHRcdGwucHVzaChbZix2XSk7XG5cdFx0fSk7XG5cdFx0aWYobC5sZW5ndGgpe1xuXHRcdFx0Y29uc29sZS5sb2coXCJcXG4hICEgISBXQVJOSU5HICEgISAhXFxuUkFEIHYwLjIwMjAueCBoYXMgZGV0ZWN0ZWQgT0xEIHYwLjIwMTkueCBkYXRhICYgYXV0b21hdGljYWxseSBtaWdyYXRpbmcuIEF1dG9tYXRpYyBtaWdyYXRpb24gd2lsbCBiZSB0dXJuZWQgT0ZGIGluIGZ1dHVyZSB2ZXJzaW9ucyEgSWYgeW91IGFyZSBqdXN0IGRldmVsb3BpbmcvdGVzdGluZywgd2UgcmVjb21tZW5kIHlvdSByZXNldCB5b3VyIGRhdGEuIFBsZWFzZSBjb250YWN0IHVzIGlmIHlvdSBoYXZlIGFueSBjb25jZXJucy5cXG5UaGlzIG1lc3NhZ2Ugc2hvdWxkIG9ubHkgbG9nIG9uY2UuXCIpXG5cdFx0fVxuXHRcdHZhciBmLCB2O1xuXHRcdGwuZm9yRWFjaChmdW5jdGlvbihhKXtcblx0XHRcdGYgPSBhWzBdOyB2ID0gYVsxXTtcblx0XHRcdHIubGlzdChkZWNvZGVVUklDb21wb25lbnQoZiksIHYpO1xuXHRcdFx0ci5saXN0KGYsIDApO1xuXHRcdH0pO1xuXHRcdGlmKCFmKXsgcmV0dXJuIH1cblx0XHRyLmZpbmQuYmFkKGYpO1xuXHR9KVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/radmigtmp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/rfs.js":
/*!*************************************!*\
  !*** ./node_modules/gun/lib/rfs.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function Store(opt){\n\topt = opt || {};\n\topt.log = opt.log || console.log;\n\topt.file = String(opt.file || 'radata');\n\tvar fs = __webpack_require__(/*! fs */ \"fs\"), u;\n\n\tvar store = function Store(){};\n\tif(Store[opt.file]){\n\t\tconsole.log(\"Warning: reusing same fs store and options as 1st.\");\n\t\treturn Store[opt.file];\n\t}\n\tStore[opt.file] = store;\n\tvar puts = {};\n\n\t// TODO!!! ADD ZLIB INFLATE / DEFLATE COMPRESSION!\n\tstore.put = function(file, data, cb){\n\t\tvar random = Math.random().toString(36).slice(-3);\n\t\tputs[file] = {id: random, data: data};\n\t\tvar tmp = opt.file+'-'+file+'-'+random+'.tmp';\n\t\tfs.writeFile(tmp, data, function(err, ok){\n\t\t\tif(err){\n\t\t\t\tif(random === (puts[file]||'').id){ delete puts[file] }\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t\tmove(tmp, opt.file+'/'+file, function(err, ok){\n\t\t\t\tif(random === (puts[file]||'').id){ delete puts[file] }\n\t\t\t\tcb(err, ok || !err);\n\t\t\t});\n\t\t});\n\t};\n\tstore.get = function(file, cb){ var tmp; // this took 3s+?\n\t\tif(tmp = puts[file]){ cb(u, tmp.data); return }\n\t\tfs.readFile(opt.file+'/'+file, function(err, data){\n\t\t\tif(err){\n\t\t\t\tif('ENOENT' === (err.code||'').toUpperCase()){\n\t\t\t\t\treturn cb();\n\t\t\t\t}\n\t\t\t\topt.log(\"ERROR:\", err);\n\t\t\t}\n\t\t\tcb(err, data);\n\t\t});\n\t};\n\n\tif(!fs.existsSync(opt.file)){ fs.mkdirSync(opt.file) }\n\n\tfunction move(oldPath, newPath, cb) {\n\t\tfs.rename(oldPath, newPath, function (err) {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === 'EXDEV') {\n\t\t\t\t\tvar readStream = fs.createReadStream(oldPath);\n\t\t\t\t\tvar writeStream = fs.createWriteStream(newPath);\n\n\t\t\t\t\treadStream.on('error', cb);\n\t\t\t\t\twriteStream.on('error', cb);\n\n\t\t\t\t\treadStream.on('close', function () {\n\t\t\t\t\t\tfs.unlink(oldPath, cb);\n\t\t\t\t\t});\n\n\t\t\t\t\treadStream.pipe(writeStream);\n\t\t\t\t} else {\n\t\t\t\t\tcb(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcb();\n\t\t\t}\n\t\t});\n\t};\n\n\tstore.list = function(cb, match, params, cbs){\n\t\tvar dir = fs.readdirSync(opt.file);\n\t\tdir.forEach(function(file){\n\t\t\tcb(file);\n\t\t})\n\t\tcb();\n\t};\n\t\n\treturn store;\n}\n\nvar Gun = (typeof window !== \"undefined\")? window.Gun : __webpack_require__(/*! ../gun */ \"(ssr)/./node_modules/gun/gun.js\");\nGun.on('create', function(root){\n\tthis.to.next(root);\n\tvar opt = root.opt;\n\tif(opt.rfs === false){ return }\n\topt.store = opt.store || (!Gun.window && Store(opt));\n});\n\nmodule.exports = Store;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9yZnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsY0FBSTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUMsd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdELG1CQUFPLENBQUMsK0NBQVE7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjMtY2hhdC8uL25vZGVfbW9kdWxlcy9ndW4vbGliL3Jmcy5qcz84NjM3Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFN0b3JlKG9wdCl7XG5cdG9wdCA9IG9wdCB8fCB7fTtcblx0b3B0LmxvZyA9IG9wdC5sb2cgfHwgY29uc29sZS5sb2c7XG5cdG9wdC5maWxlID0gU3RyaW5nKG9wdC5maWxlIHx8ICdyYWRhdGEnKTtcblx0dmFyIGZzID0gcmVxdWlyZSgnZnMnKSwgdTtcblxuXHR2YXIgc3RvcmUgPSBmdW5jdGlvbiBTdG9yZSgpe307XG5cdGlmKFN0b3JlW29wdC5maWxlXSl7XG5cdFx0Y29uc29sZS5sb2coXCJXYXJuaW5nOiByZXVzaW5nIHNhbWUgZnMgc3RvcmUgYW5kIG9wdGlvbnMgYXMgMXN0LlwiKTtcblx0XHRyZXR1cm4gU3RvcmVbb3B0LmZpbGVdO1xuXHR9XG5cdFN0b3JlW29wdC5maWxlXSA9IHN0b3JlO1xuXHR2YXIgcHV0cyA9IHt9O1xuXG5cdC8vIFRPRE8hISEgQUREIFpMSUIgSU5GTEFURSAvIERFRkxBVEUgQ09NUFJFU1NJT04hXG5cdHN0b3JlLnB1dCA9IGZ1bmN0aW9uKGZpbGUsIGRhdGEsIGNiKXtcblx0XHR2YXIgcmFuZG9tID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoLTMpO1xuXHRcdHB1dHNbZmlsZV0gPSB7aWQ6IHJhbmRvbSwgZGF0YTogZGF0YX07XG5cdFx0dmFyIHRtcCA9IG9wdC5maWxlKyctJytmaWxlKyctJytyYW5kb20rJy50bXAnO1xuXHRcdGZzLndyaXRlRmlsZSh0bXAsIGRhdGEsIGZ1bmN0aW9uKGVyciwgb2spe1xuXHRcdFx0aWYoZXJyKXtcblx0XHRcdFx0aWYocmFuZG9tID09PSAocHV0c1tmaWxlXXx8JycpLmlkKXsgZGVsZXRlIHB1dHNbZmlsZV0gfVxuXHRcdFx0XHRyZXR1cm4gY2IoZXJyKTtcblx0XHRcdH1cblx0XHRcdG1vdmUodG1wLCBvcHQuZmlsZSsnLycrZmlsZSwgZnVuY3Rpb24oZXJyLCBvayl7XG5cdFx0XHRcdGlmKHJhbmRvbSA9PT0gKHB1dHNbZmlsZV18fCcnKS5pZCl7IGRlbGV0ZSBwdXRzW2ZpbGVdIH1cblx0XHRcdFx0Y2IoZXJyLCBvayB8fCAhZXJyKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9O1xuXHRzdG9yZS5nZXQgPSBmdW5jdGlvbihmaWxlLCBjYil7IHZhciB0bXA7IC8vIHRoaXMgdG9vayAzcys/XG5cdFx0aWYodG1wID0gcHV0c1tmaWxlXSl7IGNiKHUsIHRtcC5kYXRhKTsgcmV0dXJuIH1cblx0XHRmcy5yZWFkRmlsZShvcHQuZmlsZSsnLycrZmlsZSwgZnVuY3Rpb24oZXJyLCBkYXRhKXtcblx0XHRcdGlmKGVycil7XG5cdFx0XHRcdGlmKCdFTk9FTlQnID09PSAoZXJyLmNvZGV8fCcnKS50b1VwcGVyQ2FzZSgpKXtcblx0XHRcdFx0XHRyZXR1cm4gY2IoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHQubG9nKFwiRVJST1I6XCIsIGVycik7XG5cdFx0XHR9XG5cdFx0XHRjYihlcnIsIGRhdGEpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdGlmKCFmcy5leGlzdHNTeW5jKG9wdC5maWxlKSl7IGZzLm1rZGlyU3luYyhvcHQuZmlsZSkgfVxuXG5cdGZ1bmN0aW9uIG1vdmUob2xkUGF0aCwgbmV3UGF0aCwgY2IpIHtcblx0XHRmcy5yZW5hbWUob2xkUGF0aCwgbmV3UGF0aCwgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRpZiAoZXJyLmNvZGUgPT09ICdFWERFVicpIHtcblx0XHRcdFx0XHR2YXIgcmVhZFN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0ob2xkUGF0aCk7XG5cdFx0XHRcdFx0dmFyIHdyaXRlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0obmV3UGF0aCk7XG5cblx0XHRcdFx0XHRyZWFkU3RyZWFtLm9uKCdlcnJvcicsIGNiKTtcblx0XHRcdFx0XHR3cml0ZVN0cmVhbS5vbignZXJyb3InLCBjYik7XG5cblx0XHRcdFx0XHRyZWFkU3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGZzLnVubGluayhvbGRQYXRoLCBjYik7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZWFkU3RyZWFtLnBpcGUod3JpdGVTdHJlYW0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNiKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0c3RvcmUubGlzdCA9IGZ1bmN0aW9uKGNiLCBtYXRjaCwgcGFyYW1zLCBjYnMpe1xuXHRcdHZhciBkaXIgPSBmcy5yZWFkZGlyU3luYyhvcHQuZmlsZSk7XG5cdFx0ZGlyLmZvckVhY2goZnVuY3Rpb24oZmlsZSl7XG5cdFx0XHRjYihmaWxlKTtcblx0XHR9KVxuXHRcdGNiKCk7XG5cdH07XG5cdFxuXHRyZXR1cm4gc3RvcmU7XG59XG5cbnZhciBHdW4gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIik/IHdpbmRvdy5HdW4gOiByZXF1aXJlKCcuLi9ndW4nKTtcbkd1bi5vbignY3JlYXRlJywgZnVuY3Rpb24ocm9vdCl7XG5cdHRoaXMudG8ubmV4dChyb290KTtcblx0dmFyIG9wdCA9IHJvb3Qub3B0O1xuXHRpZihvcHQucmZzID09PSBmYWxzZSl7IHJldHVybiB9XG5cdG9wdC5zdG9yZSA9IG9wdC5zdG9yZSB8fCAoIUd1bi53aW5kb3cgJiYgU3RvcmUob3B0KSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdG9yZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/rfs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/rfsmix.js":
/*!****************************************!*\
  !*** ./node_modules/gun/lib/rfsmix.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = function(opt, store){\n\tvar rfs = __webpack_require__(/*! ./rfs */ \"(ssr)/./node_modules/gun/lib/rfs.js\")(opt);\n\tvar p = store.put;\n\tvar g = store.get;\n\tstore.put = function(file, data, cb){\n\t\tvar a, b, c = function(err, ok){\n\t\t\tif(b){ return cb(err || b) }\n\t\t\tif(a){ return cb(err, ok) }\n\t\t\ta = true;\n\t\t\tb = err;\n\t\t}\n\t\tp(file, data, c); // parallel\n\t\trfs.put(file, data, c); // parallel\n\t}\n\tstore.get = function(file, cb){\n\t\trfs.get(file, function(err, data){\n\t\t\t//console.log(\"rfs3 hijacked\", file);\n\t\t\tif(data){ return cb(err, data) }\n\t\t\tg(file, cb);\n\t\t});\n\t}\n\treturn store;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9yZnNtaXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxXQUFXLG1CQUFPLENBQUMsa0RBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMy1jaGF0Ly4vbm9kZV9tb2R1bGVzL2d1bi9saWIvcmZzbWl4LmpzPzdkZmUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHQsIHN0b3JlKXtcblx0dmFyIHJmcyA9IHJlcXVpcmUoJy4vcmZzJykob3B0KTtcblx0dmFyIHAgPSBzdG9yZS5wdXQ7XG5cdHZhciBnID0gc3RvcmUuZ2V0O1xuXHRzdG9yZS5wdXQgPSBmdW5jdGlvbihmaWxlLCBkYXRhLCBjYil7XG5cdFx0dmFyIGEsIGIsIGMgPSBmdW5jdGlvbihlcnIsIG9rKXtcblx0XHRcdGlmKGIpeyByZXR1cm4gY2IoZXJyIHx8IGIpIH1cblx0XHRcdGlmKGEpeyByZXR1cm4gY2IoZXJyLCBvaykgfVxuXHRcdFx0YSA9IHRydWU7XG5cdFx0XHRiID0gZXJyO1xuXHRcdH1cblx0XHRwKGZpbGUsIGRhdGEsIGMpOyAvLyBwYXJhbGxlbFxuXHRcdHJmcy5wdXQoZmlsZSwgZGF0YSwgYyk7IC8vIHBhcmFsbGVsXG5cdH1cblx0c3RvcmUuZ2V0ID0gZnVuY3Rpb24oZmlsZSwgY2Ipe1xuXHRcdHJmcy5nZXQoZmlsZSwgZnVuY3Rpb24oZXJyLCBkYXRhKXtcblx0XHRcdC8vY29uc29sZS5sb2coXCJyZnMzIGhpamFja2VkXCIsIGZpbGUpO1xuXHRcdFx0aWYoZGF0YSl7IHJldHVybiBjYihlcnIsIGRhdGEpIH1cblx0XHRcdGcoZmlsZSwgY2IpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBzdG9yZTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/rfsmix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/rs3.js":
/*!*************************************!*\
  !*** ./node_modules/gun/lib/rs3.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Gun = __webpack_require__(/*! ../gun */ \"(ssr)/./node_modules/gun/gun.js\");\nvar Radisk = __webpack_require__(/*! ./radisk */ \"(ssr)/./node_modules/gun/lib/radisk.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar Radix = Radisk.Radix;\nvar u, AWS;\n\nGun.on('create', function(root){\n\tthis.to.next(root);\n\tvar opt = root.opt;\n\tif(!opt.s3 && !process.env.AWS_S3_BUCKET){ return }\n\t//opt.batch = opt.batch || (1000 * 10);\n\t//opt.until = opt.until || (1000 * 3); // ignoring these now, cause perf > cost\n\t//opt.chunk = opt.chunk || (1024 * 1024 * 10); // 10MB // when cost only cents\n\n\ttry{AWS = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'aws-sdk'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t}catch(e){\n\t\tconsole.log(\"Please `npm install aws-sdk` or add it to your package.json !\");\n\t\tAWS_SDK_NOT_INSTALLED;\n\t}\n\n\tvar opts = opt.s3 || (opt.s3 = {});\n\topts.bucket = opts.bucket || process.env.AWS_S3_BUCKET;\n\topts.region = opts.region || process.env.AWS_REGION || \"us-east-1\";\n\topts.accessKeyId = opts.key = opts.key || opts.accessKeyId || process.env.AWS_ACCESS_KEY_ID;\n\topts.secretAccessKey = opts.secret = opts.secret || opts.secretAccessKey || process.env.AWS_SECRET_ACCESS_KEY;\n\n\tif(opt.fakes3 = opt.fakes3 || process.env.fakes3){\n\t\topts.endpoint = opt.fakes3;\n\t\topts.sslEnabled = false;\n\t\topts.bucket = opts.bucket.replace('.','p');\n\t}\n\n\topts.config = new AWS.Config(opts);\n\topts.s3 = opts.s3 || new AWS.S3(opts.config);\n\n\topt.store = Object.keys(opts.s3).length === 0 ? opt.store : Store(opt);\n});\n\nfunction Store(opt){\n\topt = opt || {};\n\topt.file = String(opt.file || 'radata');\n\tvar opts = opt.s3, s3 = opts.s3;\n\tvar c = {p: {}, g: {}, l: {}};\n\t\n\tvar store = function Store(){};\n\tif(Store[opt.file]){\n\t\tconsole.log(\"Warning: reusing same S3 store and options as 1st.\");\n\t\treturn Store[opt.file];\n\t}\n\tStore[opt.file] = store;\n\n\tstore.put = function(file, data, cb){\n\t\tvar params = {Bucket: opts.bucket, Key: file, Body: data};\n\t\t//console.log(\"RS3 PUT ---->\", (data||\"\").slice(0,20));\n\t\tc.p[file] = data;\n\t\tdelete c.g[file];//Gun.obj.del(c.g, file);\n\t\tdelete c.l[1];//Gun.obj.del(c.l, 1);\n    s3.putObject(params, function(err, ok){\n    \tdelete c.p[file];\n    \tcb(err, 's3');\n    });\n\t};\n\tstore.get = function(file, cb){ var tmp;\n\t\tif(tmp = c.p[file]){ cb(u, tmp); return }\n\t\tif(tmp = c.g[file]){ tmp.push(cb); return }\n\t\tvar cbs = c.g[file] = [cb];\n\t\tvar params = {Bucket: opts.bucket, Key: file||''};\n\t\t//console.log(\"RS3 GET ---->\", file);\n\t\ts3.getObject(params, function got(err, ack){\n\t\t\tif(err && 'NoSuchKey' === err.code){ err = u }\n\t\t\t//console.log(\"RS3 GOT <----\", err, file, cbs.length, ((ack||{}).Body||'').length);//.toString().slice(0,20));\n\t\t\tdelete c.g[file];//Gun.obj.del(c.g, file);\n\t\t\tvar data, data = (ack||'').Body;\n\t\t\t//console.log(1, process.memoryUsage().heapUsed);\n\t\t\tvar i = 0, cba; while(cba = cbs[i++]){ cba && cba(err, data) }//Gun.obj.map(cbs, cbe);\n\t\t});\n\t};\n\tstore.list = function(cb, match, params, cbs){\n\t\tif(!cbs){\n\t\t\tif(c.l[1]){ return c.l[1].push(cb) }\n\t\t\tcbs = c.l[1] = [cb];\n\t\t}\n\t\tparams = params || {Bucket: opts.bucket};\n\t\t//console.log(\"RS3 LIST --->\");\n\t\ts3.listObjectsV2(params, function(err, data){\n\t\t\t//console.log(\"RS3 LIST <---\", err, data, cbs.length);\n\t\t\tif(err){ return Gun.log(err, err.stack) }\n\t\t\tvar IT = data.IsTruncated, cbe = function(cb){\n\t\t\t\tif(cb.end){ return }\n\t\t\t\tif(Gun.obj.map(data.Contents, function(content){\n\t\t\t\t\treturn cb(content.Key);\n\t\t\t\t})){ cb.end = true; return }\n\t\t\t\tif(IT){ return }\n\t\t\t\t// Stream interface requires a final call to know when to be done.\n\t\t\t\tcb.end = true; cb();\n\t\t\t}\n\t\t\t// Gun.obj.map(cbs, cbe); // lets see if fixes heroku\n\t\t\tif(!IT){ delete c.l[1]; return }\n\t    params.ContinuationToken = data.NextContinuationToken;\n\t  \tstore.list(cb, match, params, cbs);\n    });\n\t};\n\t//store.list(function(){ return true });\n\tif(false !== opt.rfs){ __webpack_require__(/*! ./rfsmix */ \"(ssr)/./node_modules/gun/lib/rfsmix.js\")(opt, store) } // ugly, but gotta move fast for now.\n\treturn store;\n}\n\nmodule.exports = Store;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9yczMuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLCtDQUFRO0FBQzFCLGFBQWEsbUJBQU8sQ0FBQyx3REFBVTtBQUMvQixTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLHdDQUF3QztBQUN4QyxnREFBZ0Q7O0FBRWhELEtBQUssTUFBTSxtQkFBTyxDQUFDLHNJQUFTO0FBQzVCLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUssT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUM7QUFDakMsdUJBQXVCLFlBQVk7QUFDbkMsdUJBQXVCLGNBQWM7QUFDckM7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxrRUFBa0Usb0JBQW9CO0FBQ3RGLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1Qix1QkFBdUI7QUFDakUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsS0FBSyxJQUFJLGVBQWU7QUFDeEIsWUFBWTtBQUNaO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsNkJBQTZCO0FBQzdCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkMsd0JBQXdCLG1CQUFPLENBQUMsd0RBQVUsZ0JBQWdCO0FBQzFEO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIzLWNoYXQvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9yczMuanM/MDk0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgR3VuID0gcmVxdWlyZSgnLi4vZ3VuJyk7XG52YXIgUmFkaXNrID0gcmVxdWlyZSgnLi9yYWRpc2snKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgUmFkaXggPSBSYWRpc2suUmFkaXg7XG52YXIgdSwgQVdTO1xuXG5HdW4ub24oJ2NyZWF0ZScsIGZ1bmN0aW9uKHJvb3Qpe1xuXHR0aGlzLnRvLm5leHQocm9vdCk7XG5cdHZhciBvcHQgPSByb290Lm9wdDtcblx0aWYoIW9wdC5zMyAmJiAhcHJvY2Vzcy5lbnYuQVdTX1MzX0JVQ0tFVCl7IHJldHVybiB9XG5cdC8vb3B0LmJhdGNoID0gb3B0LmJhdGNoIHx8ICgxMDAwICogMTApO1xuXHQvL29wdC51bnRpbCA9IG9wdC51bnRpbCB8fCAoMTAwMCAqIDMpOyAvLyBpZ25vcmluZyB0aGVzZSBub3csIGNhdXNlIHBlcmYgPiBjb3N0XG5cdC8vb3B0LmNodW5rID0gb3B0LmNodW5rIHx8ICgxMDI0ICogMTAyNCAqIDEwKTsgLy8gMTBNQiAvLyB3aGVuIGNvc3Qgb25seSBjZW50c1xuXG5cdHRyeXtBV1MgPSByZXF1aXJlKCdhd3Mtc2RrJyk7XG5cdH1jYXRjaChlKXtcblx0XHRjb25zb2xlLmxvZyhcIlBsZWFzZSBgbnBtIGluc3RhbGwgYXdzLXNka2Agb3IgYWRkIGl0IHRvIHlvdXIgcGFja2FnZS5qc29uICFcIik7XG5cdFx0QVdTX1NES19OT1RfSU5TVEFMTEVEO1xuXHR9XG5cblx0dmFyIG9wdHMgPSBvcHQuczMgfHwgKG9wdC5zMyA9IHt9KTtcblx0b3B0cy5idWNrZXQgPSBvcHRzLmJ1Y2tldCB8fCBwcm9jZXNzLmVudi5BV1NfUzNfQlVDS0VUO1xuXHRvcHRzLnJlZ2lvbiA9IG9wdHMucmVnaW9uIHx8IHByb2Nlc3MuZW52LkFXU19SRUdJT04gfHwgXCJ1cy1lYXN0LTFcIjtcblx0b3B0cy5hY2Nlc3NLZXlJZCA9IG9wdHMua2V5ID0gb3B0cy5rZXkgfHwgb3B0cy5hY2Nlc3NLZXlJZCB8fCBwcm9jZXNzLmVudi5BV1NfQUNDRVNTX0tFWV9JRDtcblx0b3B0cy5zZWNyZXRBY2Nlc3NLZXkgPSBvcHRzLnNlY3JldCA9IG9wdHMuc2VjcmV0IHx8IG9wdHMuc2VjcmV0QWNjZXNzS2V5IHx8IHByb2Nlc3MuZW52LkFXU19TRUNSRVRfQUNDRVNTX0tFWTtcblxuXHRpZihvcHQuZmFrZXMzID0gb3B0LmZha2VzMyB8fCBwcm9jZXNzLmVudi5mYWtlczMpe1xuXHRcdG9wdHMuZW5kcG9pbnQgPSBvcHQuZmFrZXMzO1xuXHRcdG9wdHMuc3NsRW5hYmxlZCA9IGZhbHNlO1xuXHRcdG9wdHMuYnVja2V0ID0gb3B0cy5idWNrZXQucmVwbGFjZSgnLicsJ3AnKTtcblx0fVxuXG5cdG9wdHMuY29uZmlnID0gbmV3IEFXUy5Db25maWcob3B0cyk7XG5cdG9wdHMuczMgPSBvcHRzLnMzIHx8IG5ldyBBV1MuUzMob3B0cy5jb25maWcpO1xuXG5cdG9wdC5zdG9yZSA9IE9iamVjdC5rZXlzKG9wdHMuczMpLmxlbmd0aCA9PT0gMCA/IG9wdC5zdG9yZSA6IFN0b3JlKG9wdCk7XG59KTtcblxuZnVuY3Rpb24gU3RvcmUob3B0KXtcblx0b3B0ID0gb3B0IHx8IHt9O1xuXHRvcHQuZmlsZSA9IFN0cmluZyhvcHQuZmlsZSB8fCAncmFkYXRhJyk7XG5cdHZhciBvcHRzID0gb3B0LnMzLCBzMyA9IG9wdHMuczM7XG5cdHZhciBjID0ge3A6IHt9LCBnOiB7fSwgbDoge319O1xuXHRcblx0dmFyIHN0b3JlID0gZnVuY3Rpb24gU3RvcmUoKXt9O1xuXHRpZihTdG9yZVtvcHQuZmlsZV0pe1xuXHRcdGNvbnNvbGUubG9nKFwiV2FybmluZzogcmV1c2luZyBzYW1lIFMzIHN0b3JlIGFuZCBvcHRpb25zIGFzIDFzdC5cIik7XG5cdFx0cmV0dXJuIFN0b3JlW29wdC5maWxlXTtcblx0fVxuXHRTdG9yZVtvcHQuZmlsZV0gPSBzdG9yZTtcblxuXHRzdG9yZS5wdXQgPSBmdW5jdGlvbihmaWxlLCBkYXRhLCBjYil7XG5cdFx0dmFyIHBhcmFtcyA9IHtCdWNrZXQ6IG9wdHMuYnVja2V0LCBLZXk6IGZpbGUsIEJvZHk6IGRhdGF9O1xuXHRcdC8vY29uc29sZS5sb2coXCJSUzMgUFVUIC0tLS0+XCIsIChkYXRhfHxcIlwiKS5zbGljZSgwLDIwKSk7XG5cdFx0Yy5wW2ZpbGVdID0gZGF0YTtcblx0XHRkZWxldGUgYy5nW2ZpbGVdOy8vR3VuLm9iai5kZWwoYy5nLCBmaWxlKTtcblx0XHRkZWxldGUgYy5sWzFdOy8vR3VuLm9iai5kZWwoYy5sLCAxKTtcbiAgICBzMy5wdXRPYmplY3QocGFyYW1zLCBmdW5jdGlvbihlcnIsIG9rKXtcbiAgICBcdGRlbGV0ZSBjLnBbZmlsZV07XG4gICAgXHRjYihlcnIsICdzMycpO1xuICAgIH0pO1xuXHR9O1xuXHRzdG9yZS5nZXQgPSBmdW5jdGlvbihmaWxlLCBjYil7IHZhciB0bXA7XG5cdFx0aWYodG1wID0gYy5wW2ZpbGVdKXsgY2IodSwgdG1wKTsgcmV0dXJuIH1cblx0XHRpZih0bXAgPSBjLmdbZmlsZV0peyB0bXAucHVzaChjYik7IHJldHVybiB9XG5cdFx0dmFyIGNicyA9IGMuZ1tmaWxlXSA9IFtjYl07XG5cdFx0dmFyIHBhcmFtcyA9IHtCdWNrZXQ6IG9wdHMuYnVja2V0LCBLZXk6IGZpbGV8fCcnfTtcblx0XHQvL2NvbnNvbGUubG9nKFwiUlMzIEdFVCAtLS0tPlwiLCBmaWxlKTtcblx0XHRzMy5nZXRPYmplY3QocGFyYW1zLCBmdW5jdGlvbiBnb3QoZXJyLCBhY2spe1xuXHRcdFx0aWYoZXJyICYmICdOb1N1Y2hLZXknID09PSBlcnIuY29kZSl7IGVyciA9IHUgfVxuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIlJTMyBHT1QgPC0tLS1cIiwgZXJyLCBmaWxlLCBjYnMubGVuZ3RoLCAoKGFja3x8e30pLkJvZHl8fCcnKS5sZW5ndGgpOy8vLnRvU3RyaW5nKCkuc2xpY2UoMCwyMCkpO1xuXHRcdFx0ZGVsZXRlIGMuZ1tmaWxlXTsvL0d1bi5vYmouZGVsKGMuZywgZmlsZSk7XG5cdFx0XHR2YXIgZGF0YSwgZGF0YSA9IChhY2t8fCcnKS5Cb2R5O1xuXHRcdFx0Ly9jb25zb2xlLmxvZygxLCBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQpO1xuXHRcdFx0dmFyIGkgPSAwLCBjYmE7IHdoaWxlKGNiYSA9IGNic1tpKytdKXsgY2JhICYmIGNiYShlcnIsIGRhdGEpIH0vL0d1bi5vYmoubWFwKGNicywgY2JlKTtcblx0XHR9KTtcblx0fTtcblx0c3RvcmUubGlzdCA9IGZ1bmN0aW9uKGNiLCBtYXRjaCwgcGFyYW1zLCBjYnMpe1xuXHRcdGlmKCFjYnMpe1xuXHRcdFx0aWYoYy5sWzFdKXsgcmV0dXJuIGMubFsxXS5wdXNoKGNiKSB9XG5cdFx0XHRjYnMgPSBjLmxbMV0gPSBbY2JdO1xuXHRcdH1cblx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge0J1Y2tldDogb3B0cy5idWNrZXR9O1xuXHRcdC8vY29uc29sZS5sb2coXCJSUzMgTElTVCAtLS0+XCIpO1xuXHRcdHMzLmxpc3RPYmplY3RzVjIocGFyYW1zLCBmdW5jdGlvbihlcnIsIGRhdGEpe1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIlJTMyBMSVNUIDwtLS1cIiwgZXJyLCBkYXRhLCBjYnMubGVuZ3RoKTtcblx0XHRcdGlmKGVycil7IHJldHVybiBHdW4ubG9nKGVyciwgZXJyLnN0YWNrKSB9XG5cdFx0XHR2YXIgSVQgPSBkYXRhLklzVHJ1bmNhdGVkLCBjYmUgPSBmdW5jdGlvbihjYil7XG5cdFx0XHRcdGlmKGNiLmVuZCl7IHJldHVybiB9XG5cdFx0XHRcdGlmKEd1bi5vYmoubWFwKGRhdGEuQ29udGVudHMsIGZ1bmN0aW9uKGNvbnRlbnQpe1xuXHRcdFx0XHRcdHJldHVybiBjYihjb250ZW50LktleSk7XG5cdFx0XHRcdH0pKXsgY2IuZW5kID0gdHJ1ZTsgcmV0dXJuIH1cblx0XHRcdFx0aWYoSVQpeyByZXR1cm4gfVxuXHRcdFx0XHQvLyBTdHJlYW0gaW50ZXJmYWNlIHJlcXVpcmVzIGEgZmluYWwgY2FsbCB0byBrbm93IHdoZW4gdG8gYmUgZG9uZS5cblx0XHRcdFx0Y2IuZW5kID0gdHJ1ZTsgY2IoKTtcblx0XHRcdH1cblx0XHRcdC8vIEd1bi5vYmoubWFwKGNicywgY2JlKTsgLy8gbGV0cyBzZWUgaWYgZml4ZXMgaGVyb2t1XG5cdFx0XHRpZighSVQpeyBkZWxldGUgYy5sWzFdOyByZXR1cm4gfVxuXHQgICAgcGFyYW1zLkNvbnRpbnVhdGlvblRva2VuID0gZGF0YS5OZXh0Q29udGludWF0aW9uVG9rZW47XG5cdCAgXHRzdG9yZS5saXN0KGNiLCBtYXRjaCwgcGFyYW1zLCBjYnMpO1xuICAgIH0pO1xuXHR9O1xuXHQvL3N0b3JlLmxpc3QoZnVuY3Rpb24oKXsgcmV0dXJuIHRydWUgfSk7XG5cdGlmKGZhbHNlICE9PSBvcHQucmZzKXsgcmVxdWlyZSgnLi9yZnNtaXgnKShvcHQsIHN0b3JlKSB9IC8vIHVnbHksIGJ1dCBnb3R0YSBtb3ZlIGZhc3QgZm9yIG5vdy5cblx0cmV0dXJuIHN0b3JlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3JlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/rs3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/serve.js":
/*!***************************************!*\
  !*** ./node_modules/gun/lib/serve.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar dot = /\\.\\.+/g;\nvar slash = /\\/\\/+/g;\n\nfunction CDN(dir){\n\treturn function(req, res){\n\t\treq.url = (req.url||'').replace(dot,'').replace(slash,'/');\n\t\tif(serve(req, res)){ return } // filters GUN requests!\n\t\tif (req.url.slice(-3) === '.js') {\n\t\t\tres.writeHead(200, {'Content-Type': 'text/javascript'});\n\t\t}\n\t\tfs.createReadStream(path.join(dir, req.url)).on('error',function(tmp){ // static files!\n\t\t\tfs.readFile(path.join(dir, 'index.html'), function(err, tmp){\n\t\t\t\ttry{ res.writeHead(200, {'Content-Type': 'text/html'});\n\t\t\t\tres.end(tmp+''); }catch(e){} // or default to index\n\t\t})}).pipe(res); // stream\n\t}\n}\n\nfunction serve(req, res, next){ var tmp;\n\tif(typeof req === 'string'){\n\t\treturn CDN(req);\n\t}\n\tif(!req || !res){ return false }\n\tnext = next || serve;\n\tif(!req.url){ return next() }\n\tif(res.setHeader){ res.setHeader('Access-Control-Allow-Origin', '*') }\n\tif(0 <= req.url.indexOf('gun.js')){\n\t\tres.writeHead(200, {'Content-Type': 'text/javascript'});\n\t\tres.end(serve.js = serve.js || (__webpack_require__(/*! fs */ \"fs\").readFileSync)(__dirname + '/../gun.js'));\n\t\treturn true;\n\t}\n\tif(0 <= req.url.indexOf('gun/')){\n\t\tvar path = __dirname + '/../' + req.url.split('/').slice(2).join('/');\n\t\tif('/' === path.slice(-1)){\n\t\t\tfs.readdir(path, function(err, dir){ res.end((dir || (err && 404))+'') });\n\t\t\treturn true;\n\t\t}\n\t\tvar S = +new Date;\n\t\tvar rs = fs.createReadStream(path);\n\t\trs.on('open', function(){ console.STAT && console.STAT(S, +new Date - S, 'serve file open'); rs.pipe(res) });\n\t\trs.on('error', function(err){ res.end(404+'') });\n\t\trs.on('end', function(){ console.STAT && console.STAT(S, +new Date - S, 'serve file end') });\n\t\treturn true;\n\t}\n\tif((tmp = req.socket) && (tmp = tmp.server) && (tmp = tmp.route)){ var url;\n\t\tif(tmp = tmp[(((req.url||'').slice(1)).split('/')[0]||'').split('.')[0]]){\n\t\t\ttry{ return tmp(req, res, next) }catch(e){ console.log(req.url+' crashed with '+e) }\n\t\t}\n\t}\n\treturn next();\n}\n\nmodule.exports = serve;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9zZXJ2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQSx5RUFBeUU7QUFDekU7QUFDQSxTQUFTLG9CQUFvQiw0QkFBNEI7QUFDekQsc0JBQXNCLFdBQVc7QUFDakMsR0FBRyxFQUFFLGFBQWE7QUFDbEI7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQjtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQsaUNBQWlDLGtEQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBbUUsY0FBYztBQUM3RyxnQ0FBZ0MsaUJBQWlCO0FBQ2pELDJCQUEyQixrRUFBa0U7QUFDN0Y7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLFFBQVEsNEJBQTRCLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIzLWNoYXQvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9zZXJ2ZS5qcz9iYWQ4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBkb3QgPSAvXFwuXFwuKy9nO1xudmFyIHNsYXNoID0gL1xcL1xcLysvZztcblxuZnVuY3Rpb24gQ0ROKGRpcil7XG5cdHJldHVybiBmdW5jdGlvbihyZXEsIHJlcyl7XG5cdFx0cmVxLnVybCA9IChyZXEudXJsfHwnJykucmVwbGFjZShkb3QsJycpLnJlcGxhY2Uoc2xhc2gsJy8nKTtcblx0XHRpZihzZXJ2ZShyZXEsIHJlcykpeyByZXR1cm4gfSAvLyBmaWx0ZXJzIEdVTiByZXF1ZXN0cyFcblx0XHRpZiAocmVxLnVybC5zbGljZSgtMykgPT09ICcuanMnKSB7XG5cdFx0XHRyZXMud3JpdGVIZWFkKDIwMCwgeydDb250ZW50LVR5cGUnOiAndGV4dC9qYXZhc2NyaXB0J30pO1xuXHRcdH1cblx0XHRmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGguam9pbihkaXIsIHJlcS51cmwpKS5vbignZXJyb3InLGZ1bmN0aW9uKHRtcCl7IC8vIHN0YXRpYyBmaWxlcyFcblx0XHRcdGZzLnJlYWRGaWxlKHBhdGguam9pbihkaXIsICdpbmRleC5odG1sJyksIGZ1bmN0aW9uKGVyciwgdG1wKXtcblx0XHRcdFx0dHJ5eyByZXMud3JpdGVIZWFkKDIwMCwgeydDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJ30pO1xuXHRcdFx0XHRyZXMuZW5kKHRtcCsnJyk7IH1jYXRjaChlKXt9IC8vIG9yIGRlZmF1bHQgdG8gaW5kZXhcblx0XHR9KX0pLnBpcGUocmVzKTsgLy8gc3RyZWFtXG5cdH1cbn1cblxuZnVuY3Rpb24gc2VydmUocmVxLCByZXMsIG5leHQpeyB2YXIgdG1wO1xuXHRpZih0eXBlb2YgcmVxID09PSAnc3RyaW5nJyl7XG5cdFx0cmV0dXJuIENETihyZXEpO1xuXHR9XG5cdGlmKCFyZXEgfHwgIXJlcyl7IHJldHVybiBmYWxzZSB9XG5cdG5leHQgPSBuZXh0IHx8IHNlcnZlO1xuXHRpZighcmVxLnVybCl7IHJldHVybiBuZXh0KCkgfVxuXHRpZihyZXMuc2V0SGVhZGVyKXsgcmVzLnNldEhlYWRlcignQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJywgJyonKSB9XG5cdGlmKDAgPD0gcmVxLnVybC5pbmRleE9mKCdndW4uanMnKSl7XG5cdFx0cmVzLndyaXRlSGVhZCgyMDAsIHsnQ29udGVudC1UeXBlJzogJ3RleHQvamF2YXNjcmlwdCd9KTtcblx0XHRyZXMuZW5kKHNlcnZlLmpzID0gc2VydmUuanMgfHwgcmVxdWlyZSgnZnMnKS5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy8uLi9ndW4uanMnKSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYoMCA8PSByZXEudXJsLmluZGV4T2YoJ2d1bi8nKSl7XG5cdFx0dmFyIHBhdGggPSBfX2Rpcm5hbWUgKyAnLy4uLycgKyByZXEudXJsLnNwbGl0KCcvJykuc2xpY2UoMikuam9pbignLycpO1xuXHRcdGlmKCcvJyA9PT0gcGF0aC5zbGljZSgtMSkpe1xuXHRcdFx0ZnMucmVhZGRpcihwYXRoLCBmdW5jdGlvbihlcnIsIGRpcil7IHJlcy5lbmQoKGRpciB8fCAoZXJyICYmIDQwNCkpKycnKSB9KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgUyA9ICtuZXcgRGF0ZTtcblx0XHR2YXIgcnMgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgpO1xuXHRcdHJzLm9uKCdvcGVuJywgZnVuY3Rpb24oKXsgY29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAnc2VydmUgZmlsZSBvcGVuJyk7IHJzLnBpcGUocmVzKSB9KTtcblx0XHRycy5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpeyByZXMuZW5kKDQwNCsnJykgfSk7XG5cdFx0cnMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7IGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgK25ldyBEYXRlIC0gUywgJ3NlcnZlIGZpbGUgZW5kJykgfSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYoKHRtcCA9IHJlcS5zb2NrZXQpICYmICh0bXAgPSB0bXAuc2VydmVyKSAmJiAodG1wID0gdG1wLnJvdXRlKSl7IHZhciB1cmw7XG5cdFx0aWYodG1wID0gdG1wWygoKHJlcS51cmx8fCcnKS5zbGljZSgxKSkuc3BsaXQoJy8nKVswXXx8JycpLnNwbGl0KCcuJylbMF1dKXtcblx0XHRcdHRyeXsgcmV0dXJuIHRtcChyZXEsIHJlcywgbmV4dCkgfWNhdGNoKGUpeyBjb25zb2xlLmxvZyhyZXEudXJsKycgY3Jhc2hlZCB3aXRoICcrZSkgfVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbmV4dCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlcnZlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/serve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/server.js":
/*!****************************************!*\
  !*** ./node_modules/gun/lib/server.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(";(function(){\n\t__webpack_require__(/*! ./yson */ \"(ssr)/./node_modules/gun/lib/yson.js\");\n\tvar Gun = __webpack_require__(/*! ../gun */ \"(ssr)/./node_modules/gun/gun.js\"), u;\n\tGun.serve = __webpack_require__(/*! ./serve */ \"(ssr)/./node_modules/gun/lib/serve.js\");\n\t//process.env.GUN_ENV = process.env.GUN_ENV || 'debug';\n\t//console.LOG = {}; // only do this for dev.\n\tGun.on('opt', function(root){\n\t\tif(u === root.opt.super){ root.opt.super = true }\n\t\tif(u === root.opt.faith){ root.opt.faith = true } // HNPERF: This should probably be off, but we're testing performance improvements, please audit.\n\t\troot.opt.log = root.opt.log || Gun.log;\n\t\tthis.to.next(root);\n\t})\n\t//require('../nts');\n\t__webpack_require__(/*! ./store */ \"(ssr)/./node_modules/gun/lib/store.js\");\n\t__webpack_require__(/*! ./rfs */ \"(ssr)/./node_modules/gun/lib/rfs.js\");\n\t__webpack_require__(/*! ./rs3 */ \"(ssr)/./node_modules/gun/lib/rs3.js\");\n\t__webpack_require__(/*! ./wire */ \"(ssr)/./node_modules/gun/lib/wire.js\");\n\n\ttry{__webpack_require__(/*! ../sea */ \"(ssr)/./node_modules/gun/sea.js\");}catch(e){}\n\ttry{__webpack_require__(/*! ../axe */ \"(ssr)/./node_modules/gun/axe.js\");}catch(e){}\n\t//require('./file');\n\t//require('./evict');\n\t__webpack_require__(/*! ./multicast */ \"(ssr)/./node_modules/gun/lib/multicast.js\");\n\t__webpack_require__(/*! ./stats */ \"(ssr)/./node_modules/gun/lib/stats.js\");\n\tmodule.exports = Gun;\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQztBQUNELENBQUMsbUJBQU8sQ0FBQyxvREFBUTtBQUNqQixXQUFXLG1CQUFPLENBQUMsK0NBQVE7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHNEQUFTO0FBQzlCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUMsbUJBQU8sQ0FBQyxzREFBUztBQUNsQixDQUFDLG1CQUFPLENBQUMsa0RBQU87QUFDaEIsQ0FBQyxtQkFBTyxDQUFDLGtEQUFPO0FBQ2hCLENBQUMsbUJBQU8sQ0FBQyxvREFBUTs7QUFFakIsS0FBSyxtQkFBTyxDQUFDLCtDQUFRLEdBQUc7QUFDeEIsS0FBSyxtQkFBTyxDQUFDLCtDQUFRLEdBQUc7QUFDeEI7QUFDQTtBQUNBLENBQUMsbUJBQU8sQ0FBQyw4REFBYTtBQUN0QixDQUFDLG1CQUFPLENBQUMsc0RBQVM7QUFDbEI7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMy1jaGF0Ly4vbm9kZV9tb2R1bGVzL2d1bi9saWIvc2VydmVyLmpzPzhhMDkiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpe1xuXHRyZXF1aXJlKCcuL3lzb24nKTtcblx0dmFyIEd1biA9IHJlcXVpcmUoJy4uL2d1bicpLCB1O1xuXHRHdW4uc2VydmUgPSByZXF1aXJlKCcuL3NlcnZlJyk7XG5cdC8vcHJvY2Vzcy5lbnYuR1VOX0VOViA9IHByb2Nlc3MuZW52LkdVTl9FTlYgfHwgJ2RlYnVnJztcblx0Ly9jb25zb2xlLkxPRyA9IHt9OyAvLyBvbmx5IGRvIHRoaXMgZm9yIGRldi5cblx0R3VuLm9uKCdvcHQnLCBmdW5jdGlvbihyb290KXtcblx0XHRpZih1ID09PSByb290Lm9wdC5zdXBlcil7IHJvb3Qub3B0LnN1cGVyID0gdHJ1ZSB9XG5cdFx0aWYodSA9PT0gcm9vdC5vcHQuZmFpdGgpeyByb290Lm9wdC5mYWl0aCA9IHRydWUgfSAvLyBITlBFUkY6IFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIG9mZiwgYnV0IHdlJ3JlIHRlc3RpbmcgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzLCBwbGVhc2UgYXVkaXQuXG5cdFx0cm9vdC5vcHQubG9nID0gcm9vdC5vcHQubG9nIHx8IEd1bi5sb2c7XG5cdFx0dGhpcy50by5uZXh0KHJvb3QpO1xuXHR9KVxuXHQvL3JlcXVpcmUoJy4uL250cycpO1xuXHRyZXF1aXJlKCcuL3N0b3JlJyk7XG5cdHJlcXVpcmUoJy4vcmZzJyk7XG5cdHJlcXVpcmUoJy4vcnMzJyk7XG5cdHJlcXVpcmUoJy4vd2lyZScpO1xuXG5cdHRyeXtyZXF1aXJlKCcuLi9zZWEnKTt9Y2F0Y2goZSl7fVxuXHR0cnl7cmVxdWlyZSgnLi4vYXhlJyk7fWNhdGNoKGUpe31cblx0Ly9yZXF1aXJlKCcuL2ZpbGUnKTtcblx0Ly9yZXF1aXJlKCcuL2V2aWN0Jyk7XG5cdHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG5cdHJlcXVpcmUoJy4vc3RhdHMnKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBHdW47XG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/stats.js":
/*!***************************************!*\
  !*** ./node_modules/gun/lib/stats.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var Gun = (typeof window !== \"undefined\")? window.Gun : __webpack_require__(/*! ../gun */ \"(ssr)/./node_modules/gun/gun.js\");\n\nGun.on('opt', function(root){\n\tthis.to.next(root);\n\tif(root.once){ return }\n\tif(typeof process === 'undefined'){ return }\n\tif(false){}\n\tif(false === root.opt.stats){ return }\n\tvar path = __webpack_require__(/*! path */ \"path\") || {};\n\tvar file = root.opt.file ? path.resolve(root.opt.file).split(path.sep).slice(-1)[0] : 'radata';\n\tvar noop = function(){};\n\tvar os = __webpack_require__(/*! os */ \"os\") || {};\n\tvar fs = __webpack_require__(/*! fs */ \"fs\") || {};\n\tfs.existsSync = fs.existsSync || path.existsSync;\n\tif(!fs.existsSync){ return }\n\tif(!process){ return }\n\tprocess.uptime = process.uptime || noop;\n\tprocess.cpuUsage = process.cpuUsage || noop;\n\tprocess.memoryUsage = process.memoryUsage || noop;\n\tos.totalmem = os.totalmem || noop;\n\tos.freemem = os.freemem || noop;\n\tos.loadavg = os.loadavg || noop;\n\tos.cpus = os.cpus || noop;\n\tvar S = +new Date, W;\n\tvar obj_ify = function(o){try{o = JSON.parse(o)}catch(e){o={}};return o;}\n\tsetTimeout(function(){\n\t\troot.stats = obj_ify((fs.existsSync(__dirname+'/../stats.'+file) && fs.readFileSync(__dirname+'/../stats.'+file).toString())) || {};\n\t\troot.stats.up = root.stats.up || {};\n\t\troot.stats.up.start = root.stats.up.start || +(new Date);\n\t\troot.stats.up.count = (root.stats.up.count || 0) + 1;\n\t\troot.stats.stay = root.stats.stay || {};\n\t\troot.stats.over = +new Date;\n\t},1);\n\tsetInterval(function(){\n\t\tif(!root.stats){ root.stats = {} }\n\t\tif(W){ return }\n\t\tvar stats = root.stats, tmp;\n\t\tstats.over = -(S - (S = +new Date));\n\t\t(stats.up||{}).time = process.uptime();\n\t\tstats.memory = process.memoryUsage() || {};\n\t\tstats.memory.totalmem = os.totalmem();\n\t\tstats.memory.freemem = os.freemem();\n\t\tstats.cpu = process.cpuUsage() || {};\n\t\tstats.cpu.loadavg = os.loadavg();\n\t\tstats.cpu.stack = (((setTimeout||'').turn||'').s||'').length;\n\t\tstats.peers = {};\n\n\t\tstats.peers.count = console.STAT.peers || Object.keys(root.opt.peers||{}).length; // TODO: .keys( is slow\n\t\tstats.node = {};\n\t\tstats.node.count = Object.keys(root.graph||{}).length; // TODO: .keys( is slow\n\t\tstats.all = all;\n\t\tstats.sites = console.STAT.sites;\n\t\tall = {}; // will this cause missing stats?\n\t\tvar dam = root.opt.mesh;\n\t\tif(dam){\n\t\t\tstats.dam = {'in': {count: dam.hear.c, done: dam.hear.d}, 'out': {count: dam.say.c, done: dam.say.d}};\n\t\t\tdam.hear.c = dam.hear.d = dam.say.c = dam.say.d = 0; // reset\n\t\t\tstats.peers.time = dam.bye.time || 0;\n\t\t}\n\t\tvar rad = root.opt.store; rad = rad && rad.stats;\n\t\tif(rad){\n\t\t\tstats.rad = rad;\n\t\t\troot.opt.store.stats = {get:{time:{}, count:0}, put: {time:{}, count:0}}; // reset\n\t\t}\n\t\tJSON.stringifyAsync(stats, function(err, raw){ if(err){ return } W = true;\n\t\t\tfs.writeFile(__dirname+'/../stats.'+file, raw, function(err){ W = false; err && console.log(console.STAT.err = err); console.STAT && console.STAT(S, +new Date - S, 'stats stash') });\n\t\t});\n\n\t\t//exec(\"top -b -n 1\", function(err, out){ out && fs.writeFile(__dirname+'/../stats.top.'+file, out, noop) }); // was it really seriously actually this?\n\t//}, 1000 * 15);\n\t}, 1000 * 5);\n});\n\nvar exec = (__webpack_require__(/*! child_process */ \"child_process\").exec), noop = function(){};\n__webpack_require__(/*! ./yson */ \"(ssr)/./node_modules/gun/lib/yson.js\");\n\nvar log = Gun.log, all = {}, max = 1000;\nconsole.STAT = function(a,b,c,d){\n\tif('number' == typeof a && 'number' == typeof b && 'string' == typeof c){\n\t\tvar tmp = (all[c] || (all[c] = []));\n\t\tif(max < tmp.push([a,b])){ all[c] = [] } // reset\n\t\t//return;\n\t}\n\tif(!console.LOG || log.off){ return a }\n\treturn log.apply(Gun, arguments);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9zdGF0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3REFBd0QsbUJBQU8sQ0FBQywrQ0FBUTs7QUFFeEU7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixxQ0FBcUM7QUFDckMsSUFBSSxLQUE4QixDQUFDLEVBQVU7QUFDN0MsK0JBQStCO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxrQkFBTTtBQUMxQjtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLGNBQUk7QUFDdEIsVUFBVSxtQkFBTyxDQUFDLGNBQUk7QUFDdEI7QUFDQSxxQkFBcUI7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSSxrQkFBa0IsU0FBUyxNQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBFQUEwRSxVQUFVO0FBQ3BGO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sb0NBQW9DLFVBQVU7QUFDckUsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDJCQUEyQixLQUFLLE9BQU8sVUFBVSxRQUFRLE9BQU8sYUFBYTtBQUM3RTtBQUNBLGlEQUFpRCxTQUFTLFNBQVM7QUFDbkUsaUVBQWlFLFdBQVcsNENBQTRDLCtEQUErRDtBQUN2TCxHQUFHOztBQUVILDRDQUE0QyxpRUFBaUUsR0FBRztBQUNoSCxJQUFJO0FBQ0osRUFBRTtBQUNGLENBQUM7O0FBRUQsV0FBVyxnRUFBNkI7QUFDeEMsbUJBQU8sQ0FBQyxvREFBUTs7QUFFaEIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjMtY2hhdC8uL25vZGVfbW9kdWxlcy9ndW4vbGliL3N0YXRzLmpzP2Y4ZGQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEd1biA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKT8gd2luZG93Lkd1biA6IHJlcXVpcmUoJy4uL2d1bicpO1xuXG5HdW4ub24oJ29wdCcsIGZ1bmN0aW9uKHJvb3Qpe1xuXHR0aGlzLnRvLm5leHQocm9vdCk7XG5cdGlmKHJvb3Qub25jZSl7IHJldHVybiB9XG5cdGlmKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyl7IHJldHVybiB9XG5cdGlmKHR5cGVvZiByZXF1aXJlID09PSAndW5kZWZpbmVkJyl7IHJldHVybiB9XG5cdGlmKGZhbHNlID09PSByb290Lm9wdC5zdGF0cyl7IHJldHVybiB9XG5cdHZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpIHx8IHt9O1xuXHR2YXIgZmlsZSA9IHJvb3Qub3B0LmZpbGUgPyBwYXRoLnJlc29sdmUocm9vdC5vcHQuZmlsZSkuc3BsaXQocGF0aC5zZXApLnNsaWNlKC0xKVswXSA6ICdyYWRhdGEnO1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCl7fTtcblx0dmFyIG9zID0gcmVxdWlyZSgnb3MnKSB8fCB7fTtcblx0dmFyIGZzID0gcmVxdWlyZSgnZnMnKSB8fCB7fTtcblx0ZnMuZXhpc3RzU3luYyA9IGZzLmV4aXN0c1N5bmMgfHwgcGF0aC5leGlzdHNTeW5jO1xuXHRpZighZnMuZXhpc3RzU3luYyl7IHJldHVybiB9XG5cdGlmKCFwcm9jZXNzKXsgcmV0dXJuIH1cblx0cHJvY2Vzcy51cHRpbWUgPSBwcm9jZXNzLnVwdGltZSB8fCBub29wO1xuXHRwcm9jZXNzLmNwdVVzYWdlID0gcHJvY2Vzcy5jcHVVc2FnZSB8fCBub29wO1xuXHRwcm9jZXNzLm1lbW9yeVVzYWdlID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSB8fCBub29wO1xuXHRvcy50b3RhbG1lbSA9IG9zLnRvdGFsbWVtIHx8IG5vb3A7XG5cdG9zLmZyZWVtZW0gPSBvcy5mcmVlbWVtIHx8IG5vb3A7XG5cdG9zLmxvYWRhdmcgPSBvcy5sb2FkYXZnIHx8IG5vb3A7XG5cdG9zLmNwdXMgPSBvcy5jcHVzIHx8IG5vb3A7XG5cdHZhciBTID0gK25ldyBEYXRlLCBXO1xuXHR2YXIgb2JqX2lmeSA9IGZ1bmN0aW9uKG8pe3RyeXtvID0gSlNPTi5wYXJzZShvKX1jYXRjaChlKXtvPXt9fTtyZXR1cm4gbzt9XG5cdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRyb290LnN0YXRzID0gb2JqX2lmeSgoZnMuZXhpc3RzU3luYyhfX2Rpcm5hbWUrJy8uLi9zdGF0cy4nK2ZpbGUpICYmIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUrJy8uLi9zdGF0cy4nK2ZpbGUpLnRvU3RyaW5nKCkpKSB8fCB7fTtcblx0XHRyb290LnN0YXRzLnVwID0gcm9vdC5zdGF0cy51cCB8fCB7fTtcblx0XHRyb290LnN0YXRzLnVwLnN0YXJ0ID0gcm9vdC5zdGF0cy51cC5zdGFydCB8fCArKG5ldyBEYXRlKTtcblx0XHRyb290LnN0YXRzLnVwLmNvdW50ID0gKHJvb3Quc3RhdHMudXAuY291bnQgfHwgMCkgKyAxO1xuXHRcdHJvb3Quc3RhdHMuc3RheSA9IHJvb3Quc3RhdHMuc3RheSB8fCB7fTtcblx0XHRyb290LnN0YXRzLm92ZXIgPSArbmV3IERhdGU7XG5cdH0sMSk7XG5cdHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG5cdFx0aWYoIXJvb3Quc3RhdHMpeyByb290LnN0YXRzID0ge30gfVxuXHRcdGlmKFcpeyByZXR1cm4gfVxuXHRcdHZhciBzdGF0cyA9IHJvb3Quc3RhdHMsIHRtcDtcblx0XHRzdGF0cy5vdmVyID0gLShTIC0gKFMgPSArbmV3IERhdGUpKTtcblx0XHQoc3RhdHMudXB8fHt9KS50aW1lID0gcHJvY2Vzcy51cHRpbWUoKTtcblx0XHRzdGF0cy5tZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkgfHwge307XG5cdFx0c3RhdHMubWVtb3J5LnRvdGFsbWVtID0gb3MudG90YWxtZW0oKTtcblx0XHRzdGF0cy5tZW1vcnkuZnJlZW1lbSA9IG9zLmZyZWVtZW0oKTtcblx0XHRzdGF0cy5jcHUgPSBwcm9jZXNzLmNwdVVzYWdlKCkgfHwge307XG5cdFx0c3RhdHMuY3B1LmxvYWRhdmcgPSBvcy5sb2FkYXZnKCk7XG5cdFx0c3RhdHMuY3B1LnN0YWNrID0gKCgoc2V0VGltZW91dHx8JycpLnR1cm58fCcnKS5zfHwnJykubGVuZ3RoO1xuXHRcdHN0YXRzLnBlZXJzID0ge307XG5cblx0XHRzdGF0cy5wZWVycy5jb3VudCA9IGNvbnNvbGUuU1RBVC5wZWVycyB8fCBPYmplY3Qua2V5cyhyb290Lm9wdC5wZWVyc3x8e30pLmxlbmd0aDsgLy8gVE9ETzogLmtleXMoIGlzIHNsb3dcblx0XHRzdGF0cy5ub2RlID0ge307XG5cdFx0c3RhdHMubm9kZS5jb3VudCA9IE9iamVjdC5rZXlzKHJvb3QuZ3JhcGh8fHt9KS5sZW5ndGg7IC8vIFRPRE86IC5rZXlzKCBpcyBzbG93XG5cdFx0c3RhdHMuYWxsID0gYWxsO1xuXHRcdHN0YXRzLnNpdGVzID0gY29uc29sZS5TVEFULnNpdGVzO1xuXHRcdGFsbCA9IHt9OyAvLyB3aWxsIHRoaXMgY2F1c2UgbWlzc2luZyBzdGF0cz9cblx0XHR2YXIgZGFtID0gcm9vdC5vcHQubWVzaDtcblx0XHRpZihkYW0pe1xuXHRcdFx0c3RhdHMuZGFtID0geydpbic6IHtjb3VudDogZGFtLmhlYXIuYywgZG9uZTogZGFtLmhlYXIuZH0sICdvdXQnOiB7Y291bnQ6IGRhbS5zYXkuYywgZG9uZTogZGFtLnNheS5kfX07XG5cdFx0XHRkYW0uaGVhci5jID0gZGFtLmhlYXIuZCA9IGRhbS5zYXkuYyA9IGRhbS5zYXkuZCA9IDA7IC8vIHJlc2V0XG5cdFx0XHRzdGF0cy5wZWVycy50aW1lID0gZGFtLmJ5ZS50aW1lIHx8IDA7XG5cdFx0fVxuXHRcdHZhciByYWQgPSByb290Lm9wdC5zdG9yZTsgcmFkID0gcmFkICYmIHJhZC5zdGF0cztcblx0XHRpZihyYWQpe1xuXHRcdFx0c3RhdHMucmFkID0gcmFkO1xuXHRcdFx0cm9vdC5vcHQuc3RvcmUuc3RhdHMgPSB7Z2V0Ont0aW1lOnt9LCBjb3VudDowfSwgcHV0OiB7dGltZTp7fSwgY291bnQ6MH19OyAvLyByZXNldFxuXHRcdH1cblx0XHRKU09OLnN0cmluZ2lmeUFzeW5jKHN0YXRzLCBmdW5jdGlvbihlcnIsIHJhdyl7IGlmKGVycil7IHJldHVybiB9IFcgPSB0cnVlO1xuXHRcdFx0ZnMud3JpdGVGaWxlKF9fZGlybmFtZSsnLy4uL3N0YXRzLicrZmlsZSwgcmF3LCBmdW5jdGlvbihlcnIpeyBXID0gZmFsc2U7IGVyciAmJiBjb25zb2xlLmxvZyhjb25zb2xlLlNUQVQuZXJyID0gZXJyKTsgY29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAnc3RhdHMgc3Rhc2gnKSB9KTtcblx0XHR9KTtcblxuXHRcdC8vZXhlYyhcInRvcCAtYiAtbiAxXCIsIGZ1bmN0aW9uKGVyciwgb3V0KXsgb3V0ICYmIGZzLndyaXRlRmlsZShfX2Rpcm5hbWUrJy8uLi9zdGF0cy50b3AuJytmaWxlLCBvdXQsIG5vb3ApIH0pOyAvLyB3YXMgaXQgcmVhbGx5IHNlcmlvdXNseSBhY3R1YWxseSB0aGlzP1xuXHQvL30sIDEwMDAgKiAxNSk7XG5cdH0sIDEwMDAgKiA1KTtcbn0pO1xuXG52YXIgZXhlYyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpLmV4ZWMsIG5vb3AgPSBmdW5jdGlvbigpe307XG5yZXF1aXJlKCcuL3lzb24nKTtcblxudmFyIGxvZyA9IEd1bi5sb2csIGFsbCA9IHt9LCBtYXggPSAxMDAwO1xuY29uc29sZS5TVEFUID0gZnVuY3Rpb24oYSxiLGMsZCl7XG5cdGlmKCdudW1iZXInID09IHR5cGVvZiBhICYmICdudW1iZXInID09IHR5cGVvZiBiICYmICdzdHJpbmcnID09IHR5cGVvZiBjKXtcblx0XHR2YXIgdG1wID0gKGFsbFtjXSB8fCAoYWxsW2NdID0gW10pKTtcblx0XHRpZihtYXggPCB0bXAucHVzaChbYSxiXSkpeyBhbGxbY10gPSBbXSB9IC8vIHJlc2V0XG5cdFx0Ly9yZXR1cm47XG5cdH1cblx0aWYoIWNvbnNvbGUuTE9HIHx8IGxvZy5vZmYpeyByZXR1cm4gYSB9XG5cdHJldHVybiBsb2cuYXBwbHkoR3VuLCBhcmd1bWVudHMpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/stats.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/store.js":
/*!***************************************!*\
  !*** ./node_modules/gun/lib/store.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var Gun = (typeof window !== \"undefined\")? window.Gun : __webpack_require__(/*! ../gun */ \"(ssr)/./node_modules/gun/gun.js\");\n\nGun.on('create', function(root){\n    if(Gun.TESTING){ root.opt.file = 'radatatest' }\n    this.to.next(root);\n    var opt = root.opt, empty = {}, u;\n    if(false === opt.rad || false === opt.radisk){ return }\n    if((u+'' != typeof process) && 'false' === ''+(process.env||'').RAD){ return }\n    var Radisk = (Gun.window && Gun.window.Radisk) || __webpack_require__(/*! ./radisk */ \"(ssr)/./node_modules/gun/lib/radisk.js\");\n    var Radix = Radisk.Radix;\n    var dare = Radisk(opt), esc = String.fromCharCode(27);\n    var ST = 0;\n \n    root.on('put', function(msg){\n        this.to.next(msg);\n        if((msg._||'').rad){ return } // don't save what just came from a read.\n        //if(msg['@']){ return } // WHY DID I NOT ADD THIS?\n        var id = msg['#'], put = msg.put, soul = put['#'], key = put['.'], val = put[':'], state = put['>'], tmp;\n        var DBG = (msg._||'').DBG; DBG && (DBG.sp = DBG.sp || +new Date);\n        //var lot = (msg._||'').lot||''; count[id] = (count[id] || 0) + 1; \n        var S = (msg._||'').RPS || ((msg._||'').RPS = +new Date);\n        //console.log(\"PUT ------->>>\", soul,key, val, state);\n        //dare(soul+esc+key, {':': val, '>': state}, dare.one[id] || function(err, ok){\n        dare(soul+esc+key, {':': val, '>': state}, function(err, ok){\n            //console.log(\"<<<------- PAT\", soul,key, val, state, 'in', +new Date - S);\n            DBG && (DBG.spd = DBG.spd || +new Date);\n            console.STAT && console.STAT(S, +new Date - S, 'put');\n            //if(!err && count[id] !== lot.s){ console.log(err = \"Disk count not same as ram count.\"); console.STAT && console.STAT(+new Date, lot.s - count[id], 'put ack != count') } delete count[id];\n            if(err){ root.on('in', {'@': id, err: err, DBG: DBG}); return }\n            root.on('in', {'@': id, ok: ok, DBG: DBG});\n        //}, id, DBG && (DBG.r = DBG.r || {}));\n        },  false && 0, DBG && (DBG.r = DBG.r || {}));\n        DBG && (DBG.sps = DBG.sps || +new Date);\n    });\n    var count = {}, obj_empty = Object.empty;\n \n    root.on('get', function(msg){\n        this.to.next(msg);\n        var ctx = msg._||'', DBG = ctx.DBG = msg.DBG; DBG && (DBG.sg = +new Date);\n        var id = msg['#'], get = msg.get, soul = msg.get['#'], has = msg.get['.']||'', o = {}, graph, lex, key, tmp, force;\n        if('string' == typeof soul){\n            key = soul;\n        } else \n        if(soul){\n            if(u !== (tmp = soul['*'])){ o.limit = force = 1 }\n            if(u !== soul['>']){ o.start = soul['>'] }\n            if(u !== soul['<']){ o.end = soul['<'] }\n            key = force? (''+tmp) : tmp || soul['='];\n            force = null;\n        }\n        if(key && !o.limit){ // a soul.has must be on a soul, and not during soul*\n            if('string' == typeof has){\n                key = key+esc+(o.atom = has);\n            } else \n            if(has){\n                if(u !== has['>']){ o.start = has['>']; o.limit = 1 }\n                if(u !== has['<']){ o.end = has['<']; o.limit = 1 }\n                if(u !== (tmp = has['*'])){ o.limit = force = 1 }\n                if(key){ key = key+esc + (force? (''+(tmp||'')) : tmp || (o.atom = has['='] || '')) }\n            }\n        }\n        if((tmp = get['%']) || o.limit){\n            o.limit = (tmp <= (o.pack || (1000 * 100)))? tmp : 1;\n        }\n        if(has['-'] || (soul||{})['-'] || get['-']){ o.reverse = true }\n        if((tmp = (root.next||'')[soul]) && tmp.put){\n            if(o.atom){\n                tmp = (tmp.next||'')[o.atom] ;\n                if(tmp && tmp.root && tmp.root.graph && tmp.root.graph[soul] && tmp.root.graph[soul][o.atom]){ return }\n            } else\n            if(tmp && tmp.rad){ return }\n        }\n        var now = Gun.state();\n        var S = (+new Date), C = 0, SPT = 0; // STATS!\n        DBG && (DBG.sgm = S);\n        //var GID = String.random(3); console.log(\"GET ------->>>\", GID, key, o, '?', get);\n        dare(key||'', function(err, data, info){\n            //console.log(\"<<<------- GOT\", GID, +new Date - S, err, data);\n            DBG && (DBG.sgr = +new Date);\n            DBG && (DBG.sgi = info);\n            try{opt.store.stats.get.time[statg % 50] = (+new Date) - S; ++statg;\n                opt.store.stats.get.count++;\n                if(err){ opt.store.stats.get.err = err }\n            }catch(e){} // STATS!\n            //if(u === data && info.chunks > 1){ return } // if we already sent a chunk, ignore ending empty responses. // this causes tests to fail.\n            console.STAT && console.STAT(S, +new Date - S, 'got', JSON.stringify(key)); S = +new Date;\n            info = info || '';\n            var va, ve;\n            if(info.unit && data && u !== (va = data[':']) && u !== (ve = data['>'])){ // new format\n                var tmp = key.split(esc), so = tmp[0], ha = tmp[1];\n                (graph = graph || {})[so] = Gun.state.ify(graph[so], ha, ve, va, so);\n                root.$.get(so).get(ha)._.rad = now;\n                // REMEMBER TO ADD _rad TO NODE/SOUL QUERY!\n            } else\n            if(data){ // old code path\n                if(typeof data !== 'string'){\n                    if(o.atom){\n                        data = u;\n                    } else {\n                        Radix.map(data, each, o); // IS A RADIX TREE, NOT FUNCTION!\n                    }\n                }\n                if(!graph && data){ each(data, '') }\n                // TODO: !has what about soul lookups?\n                if(!o.atom && !has & 'string' == typeof soul && !o.limit && !o.more){\n                    root.$.get(soul)._.rad = now;\n                }\n            }\n            DBG && (DBG.sgp = +new Date);\n            // TODO: PERF NOTES! This is like 0.2s, but for each ack, or all? Can you cache these preps?\n            // TODO: PERF NOTES! This is like 0.2s, but for each ack, or all? Can you cache these preps?\n            // TODO: PERF NOTES! This is like 0.2s, but for each ack, or all? Can you cache these preps?\n            // TODO: PERF NOTES! This is like 0.2s, but for each ack, or all? Can you cache these preps?\n            // TODO: PERF NOTES! This is like 0.2s, but for each ack, or all? Can you cache these preps?\n            // Or benchmark by reusing first start date.\n            if(console.STAT && (ST = +new Date - S) > 9){ console.STAT(S, ST, 'got prep time'); console.STAT(S, C, 'got prep #') } SPT += ST; C = 0; S = +new Date;\n            var faith = function(){}; faith.faith = true; faith.rad = get; // HNPERF: We're testing performance improvement by skipping going through security again, but this should be audited.\n            root.on('in', {'@': id, put: graph, '%': info.more? 1 : u, err: err? err : u, _: faith, DBG: DBG});\n            console.STAT && (ST = +new Date - S) > 9 && console.STAT(S, ST, 'got emit', Object.keys(graph||{}).length);\n            graph = u; // each is outside our scope, we have to reset graph to nothing!\n        }, o, DBG && (DBG.r = DBG.r || {}));\n        DBG && (DBG.sgd = +new Date);\n        console.STAT && (ST = +new Date - S) > 9 && console.STAT(S, ST, 'get call'); // TODO: Perf: this was half a second??????\n        function each(val, has, a,b){ // TODO: THIS CODE NEEDS TO BE FASTER!!!!\n            C++;\n            if(!val){ return }\n            has = (key+has).split(esc);\n            var soul = has.slice(0,1)[0];\n            has = has.slice(-1)[0];\n            if(o.limit && o.limit <= o.count){ return true }\n            var va, ve, so = soul, ha = has;\n            //if(u !== (va = val[':']) && u !== (ve = val['>'])){ // THIS HANDLES NEW CODE!\n            if('string' != typeof val){ // THIS HANDLES NEW CODE!\n                va = val[':']; ve = val['>'];\n                (graph = graph || {})[so] = Gun.state.ify(graph[so], ha, ve, va, so);\n                //root.$.get(so).get(ha)._.rad = now;\n                o.count = (o.count || 0) + ((va||'').length || 9);\n                return;\n            }\n            o.count = (o.count || 0) + val.length;\n            var tmp = val.lastIndexOf('>');\n            var state = Radisk.decode(val.slice(tmp+1), null, esc);\n            val = Radisk.decode(val.slice(0,tmp), null, esc);\n            (graph = graph || {})[soul] = Gun.state.ify(graph[soul], has, state, val, soul);\n        }\n    });\n    var val_is = Gun.valid;\n    (opt.store||{}).stats = {get:{time:{}, count:0}, put: {time:{}, count:0}}; // STATS!\n    var statg = 0, statp = 0; // STATS!\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi9zdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3REFBd0QsbUJBQU8sQ0FBQywrQ0FBUTs7QUFFeEU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxrQ0FBa0M7QUFDbEMsbURBQW1EO0FBQ25ELDBFQUEwRTtBQUMxRSxzREFBc0QsbUJBQU8sQ0FBQyx3REFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0Qyx3QkFBd0IsU0FBUztBQUNqQztBQUNBLG1DQUFtQztBQUNuQyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0RBQXdELGlGQUFpRjtBQUN4TCxxQkFBcUIsZUFBZSw0QkFBNEIsR0FBRztBQUNuRSwyQkFBMkIsMEJBQTBCO0FBQ3JELFdBQVcsaUNBQWlDO0FBQzVDLFNBQVMsRUFBRSxNQUFLLElBQUksQ0FBRSw2QkFBNkI7QUFDbkQ7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlDQUF5QztBQUN6QyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RCxvQ0FBb0Msa0JBQWtCO0FBQ3RELDRDQUE0QztBQUM1Qyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HLGNBQWM7QUFDZCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQSx5QkFBeUI7QUFDekIsYUFBYSxXQUFXO0FBQ3hCLGlEQUFpRCxTQUFTO0FBQzFELHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsc0NBQXNDLG1DQUFtQyxXQUFXLE9BQU87QUFDckosc0NBQXNDLG9CQUFvQixpQkFBaUI7QUFDM0UsMkJBQTJCLGtGQUFrRjtBQUM3Ryw2R0FBNkc7QUFDN0csdUJBQXVCO0FBQ3ZCLFNBQVMsZ0NBQWdDO0FBQ3pDO0FBQ0EscUZBQXFGO0FBQ3JGLHNDQUFzQztBQUN0QztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxrRUFBa0U7QUFDbEUsd0NBQXdDO0FBQ3hDLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQixXQUFXLEtBQUssT0FBTyxVQUFVLFFBQVEsT0FBTyxhQUFhO0FBQy9FLDhCQUE4QjtBQUM5QixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMy1jaGF0Ly4vbm9kZV9tb2R1bGVzL2d1bi9saWIvc3RvcmUuanM/ODJhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgR3VuID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpPyB3aW5kb3cuR3VuIDogcmVxdWlyZSgnLi4vZ3VuJyk7XG5cbkd1bi5vbignY3JlYXRlJywgZnVuY3Rpb24ocm9vdCl7XG4gICAgaWYoR3VuLlRFU1RJTkcpeyByb290Lm9wdC5maWxlID0gJ3JhZGF0YXRlc3QnIH1cbiAgICB0aGlzLnRvLm5leHQocm9vdCk7XG4gICAgdmFyIG9wdCA9IHJvb3Qub3B0LCBlbXB0eSA9IHt9LCB1O1xuICAgIGlmKGZhbHNlID09PSBvcHQucmFkIHx8IGZhbHNlID09PSBvcHQucmFkaXNrKXsgcmV0dXJuIH1cbiAgICBpZigodSsnJyAhPSB0eXBlb2YgcHJvY2VzcykgJiYgJ2ZhbHNlJyA9PT0gJycrKHByb2Nlc3MuZW52fHwnJykuUkFEKXsgcmV0dXJuIH1cbiAgICB2YXIgUmFkaXNrID0gKEd1bi53aW5kb3cgJiYgR3VuLndpbmRvdy5SYWRpc2spIHx8IHJlcXVpcmUoJy4vcmFkaXNrJyk7XG4gICAgdmFyIFJhZGl4ID0gUmFkaXNrLlJhZGl4O1xuICAgIHZhciBkYXJlID0gUmFkaXNrKG9wdCksIGVzYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjcpO1xuICAgIHZhciBTVCA9IDA7XG4gXG4gICAgcm9vdC5vbigncHV0JywgZnVuY3Rpb24obXNnKXtcbiAgICAgICAgdGhpcy50by5uZXh0KG1zZyk7XG4gICAgICAgIGlmKChtc2cuX3x8JycpLnJhZCl7IHJldHVybiB9IC8vIGRvbid0IHNhdmUgd2hhdCBqdXN0IGNhbWUgZnJvbSBhIHJlYWQuXG4gICAgICAgIC8vaWYobXNnWydAJ10peyByZXR1cm4gfSAvLyBXSFkgRElEIEkgTk9UIEFERCBUSElTP1xuICAgICAgICB2YXIgaWQgPSBtc2dbJyMnXSwgcHV0ID0gbXNnLnB1dCwgc291bCA9IHB1dFsnIyddLCBrZXkgPSBwdXRbJy4nXSwgdmFsID0gcHV0Wyc6J10sIHN0YXRlID0gcHV0Wyc+J10sIHRtcDtcbiAgICAgICAgdmFyIERCRyA9IChtc2cuX3x8JycpLkRCRzsgREJHICYmIChEQkcuc3AgPSBEQkcuc3AgfHwgK25ldyBEYXRlKTtcbiAgICAgICAgLy92YXIgbG90ID0gKG1zZy5ffHwnJykubG90fHwnJzsgY291bnRbaWRdID0gKGNvdW50W2lkXSB8fCAwKSArIDE7IFxuICAgICAgICB2YXIgUyA9IChtc2cuX3x8JycpLlJQUyB8fCAoKG1zZy5ffHwnJykuUlBTID0gK25ldyBEYXRlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlBVVCAtLS0tLS0tPj4+XCIsIHNvdWwsa2V5LCB2YWwsIHN0YXRlKTtcbiAgICAgICAgLy9kYXJlKHNvdWwrZXNjK2tleSwgeyc6JzogdmFsLCAnPic6IHN0YXRlfSwgZGFyZS5vbmVbaWRdIHx8IGZ1bmN0aW9uKGVyciwgb2spe1xuICAgICAgICBkYXJlKHNvdWwrZXNjK2tleSwgeyc6JzogdmFsLCAnPic6IHN0YXRlfSwgZnVuY3Rpb24oZXJyLCBvayl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiPDw8LS0tLS0tLSBQQVRcIiwgc291bCxrZXksIHZhbCwgc3RhdGUsICdpbicsICtuZXcgRGF0ZSAtIFMpO1xuICAgICAgICAgICAgREJHICYmIChEQkcuc3BkID0gREJHLnNwZCB8fCArbmV3IERhdGUpO1xuICAgICAgICAgICAgY29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAncHV0Jyk7XG4gICAgICAgICAgICAvL2lmKCFlcnIgJiYgY291bnRbaWRdICE9PSBsb3Qucyl7IGNvbnNvbGUubG9nKGVyciA9IFwiRGlzayBjb3VudCBub3Qgc2FtZSBhcyByYW0gY291bnQuXCIpOyBjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKCtuZXcgRGF0ZSwgbG90LnMgLSBjb3VudFtpZF0sICdwdXQgYWNrICE9IGNvdW50JykgfSBkZWxldGUgY291bnRbaWRdO1xuICAgICAgICAgICAgaWYoZXJyKXsgcm9vdC5vbignaW4nLCB7J0AnOiBpZCwgZXJyOiBlcnIsIERCRzogREJHfSk7IHJldHVybiB9XG4gICAgICAgICAgICByb290Lm9uKCdpbicsIHsnQCc6IGlkLCBvazogb2ssIERCRzogREJHfSk7XG4gICAgICAgIC8vfSwgaWQsIERCRyAmJiAoREJHLnIgPSBEQkcuciB8fCB7fSkpO1xuICAgICAgICB9LCBmYWxzZSAmJiBpZCwgREJHICYmIChEQkcuciA9IERCRy5yIHx8IHt9KSk7XG4gICAgICAgIERCRyAmJiAoREJHLnNwcyA9IERCRy5zcHMgfHwgK25ldyBEYXRlKTtcbiAgICB9KTtcbiAgICB2YXIgY291bnQgPSB7fSwgb2JqX2VtcHR5ID0gT2JqZWN0LmVtcHR5O1xuIFxuICAgIHJvb3Qub24oJ2dldCcsIGZ1bmN0aW9uKG1zZyl7XG4gICAgICAgIHRoaXMudG8ubmV4dChtc2cpO1xuICAgICAgICB2YXIgY3R4ID0gbXNnLl98fCcnLCBEQkcgPSBjdHguREJHID0gbXNnLkRCRzsgREJHICYmIChEQkcuc2cgPSArbmV3IERhdGUpO1xuICAgICAgICB2YXIgaWQgPSBtc2dbJyMnXSwgZ2V0ID0gbXNnLmdldCwgc291bCA9IG1zZy5nZXRbJyMnXSwgaGFzID0gbXNnLmdldFsnLiddfHwnJywgbyA9IHt9LCBncmFwaCwgbGV4LCBrZXksIHRtcCwgZm9yY2U7XG4gICAgICAgIGlmKCdzdHJpbmcnID09IHR5cGVvZiBzb3VsKXtcbiAgICAgICAgICAgIGtleSA9IHNvdWw7XG4gICAgICAgIH0gZWxzZSBcbiAgICAgICAgaWYoc291bCl7XG4gICAgICAgICAgICBpZih1ICE9PSAodG1wID0gc291bFsnKiddKSl7IG8ubGltaXQgPSBmb3JjZSA9IDEgfVxuICAgICAgICAgICAgaWYodSAhPT0gc291bFsnPiddKXsgby5zdGFydCA9IHNvdWxbJz4nXSB9XG4gICAgICAgICAgICBpZih1ICE9PSBzb3VsWyc8J10peyBvLmVuZCA9IHNvdWxbJzwnXSB9XG4gICAgICAgICAgICBrZXkgPSBmb3JjZT8gKCcnK3RtcCkgOiB0bXAgfHwgc291bFsnPSddO1xuICAgICAgICAgICAgZm9yY2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmKGtleSAmJiAhby5saW1pdCl7IC8vIGEgc291bC5oYXMgbXVzdCBiZSBvbiBhIHNvdWwsIGFuZCBub3QgZHVyaW5nIHNvdWwqXG4gICAgICAgICAgICBpZignc3RyaW5nJyA9PSB0eXBlb2YgaGFzKXtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkrZXNjKyhvLmF0b20gPSBoYXMpO1xuICAgICAgICAgICAgfSBlbHNlIFxuICAgICAgICAgICAgaWYoaGFzKXtcbiAgICAgICAgICAgICAgICBpZih1ICE9PSBoYXNbJz4nXSl7IG8uc3RhcnQgPSBoYXNbJz4nXTsgby5saW1pdCA9IDEgfVxuICAgICAgICAgICAgICAgIGlmKHUgIT09IGhhc1snPCddKXsgby5lbmQgPSBoYXNbJzwnXTsgby5saW1pdCA9IDEgfVxuICAgICAgICAgICAgICAgIGlmKHUgIT09ICh0bXAgPSBoYXNbJyonXSkpeyBvLmxpbWl0ID0gZm9yY2UgPSAxIH1cbiAgICAgICAgICAgICAgICBpZihrZXkpeyBrZXkgPSBrZXkrZXNjICsgKGZvcmNlPyAoJycrKHRtcHx8JycpKSA6IHRtcCB8fCAoby5hdG9tID0gaGFzWyc9J10gfHwgJycpKSB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoKHRtcCA9IGdldFsnJSddKSB8fCBvLmxpbWl0KXtcbiAgICAgICAgICAgIG8ubGltaXQgPSAodG1wIDw9IChvLnBhY2sgfHwgKDEwMDAgKiAxMDApKSk/IHRtcCA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaGFzWyctJ10gfHwgKHNvdWx8fHt9KVsnLSddIHx8IGdldFsnLSddKXsgby5yZXZlcnNlID0gdHJ1ZSB9XG4gICAgICAgIGlmKCh0bXAgPSAocm9vdC5uZXh0fHwnJylbc291bF0pICYmIHRtcC5wdXQpe1xuICAgICAgICAgICAgaWYoby5hdG9tKXtcbiAgICAgICAgICAgICAgICB0bXAgPSAodG1wLm5leHR8fCcnKVtvLmF0b21dIDtcbiAgICAgICAgICAgICAgICBpZih0bXAgJiYgdG1wLnJvb3QgJiYgdG1wLnJvb3QuZ3JhcGggJiYgdG1wLnJvb3QuZ3JhcGhbc291bF0gJiYgdG1wLnJvb3QuZ3JhcGhbc291bF1bby5hdG9tXSl7IHJldHVybiB9XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGlmKHRtcCAmJiB0bXAucmFkKXsgcmV0dXJuIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gR3VuLnN0YXRlKCk7XG4gICAgICAgIHZhciBTID0gKCtuZXcgRGF0ZSksIEMgPSAwLCBTUFQgPSAwOyAvLyBTVEFUUyFcbiAgICAgICAgREJHICYmIChEQkcuc2dtID0gUyk7XG4gICAgICAgIC8vdmFyIEdJRCA9IFN0cmluZy5yYW5kb20oMyk7IGNvbnNvbGUubG9nKFwiR0VUIC0tLS0tLS0+Pj5cIiwgR0lELCBrZXksIG8sICc/JywgZ2V0KTtcbiAgICAgICAgZGFyZShrZXl8fCcnLCBmdW5jdGlvbihlcnIsIGRhdGEsIGluZm8pe1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIjw8PC0tLS0tLS0gR09UXCIsIEdJRCwgK25ldyBEYXRlIC0gUywgZXJyLCBkYXRhKTtcbiAgICAgICAgICAgIERCRyAmJiAoREJHLnNnciA9ICtuZXcgRGF0ZSk7XG4gICAgICAgICAgICBEQkcgJiYgKERCRy5zZ2kgPSBpbmZvKTtcbiAgICAgICAgICAgIHRyeXtvcHQuc3RvcmUuc3RhdHMuZ2V0LnRpbWVbc3RhdGcgJSA1MF0gPSAoK25ldyBEYXRlKSAtIFM7ICsrc3RhdGc7XG4gICAgICAgICAgICAgICAgb3B0LnN0b3JlLnN0YXRzLmdldC5jb3VudCsrO1xuICAgICAgICAgICAgICAgIGlmKGVycil7IG9wdC5zdG9yZS5zdGF0cy5nZXQuZXJyID0gZXJyIH1cbiAgICAgICAgICAgIH1jYXRjaChlKXt9IC8vIFNUQVRTIVxuICAgICAgICAgICAgLy9pZih1ID09PSBkYXRhICYmIGluZm8uY2h1bmtzID4gMSl7IHJldHVybiB9IC8vIGlmIHdlIGFscmVhZHkgc2VudCBhIGNodW5rLCBpZ25vcmUgZW5kaW5nIGVtcHR5IHJlc3BvbnNlcy4gLy8gdGhpcyBjYXVzZXMgdGVzdHMgdG8gZmFpbC5cbiAgICAgICAgICAgIGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgK25ldyBEYXRlIC0gUywgJ2dvdCcsIEpTT04uc3RyaW5naWZ5KGtleSkpOyBTID0gK25ldyBEYXRlO1xuICAgICAgICAgICAgaW5mbyA9IGluZm8gfHwgJyc7XG4gICAgICAgICAgICB2YXIgdmEsIHZlO1xuICAgICAgICAgICAgaWYoaW5mby51bml0ICYmIGRhdGEgJiYgdSAhPT0gKHZhID0gZGF0YVsnOiddKSAmJiB1ICE9PSAodmUgPSBkYXRhWyc+J10pKXsgLy8gbmV3IGZvcm1hdFxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBrZXkuc3BsaXQoZXNjKSwgc28gPSB0bXBbMF0sIGhhID0gdG1wWzFdO1xuICAgICAgICAgICAgICAgIChncmFwaCA9IGdyYXBoIHx8IHt9KVtzb10gPSBHdW4uc3RhdGUuaWZ5KGdyYXBoW3NvXSwgaGEsIHZlLCB2YSwgc28pO1xuICAgICAgICAgICAgICAgIHJvb3QuJC5nZXQoc28pLmdldChoYSkuXy5yYWQgPSBub3c7XG4gICAgICAgICAgICAgICAgLy8gUkVNRU1CRVIgVE8gQUREIF9yYWQgVE8gTk9ERS9TT1VMIFFVRVJZIVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBpZihkYXRhKXsgLy8gb2xkIGNvZGUgcGF0aFxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyl7XG4gICAgICAgICAgICAgICAgICAgIGlmKG8uYXRvbSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJhZGl4Lm1hcChkYXRhLCBlYWNoLCBvKTsgLy8gSVMgQSBSQURJWCBUUkVFLCBOT1QgRlVOQ1RJT04hXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoIWdyYXBoICYmIGRhdGEpeyBlYWNoKGRhdGEsICcnKSB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogIWhhcyB3aGF0IGFib3V0IHNvdWwgbG9va3Vwcz9cbiAgICAgICAgICAgICAgICBpZighby5hdG9tICYmICFoYXMgJiAnc3RyaW5nJyA9PSB0eXBlb2Ygc291bCAmJiAhby5saW1pdCAmJiAhby5tb3JlKXtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC4kLmdldChzb3VsKS5fLnJhZCA9IG5vdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBEQkcgJiYgKERCRy5zZ3AgPSArbmV3IERhdGUpO1xuICAgICAgICAgICAgLy8gVE9ETzogUEVSRiBOT1RFUyEgVGhpcyBpcyBsaWtlIDAuMnMsIGJ1dCBmb3IgZWFjaCBhY2ssIG9yIGFsbD8gQ2FuIHlvdSBjYWNoZSB0aGVzZSBwcmVwcz9cbiAgICAgICAgICAgIC8vIFRPRE86IFBFUkYgTk9URVMhIFRoaXMgaXMgbGlrZSAwLjJzLCBidXQgZm9yIGVhY2ggYWNrLCBvciBhbGw/IENhbiB5b3UgY2FjaGUgdGhlc2UgcHJlcHM/XG4gICAgICAgICAgICAvLyBUT0RPOiBQRVJGIE5PVEVTISBUaGlzIGlzIGxpa2UgMC4ycywgYnV0IGZvciBlYWNoIGFjaywgb3IgYWxsPyBDYW4geW91IGNhY2hlIHRoZXNlIHByZXBzP1xuICAgICAgICAgICAgLy8gVE9ETzogUEVSRiBOT1RFUyEgVGhpcyBpcyBsaWtlIDAuMnMsIGJ1dCBmb3IgZWFjaCBhY2ssIG9yIGFsbD8gQ2FuIHlvdSBjYWNoZSB0aGVzZSBwcmVwcz9cbiAgICAgICAgICAgIC8vIFRPRE86IFBFUkYgTk9URVMhIFRoaXMgaXMgbGlrZSAwLjJzLCBidXQgZm9yIGVhY2ggYWNrLCBvciBhbGw/IENhbiB5b3UgY2FjaGUgdGhlc2UgcHJlcHM/XG4gICAgICAgICAgICAvLyBPciBiZW5jaG1hcmsgYnkgcmV1c2luZyBmaXJzdCBzdGFydCBkYXRlLlxuICAgICAgICAgICAgaWYoY29uc29sZS5TVEFUICYmIChTVCA9ICtuZXcgRGF0ZSAtIFMpID4gOSl7IGNvbnNvbGUuU1RBVChTLCBTVCwgJ2dvdCBwcmVwIHRpbWUnKTsgY29uc29sZS5TVEFUKFMsIEMsICdnb3QgcHJlcCAjJykgfSBTUFQgKz0gU1Q7IEMgPSAwOyBTID0gK25ldyBEYXRlO1xuICAgICAgICAgICAgdmFyIGZhaXRoID0gZnVuY3Rpb24oKXt9OyBmYWl0aC5mYWl0aCA9IHRydWU7IGZhaXRoLnJhZCA9IGdldDsgLy8gSE5QRVJGOiBXZSdyZSB0ZXN0aW5nIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50IGJ5IHNraXBwaW5nIGdvaW5nIHRocm91Z2ggc2VjdXJpdHkgYWdhaW4sIGJ1dCB0aGlzIHNob3VsZCBiZSBhdWRpdGVkLlxuICAgICAgICAgICAgcm9vdC5vbignaW4nLCB7J0AnOiBpZCwgcHV0OiBncmFwaCwgJyUnOiBpbmZvLm1vcmU/IDEgOiB1LCBlcnI6IGVycj8gZXJyIDogdSwgXzogZmFpdGgsIERCRzogREJHfSk7XG4gICAgICAgICAgICBjb25zb2xlLlNUQVQgJiYgKFNUID0gK25ldyBEYXRlIC0gUykgPiA5ICYmIGNvbnNvbGUuU1RBVChTLCBTVCwgJ2dvdCBlbWl0JywgT2JqZWN0LmtleXMoZ3JhcGh8fHt9KS5sZW5ndGgpO1xuICAgICAgICAgICAgZ3JhcGggPSB1OyAvLyBlYWNoIGlzIG91dHNpZGUgb3VyIHNjb3BlLCB3ZSBoYXZlIHRvIHJlc2V0IGdyYXBoIHRvIG5vdGhpbmchXG4gICAgICAgIH0sIG8sIERCRyAmJiAoREJHLnIgPSBEQkcuciB8fCB7fSkpO1xuICAgICAgICBEQkcgJiYgKERCRy5zZ2QgPSArbmV3IERhdGUpO1xuICAgICAgICBjb25zb2xlLlNUQVQgJiYgKFNUID0gK25ldyBEYXRlIC0gUykgPiA5ICYmIGNvbnNvbGUuU1RBVChTLCBTVCwgJ2dldCBjYWxsJyk7IC8vIFRPRE86IFBlcmY6IHRoaXMgd2FzIGhhbGYgYSBzZWNvbmQ/Pz8/Pz9cbiAgICAgICAgZnVuY3Rpb24gZWFjaCh2YWwsIGhhcywgYSxiKXsgLy8gVE9ETzogVEhJUyBDT0RFIE5FRURTIFRPIEJFIEZBU1RFUiEhISFcbiAgICAgICAgICAgIEMrKztcbiAgICAgICAgICAgIGlmKCF2YWwpeyByZXR1cm4gfVxuICAgICAgICAgICAgaGFzID0gKGtleStoYXMpLnNwbGl0KGVzYyk7XG4gICAgICAgICAgICB2YXIgc291bCA9IGhhcy5zbGljZSgwLDEpWzBdO1xuICAgICAgICAgICAgaGFzID0gaGFzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICAgIGlmKG8ubGltaXQgJiYgby5saW1pdCA8PSBvLmNvdW50KXsgcmV0dXJuIHRydWUgfVxuICAgICAgICAgICAgdmFyIHZhLCB2ZSwgc28gPSBzb3VsLCBoYSA9IGhhcztcbiAgICAgICAgICAgIC8vaWYodSAhPT0gKHZhID0gdmFsWyc6J10pICYmIHUgIT09ICh2ZSA9IHZhbFsnPiddKSl7IC8vIFRISVMgSEFORExFUyBORVcgQ09ERSFcbiAgICAgICAgICAgIGlmKCdzdHJpbmcnICE9IHR5cGVvZiB2YWwpeyAvLyBUSElTIEhBTkRMRVMgTkVXIENPREUhXG4gICAgICAgICAgICAgICAgdmEgPSB2YWxbJzonXTsgdmUgPSB2YWxbJz4nXTtcbiAgICAgICAgICAgICAgICAoZ3JhcGggPSBncmFwaCB8fCB7fSlbc29dID0gR3VuLnN0YXRlLmlmeShncmFwaFtzb10sIGhhLCB2ZSwgdmEsIHNvKTtcbiAgICAgICAgICAgICAgICAvL3Jvb3QuJC5nZXQoc28pLmdldChoYSkuXy5yYWQgPSBub3c7XG4gICAgICAgICAgICAgICAgby5jb3VudCA9IChvLmNvdW50IHx8IDApICsgKCh2YXx8JycpLmxlbmd0aCB8fCA5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvLmNvdW50ID0gKG8uY291bnQgfHwgMCkgKyB2YWwubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRtcCA9IHZhbC5sYXN0SW5kZXhPZignPicpO1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gUmFkaXNrLmRlY29kZSh2YWwuc2xpY2UodG1wKzEpLCBudWxsLCBlc2MpO1xuICAgICAgICAgICAgdmFsID0gUmFkaXNrLmRlY29kZSh2YWwuc2xpY2UoMCx0bXApLCBudWxsLCBlc2MpO1xuICAgICAgICAgICAgKGdyYXBoID0gZ3JhcGggfHwge30pW3NvdWxdID0gR3VuLnN0YXRlLmlmeShncmFwaFtzb3VsXSwgaGFzLCBzdGF0ZSwgdmFsLCBzb3VsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciB2YWxfaXMgPSBHdW4udmFsaWQ7XG4gICAgKG9wdC5zdG9yZXx8e30pLnN0YXRzID0ge2dldDp7dGltZTp7fSwgY291bnQ6MH0sIHB1dDoge3RpbWU6e30sIGNvdW50OjB9fTsgLy8gU1RBVFMhXG4gICAgdmFyIHN0YXRnID0gMCwgc3RhdHAgPSAwOyAvLyBTVEFUUyFcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/store.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/wire.js":
/*!**************************************!*\
  !*** ./node_modules/gun/lib/wire.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var Gun = __webpack_require__(/*! ../gun */ \"(ssr)/./node_modules/gun/gun.js\");\n\n/*\n\tAn Ad-Hoc Mesh-Network Daisy-Chain\n\tshould work even if humans are\n\tcommunicating with each other blind.\n\n\tTo prevent infinite broadcast loops,\n\twe use a deduplication process\n\tbased on the message's identifier.\n\tThis is currently implemented in core.\n\n\tHowever, because this still creates a\n\tN*2 (where N is the number of connections)\n\tflood, it is not scalable for traditional\n\tservices that have a hub network topology.\n\n\tDoes this mean we have to abandon mesh\n\talgorithms? No, we can simply layer more\n\tefficient optimizations in based on constraints.\n\tIf these constraints exist, it automatically\n\tupgrades, but if not, it falls back to the\n\tbrute-force mesh based robust algorithm.\n\tA simple example is to limit peer connections\n\tand rely upon daisy chaining to relay messages.\n\n\tAnother example, is if peers are willing to\n\tidentify themselves, then we can improve the\n\tefficiency of the network by having each peer\n\tinclude the names of peers it is connected in\n\teach message. Then each subsequent peer will\n\tnot relay it to them, since it is unnecessary.\n\tThis should create N (where N is the number of\n\tpeers) messages (or possibly N+ if there is a\n\tcommon peer of uncommon peers that receives it\n\tand relays at exact latency timings), which is\n\toptimal.\n\n\tSince computer networks aren't actually blind,\n\twe will implement the above method to improve\n\tthe performance of the ad-hoc mesh network.\n\n\tBut why not have every message contain the\n\twhole history of peers that it relayed through?\n\tBecause in sufficiently large enough networks,\n\twith extensive daisy chaining, this will cause\n\tthe message to become prohibitively slow and\n\tincrease indefinitely in size.\n\n*/\n\nGun.on('opt', function(root){\n\tvar opt = root.opt;\n\tif(false === opt.ws || opt.once){\n\t\tthis.to.next(root);\n\t\treturn;\n\t}\t\n\n\tvar url = __webpack_require__(/*! url */ \"url\");\n\topt.mesh = opt.mesh || Gun.Mesh(root);\n\topt.WebSocket = opt.WebSocket || __webpack_require__(/*! ws */ \"(ssr)/./node_modules/ws/index.js\");\n\tvar ws = opt.ws = opt.ws || {};\n\tws.path = ws.path || '/gun';\n\t// if we DO need an HTTP server, then choose ws specific one or GUN default one.\n\tif(!ws.noServer){\n\t\tws.server = ws.server || opt.web;\n\t\tif(!ws.server){ this.to.next(root); return } // ugh, bug fix for @jamierez & unstoppable ryan.\n\t}\n\tws.web = ws.web || new opt.WebSocket.Server(ws); // we still need a WS server.\n\tws.web.on('connection', function(wire, req){ var peer;\n\t\twire.headers = wire.headers || (req||'').headers || '';\n\t\tconsole.STAT && ((console.STAT.sites || (console.STAT.sites = {}))[wire.headers.origin] = 1);\n\t\topt.mesh.hi(peer = {wire: wire});\n\t\twire.on('message', function(msg){\n\t\t\topt.mesh.hear(msg.data || msg, peer);\n\t\t});\n\t\twire.on('close', function(){\n\t\t\topt.mesh.bye(peer);\n\t\t});\n\t\twire.on('error', function(e){});\n\t\tsetTimeout(function heart(){ if(!opt.peers[peer.id]){ return } try{ wire.send(\"[]\") }catch(e){} ;setTimeout(heart, 1000 * 20) }, 1000 * 20); // Some systems, like Heroku, require heartbeats to not time out. // TODO: Make this configurable? // TODO: PERF: Find better approach than try/timeouts?\n\t});\n\tthis.to.next(root);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi93aXJlLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQywrQ0FBUTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxnQkFBSztBQUN4QjtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLDRDQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CLFNBQVM7QUFDL0M7QUFDQSxrREFBa0Q7QUFDbEQsOENBQThDO0FBQzlDO0FBQ0Esa0VBQWtFO0FBQ2xFLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQ0FBZ0M7QUFDaEMsK0JBQStCLHlCQUF5QixTQUFTLEtBQUssaUJBQWlCLFlBQVksOEJBQThCLGNBQWM7QUFDL0ksRUFBRTtBQUNGO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjMtY2hhdC8uL25vZGVfbW9kdWxlcy9ndW4vbGliL3dpcmUuanM/NDc4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgR3VuID0gcmVxdWlyZSgnLi4vZ3VuJyk7XG5cbi8qXG5cdEFuIEFkLUhvYyBNZXNoLU5ldHdvcmsgRGFpc3ktQ2hhaW5cblx0c2hvdWxkIHdvcmsgZXZlbiBpZiBodW1hbnMgYXJlXG5cdGNvbW11bmljYXRpbmcgd2l0aCBlYWNoIG90aGVyIGJsaW5kLlxuXG5cdFRvIHByZXZlbnQgaW5maW5pdGUgYnJvYWRjYXN0IGxvb3BzLFxuXHR3ZSB1c2UgYSBkZWR1cGxpY2F0aW9uIHByb2Nlc3Ncblx0YmFzZWQgb24gdGhlIG1lc3NhZ2UncyBpZGVudGlmaWVyLlxuXHRUaGlzIGlzIGN1cnJlbnRseSBpbXBsZW1lbnRlZCBpbiBjb3JlLlxuXG5cdEhvd2V2ZXIsIGJlY2F1c2UgdGhpcyBzdGlsbCBjcmVhdGVzIGFcblx0TioyICh3aGVyZSBOIGlzIHRoZSBudW1iZXIgb2YgY29ubmVjdGlvbnMpXG5cdGZsb29kLCBpdCBpcyBub3Qgc2NhbGFibGUgZm9yIHRyYWRpdGlvbmFsXG5cdHNlcnZpY2VzIHRoYXQgaGF2ZSBhIGh1YiBuZXR3b3JrIHRvcG9sb2d5LlxuXG5cdERvZXMgdGhpcyBtZWFuIHdlIGhhdmUgdG8gYWJhbmRvbiBtZXNoXG5cdGFsZ29yaXRobXM/IE5vLCB3ZSBjYW4gc2ltcGx5IGxheWVyIG1vcmVcblx0ZWZmaWNpZW50IG9wdGltaXphdGlvbnMgaW4gYmFzZWQgb24gY29uc3RyYWludHMuXG5cdElmIHRoZXNlIGNvbnN0cmFpbnRzIGV4aXN0LCBpdCBhdXRvbWF0aWNhbGx5XG5cdHVwZ3JhZGVzLCBidXQgaWYgbm90LCBpdCBmYWxscyBiYWNrIHRvIHRoZVxuXHRicnV0ZS1mb3JjZSBtZXNoIGJhc2VkIHJvYnVzdCBhbGdvcml0aG0uXG5cdEEgc2ltcGxlIGV4YW1wbGUgaXMgdG8gbGltaXQgcGVlciBjb25uZWN0aW9uc1xuXHRhbmQgcmVseSB1cG9uIGRhaXN5IGNoYWluaW5nIHRvIHJlbGF5IG1lc3NhZ2VzLlxuXG5cdEFub3RoZXIgZXhhbXBsZSwgaXMgaWYgcGVlcnMgYXJlIHdpbGxpbmcgdG9cblx0aWRlbnRpZnkgdGhlbXNlbHZlcywgdGhlbiB3ZSBjYW4gaW1wcm92ZSB0aGVcblx0ZWZmaWNpZW5jeSBvZiB0aGUgbmV0d29yayBieSBoYXZpbmcgZWFjaCBwZWVyXG5cdGluY2x1ZGUgdGhlIG5hbWVzIG9mIHBlZXJzIGl0IGlzIGNvbm5lY3RlZCBpblxuXHRlYWNoIG1lc3NhZ2UuIFRoZW4gZWFjaCBzdWJzZXF1ZW50IHBlZXIgd2lsbFxuXHRub3QgcmVsYXkgaXQgdG8gdGhlbSwgc2luY2UgaXQgaXMgdW5uZWNlc3NhcnkuXG5cdFRoaXMgc2hvdWxkIGNyZWF0ZSBOICh3aGVyZSBOIGlzIHRoZSBudW1iZXIgb2Zcblx0cGVlcnMpIG1lc3NhZ2VzIChvciBwb3NzaWJseSBOKyBpZiB0aGVyZSBpcyBhXG5cdGNvbW1vbiBwZWVyIG9mIHVuY29tbW9uIHBlZXJzIHRoYXQgcmVjZWl2ZXMgaXRcblx0YW5kIHJlbGF5cyBhdCBleGFjdCBsYXRlbmN5IHRpbWluZ3MpLCB3aGljaCBpc1xuXHRvcHRpbWFsLlxuXG5cdFNpbmNlIGNvbXB1dGVyIG5ldHdvcmtzIGFyZW4ndCBhY3R1YWxseSBibGluZCxcblx0d2Ugd2lsbCBpbXBsZW1lbnQgdGhlIGFib3ZlIG1ldGhvZCB0byBpbXByb3ZlXG5cdHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgYWQtaG9jIG1lc2ggbmV0d29yay5cblxuXHRCdXQgd2h5IG5vdCBoYXZlIGV2ZXJ5IG1lc3NhZ2UgY29udGFpbiB0aGVcblx0d2hvbGUgaGlzdG9yeSBvZiBwZWVycyB0aGF0IGl0IHJlbGF5ZWQgdGhyb3VnaD9cblx0QmVjYXVzZSBpbiBzdWZmaWNpZW50bHkgbGFyZ2UgZW5vdWdoIG5ldHdvcmtzLFxuXHR3aXRoIGV4dGVuc2l2ZSBkYWlzeSBjaGFpbmluZywgdGhpcyB3aWxsIGNhdXNlXG5cdHRoZSBtZXNzYWdlIHRvIGJlY29tZSBwcm9oaWJpdGl2ZWx5IHNsb3cgYW5kXG5cdGluY3JlYXNlIGluZGVmaW5pdGVseSBpbiBzaXplLlxuXG4qL1xuXG5HdW4ub24oJ29wdCcsIGZ1bmN0aW9uKHJvb3Qpe1xuXHR2YXIgb3B0ID0gcm9vdC5vcHQ7XG5cdGlmKGZhbHNlID09PSBvcHQud3MgfHwgb3B0Lm9uY2Upe1xuXHRcdHRoaXMudG8ubmV4dChyb290KTtcblx0XHRyZXR1cm47XG5cdH1cdFxuXG5cdHZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblx0b3B0Lm1lc2ggPSBvcHQubWVzaCB8fCBHdW4uTWVzaChyb290KTtcblx0b3B0LldlYlNvY2tldCA9IG9wdC5XZWJTb2NrZXQgfHwgcmVxdWlyZSgnd3MnKTtcblx0dmFyIHdzID0gb3B0LndzID0gb3B0LndzIHx8IHt9O1xuXHR3cy5wYXRoID0gd3MucGF0aCB8fCAnL2d1bic7XG5cdC8vIGlmIHdlIERPIG5lZWQgYW4gSFRUUCBzZXJ2ZXIsIHRoZW4gY2hvb3NlIHdzIHNwZWNpZmljIG9uZSBvciBHVU4gZGVmYXVsdCBvbmUuXG5cdGlmKCF3cy5ub1NlcnZlcil7XG5cdFx0d3Muc2VydmVyID0gd3Muc2VydmVyIHx8IG9wdC53ZWI7XG5cdFx0aWYoIXdzLnNlcnZlcil7IHRoaXMudG8ubmV4dChyb290KTsgcmV0dXJuIH0gLy8gdWdoLCBidWcgZml4IGZvciBAamFtaWVyZXogJiB1bnN0b3BwYWJsZSByeWFuLlxuXHR9XG5cdHdzLndlYiA9IHdzLndlYiB8fCBuZXcgb3B0LldlYlNvY2tldC5TZXJ2ZXIod3MpOyAvLyB3ZSBzdGlsbCBuZWVkIGEgV1Mgc2VydmVyLlxuXHR3cy53ZWIub24oJ2Nvbm5lY3Rpb24nLCBmdW5jdGlvbih3aXJlLCByZXEpeyB2YXIgcGVlcjtcblx0XHR3aXJlLmhlYWRlcnMgPSB3aXJlLmhlYWRlcnMgfHwgKHJlcXx8JycpLmhlYWRlcnMgfHwgJyc7XG5cdFx0Y29uc29sZS5TVEFUICYmICgoY29uc29sZS5TVEFULnNpdGVzIHx8IChjb25zb2xlLlNUQVQuc2l0ZXMgPSB7fSkpW3dpcmUuaGVhZGVycy5vcmlnaW5dID0gMSk7XG5cdFx0b3B0Lm1lc2guaGkocGVlciA9IHt3aXJlOiB3aXJlfSk7XG5cdFx0d2lyZS5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZyl7XG5cdFx0XHRvcHQubWVzaC5oZWFyKG1zZy5kYXRhIHx8IG1zZywgcGVlcik7XG5cdFx0fSk7XG5cdFx0d2lyZS5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuXHRcdFx0b3B0Lm1lc2guYnllKHBlZXIpO1xuXHRcdH0pO1xuXHRcdHdpcmUub24oJ2Vycm9yJywgZnVuY3Rpb24oZSl7fSk7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiBoZWFydCgpeyBpZighb3B0LnBlZXJzW3BlZXIuaWRdKXsgcmV0dXJuIH0gdHJ5eyB3aXJlLnNlbmQoXCJbXVwiKSB9Y2F0Y2goZSl7fSA7c2V0VGltZW91dChoZWFydCwgMTAwMCAqIDIwKSB9LCAxMDAwICogMjApOyAvLyBTb21lIHN5c3RlbXMsIGxpa2UgSGVyb2t1LCByZXF1aXJlIGhlYXJ0YmVhdHMgdG8gbm90IHRpbWUgb3V0LiAvLyBUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlPyAvLyBUT0RPOiBQRVJGOiBGaW5kIGJldHRlciBhcHByb2FjaCB0aGFuIHRyeS90aW1lb3V0cz9cblx0fSk7XG5cdHRoaXMudG8ubmV4dChyb290KTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/wire.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/lib/yson.js":
/*!**************************************!*\
  !*** ./node_modules/gun/lib/yson.js ***!
  \**************************************/
/***/ ((module) => {

eval(";(function(){\n// JSON: JavaScript Object Notation\n// YSON: Yielding javaScript Object Notation\nvar yson = {}, u, sI = setTimeout.turn || (typeof setImmediate != ''+u && setImmediate) || setTimeout;\n\nyson.parseAsync = function(text, done, revive, M){\n\tif('string' != typeof text){ try{ done(u,JSON.parse(text)) }catch(e){ done(e) } return }\n\tvar ctx = {i: 0, text: text, done: done, l: text.length, up: []};\n\t//M = 1024 * 1024 * 100;\n\t//M = M || 1024 * 64;\n\tM = M || 1024 * 32;\n\tparse();\n\tfunction parse(){\n\t\t//var S = +new Date;\n\t\tvar s = ctx.text;\n\t\tvar i = ctx.i, l = ctx.l, j = 0;\n\t\tvar w = ctx.w, b, tmp;\n\t\twhile(j++ < M){\n\t\t\tvar c = s[i++];\n\t\t\tif(i > l){\n\t\t\t\tctx.end = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(w){\n\t\t\t\ti = s.indexOf('\"', i-1); c = s[i];\n\t\t\t\ttmp = 0; while('\\\\' == s[i-(++tmp)]){}; tmp = !(tmp % 2);//tmp = ('\\\\' == s[i-1]); // json is stupid\n\t\t\t\tb = b || tmp;\n\t\t\t\tif('\"' == c && !tmp){\n\t\t\t\t\tw = u;\n\t\t\t\t\ttmp = ctx.s;\n\t\t\t\t\tif(ctx.a){\n\t\t\t\t\t\ttmp = s.slice(ctx.sl, i);\n\t\t\t\t\t\tif(b || (1+tmp.indexOf('\\\\'))){ tmp = JSON.parse('\"'+tmp+'\"') } // escape + unicode :( handling\n\t\t\t\t\t\tif(ctx.at instanceof Array){\n\t\t\t\t\t\t\tctx.at.push(ctx.s = tmp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(!ctx.at){ ctx.end = j = M; tmp = u }\n\t\t\t\t\t\t\t(ctx.at||{})[ctx.s] = ctx.s = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.s = u;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.s = s.slice(ctx.sl, i);\n\t\t\t\t\t\tif(b || (1+ctx.s.indexOf('\\\\'))){ ctx.s = JSON.parse('\"'+ctx.s+'\"'); } // escape + unicode :( handling\n\t\t\t\t\t}\n\t\t\t\t\tctx.a = b = u;\n\t\t\t\t}\n\t\t\t\t++i;\n\t\t\t} else {\n\t\t\t\tswitch(c){\n\t\t\t\tcase '\"':\n\t\t\t\t\tctx.sl = i;\n\t\t\t\t\tw = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ':':\n\t\t\t\t\tctx.ai = i;\n\t\t\t\t\tctx.a = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ',':\n\t\t\t\t\tif(ctx.a || ctx.at instanceof Array){\n\t\t\t\t\t\tif(tmp = s.slice(ctx.ai, i-1)){\n\t\t\t\t\t\t\tif(u !== (tmp = value(tmp))){\n\t\t\t\t\t\t\t\tif(ctx.at instanceof Array){\n\t\t\t\t\t\t\t\t\tctx.at.push(tmp);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tctx.at[ctx.s] = tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.a = u;\n\t\t\t\t\tif(ctx.at instanceof Array){\n\t\t\t\t\t\tctx.a = true;\n\t\t\t\t\t\tctx.ai = i;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '{':\n\t\t\t\t\tctx.up.push(ctx.at||(ctx.at = {}));\n\t\t\t\t\tif(ctx.at instanceof Array){\n\t\t\t\t\t\tctx.at.push(ctx.at = {});\n\t\t\t\t\t} else\n\t\t\t\t\tif(u !== (tmp = ctx.s)){\n\t\t\t\t\t\tctx.at[tmp] = ctx.at = {};\n\t\t\t\t\t}\n\t\t\t\t\tctx.a = u;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif(ctx.a){\n\t\t\t\t\t\tif(tmp = s.slice(ctx.ai, i-1)){\n\t\t\t\t\t\t\tif(u !== (tmp = value(tmp))){\n\t\t\t\t\t\t\t\tif(ctx.at instanceof Array){\n\t\t\t\t\t\t\t\t\tctx.at.push(tmp);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif(!ctx.at){ ctx.end = j = M; tmp = u }\n\t\t\t\t\t\t\t\t\t(ctx.at||{})[ctx.s] = tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.a = u;\n\t\t\t\t\tctx.at = ctx.up.pop();\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[':\n\t\t\t\t\tif(u !== (tmp = ctx.s)){\n\t\t\t\t\t\tctx.up.push(ctx.at);\n\t\t\t\t\t\tctx.at[tmp] = ctx.at = [];\n\t\t\t\t\t} else\n\t\t\t\t\tif(!ctx.at){\n\t\t\t\t\t\tctx.up.push(ctx.at = []);\n\t\t\t\t\t}\n\t\t\t\t\tctx.a = true;\n\t\t\t\t\tctx.ai = i;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ']':\n\t\t\t\t\tif(ctx.a){\n\t\t\t\t\t\tif(tmp = s.slice(ctx.ai, i-1)){\n\t\t\t\t\t\t\tif(u !== (tmp = value(tmp))){\n\t\t\t\t\t\t\t\tif(ctx.at instanceof Array){\n\t\t\t\t\t\t\t\t\tctx.at.push(tmp);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tctx.at[ctx.s] = tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.a = u;\n\t\t\t\t\tctx.at = ctx.up.pop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx.s = u;\n\t\tctx.i = i;\n\t\tctx.w = w;\n\t\tif(ctx.end){\n\t\t\ttmp = ctx.at;\n\t\t\tif(u === tmp){\n\t\t\t\ttry{ tmp = JSON.parse(text)\n\t\t\t\t}catch(e){ return ctx.done(e) }\n\t\t\t}\n\t\t\tctx.done(u, tmp);\n\t\t} else {\n\t\t\tsI(parse);\n\t\t}\n\t}\n}\nfunction value(s){\n\tvar n = parseFloat(s);\n\tif(!isNaN(n)){\n\t\treturn n;\n\t}\n\ts = s.trim();\n\tif('true' == s){\n\t\treturn true;\n\t}\n\tif('false' == s){\n\t\treturn false;\n\t}\n\tif('null' == s){\n\t\treturn null;\n\t}\n}\n\nyson.stringifyAsync = function(data, done, replacer, space, ctx){\n\t//try{done(u, JSON.stringify(data, replacer, space))}catch(e){done(e)}return;\n\tctx = ctx || {};\n\tctx.text = ctx.text || \"\";\n\tctx.up = [ctx.at = {d: data}];\n\tctx.done = done;\n\tctx.i = 0;\n\tvar j = 0;\n\tify();\n\tfunction ify(){\n\t\tvar at = ctx.at, data = at.d, add = '', tmp;\n\t\tif(at.i && (at.i - at.j) > 0){ add += ',' }\n\t\tif(u !== (tmp = at.k)){ add += JSON.stringify(tmp) + ':' } //'\"'+tmp+'\":' } // only if backslash\n\t\tswitch(typeof data){\n\t\tcase 'boolean':\n\t\t\tadd += ''+data;\n\t\t\tbreak;\n\t\tcase 'string':\n\t\t\tadd += JSON.stringify(data); //ctx.text += '\"'+data+'\"';//JSON.stringify(data); // only if backslash\n\t\t\tbreak;\n\t\tcase 'number':\n\t\t\tadd += (isNaN(data)? 'null' : data);\n\t\t\tbreak;\n\t\tcase 'object':\n\t\t\tif(!data){\n\t\t\t\tadd += 'null';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(data instanceof Array){\t\n\t\t\t\tadd += '[';\n\t\t\t\tat = {i: -1, as: data, up: at, j: 0};\n\t\t\t\tat.l = data.length;\n\t\t\t\tctx.up.push(ctx.at = at);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif('function' != typeof (data||'').toJSON){\n\t\t\t\tadd += '{';\n\t\t\t\tat = {i: -1, ok: Object.keys(data).sort(), as: data, up: at, j: 0};\n\t\t\t\tat.l = at.ok.length;\n\t\t\t\tctx.up.push(ctx.at = at);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(tmp = data.toJSON()){\n\t\t\t\tadd += tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// let this & below pass into default case...\n\t\tcase 'function':\n\t\t\tif(at.as instanceof Array){\n\t\t\t\tadd += 'null';\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault: // handle wrongly added leading `,` if previous item not JSON-able.\n\t\t\tadd = '';\n\t\t\tat.j++;\n\t\t}\n\t\tctx.text += add;\n\t\twhile(1+at.i >= at.l){\n\t\t\tctx.text += (at.ok? '}' : ']');\n\t\t\tat = ctx.at = at.up;\n\t\t}\n\t\tif(++at.i < at.l){\n\t\t\tif(tmp = at.ok){\n\t\t\t\tat.d = at.as[at.k = tmp[at.i]];\n\t\t\t} else {\n\t\t\t\tat.d = at.as[at.i];\n\t\t\t}\n\t\t\tif(++j < 9){ return ify() } else { j = 0 }\n\t\t\tsI(ify);\n\t\t\treturn;\n\t\t}\n\t\tctx.done(u, ctx.text);\n\t}\n}\nif(typeof window != ''+u){ window.YSON = yson }\ntry{ if(\"object\" != ''+u){ module.exports = yson } }catch(e){}\nif(typeof JSON != ''+u){\n\tJSON.parseAsync = yson.parseAsync;\n\tJSON.stringifyAsync = yson.stringifyAsync;\n}\n\n}());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3VuL2xpYi95c29uLmpzIiwibWFwcGluZ3MiOiJBQUFBLENBQUM7QUFDRDtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLDhCQUE4QixLQUFLLDBCQUEwQixVQUFVLFVBQVU7QUFDakYsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGFBQWEsK0JBQStCLGlCQUFpQiwwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQixpQkFBaUI7QUFDckMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MscUNBQXFDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLHFDQUFxQztBQUNyQztBQUNBLDZCQUE2QjtBQUM3QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNCQUFzQixpQkFBaUI7QUFDdkMsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSyxVQUFVO0FBQ2Y7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTywrQ0FBK0MsU0FBUyxRQUFRO0FBQ3ZFO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsMEJBQTBCLG1DQUFtQyxpQkFBaUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkIsd0JBQXdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZSxPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixLQUFLLEdBQUcsUUFBYSxXQUFXLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMy1jaGF0Ly4vbm9kZV9tb2R1bGVzL2d1bi9saWIveXNvbi5qcz8wZWFiIl0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24oKXtcbi8vIEpTT046IEphdmFTY3JpcHQgT2JqZWN0IE5vdGF0aW9uXG4vLyBZU09OOiBZaWVsZGluZyBqYXZhU2NyaXB0IE9iamVjdCBOb3RhdGlvblxudmFyIHlzb24gPSB7fSwgdSwgc0kgPSBzZXRUaW1lb3V0LnR1cm4gfHwgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT0gJycrdSAmJiBzZXRJbW1lZGlhdGUpIHx8IHNldFRpbWVvdXQ7XG5cbnlzb24ucGFyc2VBc3luYyA9IGZ1bmN0aW9uKHRleHQsIGRvbmUsIHJldml2ZSwgTSl7XG5cdGlmKCdzdHJpbmcnICE9IHR5cGVvZiB0ZXh0KXsgdHJ5eyBkb25lKHUsSlNPTi5wYXJzZSh0ZXh0KSkgfWNhdGNoKGUpeyBkb25lKGUpIH0gcmV0dXJuIH1cblx0dmFyIGN0eCA9IHtpOiAwLCB0ZXh0OiB0ZXh0LCBkb25lOiBkb25lLCBsOiB0ZXh0Lmxlbmd0aCwgdXA6IFtdfTtcblx0Ly9NID0gMTAyNCAqIDEwMjQgKiAxMDA7XG5cdC8vTSA9IE0gfHwgMTAyNCAqIDY0O1xuXHRNID0gTSB8fCAxMDI0ICogMzI7XG5cdHBhcnNlKCk7XG5cdGZ1bmN0aW9uIHBhcnNlKCl7XG5cdFx0Ly92YXIgUyA9ICtuZXcgRGF0ZTtcblx0XHR2YXIgcyA9IGN0eC50ZXh0O1xuXHRcdHZhciBpID0gY3R4LmksIGwgPSBjdHgubCwgaiA9IDA7XG5cdFx0dmFyIHcgPSBjdHgudywgYiwgdG1wO1xuXHRcdHdoaWxlKGorKyA8IE0pe1xuXHRcdFx0dmFyIGMgPSBzW2krK107XG5cdFx0XHRpZihpID4gbCl7XG5cdFx0XHRcdGN0eC5lbmQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmKHcpe1xuXHRcdFx0XHRpID0gcy5pbmRleE9mKCdcIicsIGktMSk7IGMgPSBzW2ldO1xuXHRcdFx0XHR0bXAgPSAwOyB3aGlsZSgnXFxcXCcgPT0gc1tpLSgrK3RtcCldKXt9OyB0bXAgPSAhKHRtcCAlIDIpOy8vdG1wID0gKCdcXFxcJyA9PSBzW2ktMV0pOyAvLyBqc29uIGlzIHN0dXBpZFxuXHRcdFx0XHRiID0gYiB8fCB0bXA7XG5cdFx0XHRcdGlmKCdcIicgPT0gYyAmJiAhdG1wKXtcblx0XHRcdFx0XHR3ID0gdTtcblx0XHRcdFx0XHR0bXAgPSBjdHgucztcblx0XHRcdFx0XHRpZihjdHguYSl7XG5cdFx0XHRcdFx0XHR0bXAgPSBzLnNsaWNlKGN0eC5zbCwgaSk7XG5cdFx0XHRcdFx0XHRpZihiIHx8ICgxK3RtcC5pbmRleE9mKCdcXFxcJykpKXsgdG1wID0gSlNPTi5wYXJzZSgnXCInK3RtcCsnXCInKSB9IC8vIGVzY2FwZSArIHVuaWNvZGUgOiggaGFuZGxpbmdcblx0XHRcdFx0XHRcdGlmKGN0eC5hdCBpbnN0YW5jZW9mIEFycmF5KXtcblx0XHRcdFx0XHRcdFx0Y3R4LmF0LnB1c2goY3R4LnMgPSB0bXApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYoIWN0eC5hdCl7IGN0eC5lbmQgPSBqID0gTTsgdG1wID0gdSB9XG5cdFx0XHRcdFx0XHRcdChjdHguYXR8fHt9KVtjdHguc10gPSBjdHgucyA9IHRtcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN0eC5zID0gdTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3R4LnMgPSBzLnNsaWNlKGN0eC5zbCwgaSk7XG5cdFx0XHRcdFx0XHRpZihiIHx8ICgxK2N0eC5zLmluZGV4T2YoJ1xcXFwnKSkpeyBjdHgucyA9IEpTT04ucGFyc2UoJ1wiJytjdHgucysnXCInKTsgfSAvLyBlc2NhcGUgKyB1bmljb2RlIDooIGhhbmRsaW5nXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5hID0gYiA9IHU7XG5cdFx0XHRcdH1cblx0XHRcdFx0KytpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3dpdGNoKGMpe1xuXHRcdFx0XHRjYXNlICdcIic6XG5cdFx0XHRcdFx0Y3R4LnNsID0gaTtcblx0XHRcdFx0XHR3ID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnOic6XG5cdFx0XHRcdFx0Y3R4LmFpID0gaTtcblx0XHRcdFx0XHRjdHguYSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJywnOlxuXHRcdFx0XHRcdGlmKGN0eC5hIHx8IGN0eC5hdCBpbnN0YW5jZW9mIEFycmF5KXtcblx0XHRcdFx0XHRcdGlmKHRtcCA9IHMuc2xpY2UoY3R4LmFpLCBpLTEpKXtcblx0XHRcdFx0XHRcdFx0aWYodSAhPT0gKHRtcCA9IHZhbHVlKHRtcCkpKXtcblx0XHRcdFx0XHRcdFx0XHRpZihjdHguYXQgaW5zdGFuY2VvZiBBcnJheSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdHguYXQucHVzaCh0bXApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdHguYXRbY3R4LnNdID0gdG1wO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguYSA9IHU7XG5cdFx0XHRcdFx0aWYoY3R4LmF0IGluc3RhbmNlb2YgQXJyYXkpe1xuXHRcdFx0XHRcdFx0Y3R4LmEgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y3R4LmFpID0gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3snOlxuXHRcdFx0XHRcdGN0eC51cC5wdXNoKGN0eC5hdHx8KGN0eC5hdCA9IHt9KSk7XG5cdFx0XHRcdFx0aWYoY3R4LmF0IGluc3RhbmNlb2YgQXJyYXkpe1xuXHRcdFx0XHRcdFx0Y3R4LmF0LnB1c2goY3R4LmF0ID0ge30pO1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdGlmKHUgIT09ICh0bXAgPSBjdHgucykpe1xuXHRcdFx0XHRcdFx0Y3R4LmF0W3RtcF0gPSBjdHguYXQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LmEgPSB1O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICd9Jzpcblx0XHRcdFx0XHRpZihjdHguYSl7XG5cdFx0XHRcdFx0XHRpZih0bXAgPSBzLnNsaWNlKGN0eC5haSwgaS0xKSl7XG5cdFx0XHRcdFx0XHRcdGlmKHUgIT09ICh0bXAgPSB2YWx1ZSh0bXApKSl7XG5cdFx0XHRcdFx0XHRcdFx0aWYoY3R4LmF0IGluc3RhbmNlb2YgQXJyYXkpe1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4LmF0LnB1c2godG1wKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIWN0eC5hdCl7IGN0eC5lbmQgPSBqID0gTTsgdG1wID0gdSB9XG5cdFx0XHRcdFx0XHRcdFx0XHQoY3R4LmF0fHx7fSlbY3R4LnNdID0gdG1wO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguYSA9IHU7XG5cdFx0XHRcdFx0Y3R4LmF0ID0gY3R4LnVwLnBvcCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdbJzpcblx0XHRcdFx0XHRpZih1ICE9PSAodG1wID0gY3R4LnMpKXtcblx0XHRcdFx0XHRcdGN0eC51cC5wdXNoKGN0eC5hdCk7XG5cdFx0XHRcdFx0XHRjdHguYXRbdG1wXSA9IGN0eC5hdCA9IFtdO1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdGlmKCFjdHguYXQpe1xuXHRcdFx0XHRcdFx0Y3R4LnVwLnB1c2goY3R4LmF0ID0gW10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguYSA9IHRydWU7XG5cdFx0XHRcdFx0Y3R4LmFpID0gaTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnXSc6XG5cdFx0XHRcdFx0aWYoY3R4LmEpe1xuXHRcdFx0XHRcdFx0aWYodG1wID0gcy5zbGljZShjdHguYWksIGktMSkpe1xuXHRcdFx0XHRcdFx0XHRpZih1ICE9PSAodG1wID0gdmFsdWUodG1wKSkpe1xuXHRcdFx0XHRcdFx0XHRcdGlmKGN0eC5hdCBpbnN0YW5jZW9mIEFycmF5KXtcblx0XHRcdFx0XHRcdFx0XHRcdGN0eC5hdC5wdXNoKHRtcCk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN0eC5hdFtjdHguc10gPSB0bXA7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5hID0gdTtcblx0XHRcdFx0XHRjdHguYXQgPSBjdHgudXAucG9wKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y3R4LnMgPSB1O1xuXHRcdGN0eC5pID0gaTtcblx0XHRjdHgudyA9IHc7XG5cdFx0aWYoY3R4LmVuZCl7XG5cdFx0XHR0bXAgPSBjdHguYXQ7XG5cdFx0XHRpZih1ID09PSB0bXApe1xuXHRcdFx0XHR0cnl7IHRtcCA9IEpTT04ucGFyc2UodGV4dClcblx0XHRcdFx0fWNhdGNoKGUpeyByZXR1cm4gY3R4LmRvbmUoZSkgfVxuXHRcdFx0fVxuXHRcdFx0Y3R4LmRvbmUodSwgdG1wKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c0kocGFyc2UpO1xuXHRcdH1cblx0fVxufVxuZnVuY3Rpb24gdmFsdWUocyl7XG5cdHZhciBuID0gcGFyc2VGbG9hdChzKTtcblx0aWYoIWlzTmFOKG4pKXtcblx0XHRyZXR1cm4gbjtcblx0fVxuXHRzID0gcy50cmltKCk7XG5cdGlmKCd0cnVlJyA9PSBzKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZignZmFsc2UnID09IHMpe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZignbnVsbCcgPT0gcyl7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxueXNvbi5zdHJpbmdpZnlBc3luYyA9IGZ1bmN0aW9uKGRhdGEsIGRvbmUsIHJlcGxhY2VyLCBzcGFjZSwgY3R4KXtcblx0Ly90cnl7ZG9uZSh1LCBKU09OLnN0cmluZ2lmeShkYXRhLCByZXBsYWNlciwgc3BhY2UpKX1jYXRjaChlKXtkb25lKGUpfXJldHVybjtcblx0Y3R4ID0gY3R4IHx8IHt9O1xuXHRjdHgudGV4dCA9IGN0eC50ZXh0IHx8IFwiXCI7XG5cdGN0eC51cCA9IFtjdHguYXQgPSB7ZDogZGF0YX1dO1xuXHRjdHguZG9uZSA9IGRvbmU7XG5cdGN0eC5pID0gMDtcblx0dmFyIGogPSAwO1xuXHRpZnkoKTtcblx0ZnVuY3Rpb24gaWZ5KCl7XG5cdFx0dmFyIGF0ID0gY3R4LmF0LCBkYXRhID0gYXQuZCwgYWRkID0gJycsIHRtcDtcblx0XHRpZihhdC5pICYmIChhdC5pIC0gYXQuaikgPiAwKXsgYWRkICs9ICcsJyB9XG5cdFx0aWYodSAhPT0gKHRtcCA9IGF0LmspKXsgYWRkICs9IEpTT04uc3RyaW5naWZ5KHRtcCkgKyAnOicgfSAvLydcIicrdG1wKydcIjonIH0gLy8gb25seSBpZiBiYWNrc2xhc2hcblx0XHRzd2l0Y2godHlwZW9mIGRhdGEpe1xuXHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXHRcdFx0YWRkICs9ICcnK2RhdGE7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzdHJpbmcnOlxuXHRcdFx0YWRkICs9IEpTT04uc3RyaW5naWZ5KGRhdGEpOyAvL2N0eC50ZXh0ICs9ICdcIicrZGF0YSsnXCInOy8vSlNPTi5zdHJpbmdpZnkoZGF0YSk7IC8vIG9ubHkgaWYgYmFja3NsYXNoXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdudW1iZXInOlxuXHRcdFx0YWRkICs9IChpc05hTihkYXRhKT8gJ251bGwnIDogZGF0YSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdvYmplY3QnOlxuXHRcdFx0aWYoIWRhdGEpe1xuXHRcdFx0XHRhZGQgKz0gJ251bGwnO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmKGRhdGEgaW5zdGFuY2VvZiBBcnJheSl7XHRcblx0XHRcdFx0YWRkICs9ICdbJztcblx0XHRcdFx0YXQgPSB7aTogLTEsIGFzOiBkYXRhLCB1cDogYXQsIGo6IDB9O1xuXHRcdFx0XHRhdC5sID0gZGF0YS5sZW5ndGg7XG5cdFx0XHRcdGN0eC51cC5wdXNoKGN0eC5hdCA9IGF0KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZignZnVuY3Rpb24nICE9IHR5cGVvZiAoZGF0YXx8JycpLnRvSlNPTil7XG5cdFx0XHRcdGFkZCArPSAneyc7XG5cdFx0XHRcdGF0ID0ge2k6IC0xLCBvazogT2JqZWN0LmtleXMoZGF0YSkuc29ydCgpLCBhczogZGF0YSwgdXA6IGF0LCBqOiAwfTtcblx0XHRcdFx0YXQubCA9IGF0Lm9rLmxlbmd0aDtcblx0XHRcdFx0Y3R4LnVwLnB1c2goY3R4LmF0ID0gYXQpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmKHRtcCA9IGRhdGEudG9KU09OKCkpe1xuXHRcdFx0XHRhZGQgKz0gdG1wO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdC8vIGxldCB0aGlzICYgYmVsb3cgcGFzcyBpbnRvIGRlZmF1bHQgY2FzZS4uLlxuXHRcdGNhc2UgJ2Z1bmN0aW9uJzpcblx0XHRcdGlmKGF0LmFzIGluc3RhbmNlb2YgQXJyYXkpe1xuXHRcdFx0XHRhZGQgKz0gJ251bGwnO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRkZWZhdWx0OiAvLyBoYW5kbGUgd3JvbmdseSBhZGRlZCBsZWFkaW5nIGAsYCBpZiBwcmV2aW91cyBpdGVtIG5vdCBKU09OLWFibGUuXG5cdFx0XHRhZGQgPSAnJztcblx0XHRcdGF0LmorKztcblx0XHR9XG5cdFx0Y3R4LnRleHQgKz0gYWRkO1xuXHRcdHdoaWxlKDErYXQuaSA+PSBhdC5sKXtcblx0XHRcdGN0eC50ZXh0ICs9IChhdC5vaz8gJ30nIDogJ10nKTtcblx0XHRcdGF0ID0gY3R4LmF0ID0gYXQudXA7XG5cdFx0fVxuXHRcdGlmKCsrYXQuaSA8IGF0Lmwpe1xuXHRcdFx0aWYodG1wID0gYXQub2spe1xuXHRcdFx0XHRhdC5kID0gYXQuYXNbYXQuayA9IHRtcFthdC5pXV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdC5kID0gYXQuYXNbYXQuaV07XG5cdFx0XHR9XG5cdFx0XHRpZigrK2ogPCA5KXsgcmV0dXJuIGlmeSgpIH0gZWxzZSB7IGogPSAwIH1cblx0XHRcdHNJKGlmeSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGN0eC5kb25lKHUsIGN0eC50ZXh0KTtcblx0fVxufVxuaWYodHlwZW9mIHdpbmRvdyAhPSAnJyt1KXsgd2luZG93LllTT04gPSB5c29uIH1cbnRyeXsgaWYodHlwZW9mIG1vZHVsZSAhPSAnJyt1KXsgbW9kdWxlLmV4cG9ydHMgPSB5c29uIH0gfWNhdGNoKGUpe31cbmlmKHR5cGVvZiBKU09OICE9ICcnK3Upe1xuXHRKU09OLnBhcnNlQXN5bmMgPSB5c29uLnBhcnNlQXN5bmM7XG5cdEpTT04uc3RyaW5naWZ5QXN5bmMgPSB5c29uLnN0cmluZ2lmeUFzeW5jO1xufVxuXG59KCkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/lib/yson.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gun/sea.js":
/*!*********************************!*\
  !*** ./node_modules/gun/sea.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n;(function(){\n\n  /* UNBUILD */\n  function USE(arg, req){\n    return req? __webpack_require__(\"(ssr)/./node_modules/gun sync recursive\")(arg) : arg.slice? USE[R(arg)] : function(mod, path){\n      arg(mod = {exports: {}});\n      USE[R(path)] = mod.exports;\n    }\n    function R(p){\n      return p.split('/').slice(-1).toString().replace('.js','');\n    }\n  }\n  if(true){ var MODULE = module }\n  /* UNBUILD */\n\n  ;USE(function(module){\n    // Security, Encryption, and Authorization: SEA.js\n    // MANDATORY READING: https://gun.eco/explainers/data/security.html\n    // IT IS IMPLEMENTED IN A POLYFILL/SHIM APPROACH.\n    // THIS IS AN EARLY ALPHA!\n\n    if(typeof self !== \"undefined\"){ module.window = self } // should be safe for at least browser/worker/nodejs, need to check other envs like RN etc.\n    if(typeof window !== \"undefined\"){ module.window = window }\n\n    var tmp = module.window || module, u;\n    var SEA = tmp.SEA || {};\n\n    if(SEA.window = module.window){ SEA.window.SEA = SEA }\n\n    try{ if(u+'' !== typeof MODULE){ MODULE.exports = SEA } }catch(e){}\n    module.exports = SEA;\n  })(USE, './root');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    try{ if(SEA.window){\n      if(location.protocol.indexOf('s') < 0\n      && location.host.indexOf('localhost') < 0\n      && ! /^127\\.\\d+\\.\\d+\\.\\d+$/.test(location.hostname)\n      && location.protocol.indexOf('file:') < 0){\n        console.warn('HTTPS needed for WebCrypto in SEA, redirecting...');\n        location.protocol = 'https:'; // WebCrypto does NOT work without HTTPS!\n      }\n    } }catch(e){}\n  })(USE, './https');\n\n  ;USE(function(module){\n    var u;\n    if(u+''== typeof btoa){\n      if(u+'' == typeof Buffer){\n        try{ global.Buffer = USE(\"buffer\", 1).Buffer }catch(e){ console.log(\"Please `npm install buffer` or add it to your package.json !\") }\n      }\n      global.btoa = function(data){ return Buffer.from(data, \"binary\").toString(\"base64\") };\n      global.atob = function(data){ return Buffer.from(data, \"base64\").toString(\"binary\") };\n    }\n  })(USE, './base64');\n\n  ;USE(function(module){\n    USE('./base64');\n    // This is Array extended to have .toString(['utf8'|'hex'|'base64'])\n    function SeaArray() {}\n    Object.assign(SeaArray, { from: Array.from })\n    SeaArray.prototype = Object.create(Array.prototype)\n    SeaArray.prototype.toString = function(enc, start, end) { enc = enc || 'utf8'; start = start || 0;\n      const length = this.length\n      if (enc === 'hex') {\n        const buf = new Uint8Array(this)\n        return [ ...Array(((end && (end + 1)) || length) - start).keys()]\n        .map((i) => buf[ i + start ].toString(16).padStart(2, '0')).join('')\n      }\n      if (enc === 'utf8') {\n        return Array.from(\n          { length: (end || length) - start },\n          (_, i) => String.fromCharCode(this[ i + start])\n        ).join('')\n      }\n      if (enc === 'base64') {\n        return btoa(this)\n      }\n    }\n    module.exports = SeaArray;\n  })(USE, './array');\n\n  ;USE(function(module){\n    USE('./base64');\n    // This is Buffer implementation used in SEA. Functionality is mostly\n    // compatible with NodeJS 'safe-buffer' and is used for encoding conversions\n    // between binary and 'hex' | 'utf8' | 'base64'\n    // See documentation and validation for safe implementation in:\n    // https://github.com/feross/safe-buffer#update\n    var SeaArray = USE('./array');\n    function SafeBuffer(...props) {\n      console.warn('new SafeBuffer() is depreciated, please use SafeBuffer.from()')\n      return SafeBuffer.from(...props)\n    }\n    SafeBuffer.prototype = Object.create(Array.prototype)\n    Object.assign(SafeBuffer, {\n      // (data, enc) where typeof data === 'string' then enc === 'utf8'|'hex'|'base64'\n      from() {\n        if (!Object.keys(arguments).length || arguments[0]==null) {\n          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n        }\n        const input = arguments[0]\n        let buf\n        if (typeof input === 'string') {\n          const enc = arguments[1] || 'utf8'\n          if (enc === 'hex') {\n            const bytes = input.match(/([\\da-fA-F]{2})/g)\n            .map((byte) => parseInt(byte, 16))\n            if (!bytes || !bytes.length) {\n              throw new TypeError('Invalid first argument for type \\'hex\\'.')\n            }\n            buf = SeaArray.from(bytes)\n          } else if (enc === 'utf8' || 'binary' === enc) { // EDIT BY MARK: I think this is safe, tested it against a couple \"binary\" strings. This lets SafeBuffer match NodeJS Buffer behavior more where it safely btoas regular strings.\n            const length = input.length\n            const words = new Uint16Array(length)\n            Array.from({ length: length }, (_, i) => words[i] = input.charCodeAt(i))\n            buf = SeaArray.from(words)\n          } else if (enc === 'base64') {\n            const dec = atob(input)\n            const length = dec.length\n            const bytes = new Uint8Array(length)\n            Array.from({ length: length }, (_, i) => bytes[i] = dec.charCodeAt(i))\n            buf = SeaArray.from(bytes)\n          } else if (enc === 'binary') { // deprecated by above comment\n            buf = SeaArray.from(input) // some btoas were mishandled.\n          } else {\n            console.info('SafeBuffer.from unknown encoding: '+enc)\n          }\n          return buf\n        }\n        const byteLength = input.byteLength // what is going on here? FOR MARTTI\n        const length = input.byteLength ? input.byteLength : input.length\n        if (length) {\n          let buf\n          if (input instanceof ArrayBuffer) {\n            buf = new Uint8Array(input)\n          }\n          return SeaArray.from(buf || input)\n        }\n      },\n      // This is 'safe-buffer.alloc' sans encoding support\n      alloc(length, fill = 0 /*, enc*/ ) {\n        return SeaArray.from(new Uint8Array(Array.from({ length: length }, () => fill)))\n      },\n      // This is normal UNSAFE 'buffer.alloc' or 'new Buffer(length)' - don't use!\n      allocUnsafe(length) {\n        return SeaArray.from(new Uint8Array(Array.from({ length : length })))\n      },\n      // This puts together array of array like members\n      concat(arr) { // octet array\n        if (!Array.isArray(arr)) {\n          throw new TypeError('First argument must be Array containing ArrayBuffer or Uint8Array instances.')\n        }\n        return SeaArray.from(arr.reduce((ret, item) => ret.concat(Array.from(item)), []))\n      }\n    })\n    SafeBuffer.prototype.from = SafeBuffer.from\n    SafeBuffer.prototype.toString = SeaArray.prototype.toString\n\n    module.exports = SafeBuffer;\n  })(USE, './buffer');\n\n  ;USE(function(module){\n    const SEA = USE('./root')\n    const api = {Buffer: USE('./buffer')}\n    var o = {}, u;\n\n    // ideally we can move away from JSON entirely? unlikely due to compatibility issues... oh well.\n    JSON.parseAsync = JSON.parseAsync || function(t,cb,r){ var u; try{ cb(u, JSON.parse(t,r)) }catch(e){ cb(e) } }\n    JSON.stringifyAsync = JSON.stringifyAsync || function(v,cb,r,s){ var u; try{ cb(u, JSON.stringify(v,r,s)) }catch(e){ cb(e) } }\n\n    api.parse = function(t,r){ return new Promise(function(res, rej){\n      JSON.parseAsync(t,function(err, raw){ err? rej(err) : res(raw) },r);\n    })}\n    api.stringify = function(v,r,s){ return new Promise(function(res, rej){\n      JSON.stringifyAsync(v,function(err, raw){ err? rej(err) : res(raw) },r,s);\n    })}\n\n    if(SEA.window){\n      api.crypto = SEA.window.crypto || SEA.window.msCrypto\n      api.subtle = (api.crypto||o).subtle || (api.crypto||o).webkitSubtle;\n      api.TextEncoder = SEA.window.TextEncoder;\n      api.TextDecoder = SEA.window.TextDecoder;\n      api.random = (len) => api.Buffer.from(api.crypto.getRandomValues(new Uint8Array(api.Buffer.alloc(len))));\n    }\n    if(!api.TextDecoder)\n    {\n      const { TextEncoder, TextDecoder } = USE((u+'' == typeof MODULE?'.':'')+'./lib/text-encoding', 1);\n      api.TextDecoder = TextDecoder;\n      api.TextEncoder = TextEncoder;\n    }\n    if(!api.crypto)\n    {\n      try\n      {\n      var crypto = USE('crypto', 1);\n      Object.assign(api, {\n        crypto,\n        random: (len) => api.Buffer.from(crypto.randomBytes(len))\n      });      \n      const { Crypto: WebCrypto } = USE('@peculiar/webcrypto', 1);\n      api.ossl = api.subtle = new WebCrypto({directory: 'ossl'}).subtle // ECDH\n    }\n    catch(e){\n      console.log(\"Please `npm install @peculiar/webcrypto` or add it to your package.json !\");\n    }}\n\n    module.exports = api\n  })(USE, './shim');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var s = {};\n    s.pbkdf2 = {hash: {name : 'SHA-256'}, iter: 100000, ks: 64};\n    s.ecdsa = {\n      pair: {name: 'ECDSA', namedCurve: 'P-256'},\n      sign: {name: 'ECDSA', hash: {name: 'SHA-256'}}\n    };\n    s.ecdh = {name: 'ECDH', namedCurve: 'P-256'};\n\n    // This creates Web Cryptography API compliant JWK for sign/verify purposes\n    s.jwk = function(pub, d){  // d === priv\n      pub = pub.split('.');\n      var x = pub[0], y = pub[1];\n      var jwk = {kty: \"EC\", crv: \"P-256\", x: x, y: y, ext: true};\n      jwk.key_ops = d ? ['sign'] : ['verify'];\n      if(d){ jwk.d = d }\n      return jwk;\n    };\n    \n    s.keyToJwk = function(keyBytes) {\n      const keyB64 = keyBytes.toString('base64');\n      const k = keyB64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n      return { kty: 'oct', k: k, ext: false, alg: 'A256GCM' };\n    }\n\n    s.recall = {\n      validity: 12 * 60 * 60, // internally in seconds : 12 hours\n      hook: function(props){ return props } // { iat, exp, alias, remember } // or return new Promise((resolve, reject) => resolve(props)\n    };\n\n    s.check = function(t){ return (typeof t == 'string') && ('SEA{' === t.slice(0,4)) }\n    s.parse = async function p(t){ try {\n      var yes = (typeof t == 'string');\n      if(yes && 'SEA{' === t.slice(0,4)){ t = t.slice(3) }\n      return yes ? await shim.parse(t) : t;\n      } catch (e) {}\n      return t;\n    }\n\n    SEA.opt = s;\n    module.exports = s\n  })(USE, './settings');\n\n  ;USE(function(module){\n    var shim = USE('./shim');\n    module.exports = async function(d, o){\n      var t = (typeof d == 'string')? d : await shim.stringify(d);\n      var hash = await shim.subtle.digest({name: o||'SHA-256'}, new shim.TextEncoder().encode(t));\n      return shim.Buffer.from(hash);\n    }\n  })(USE, './sha256');\n\n  ;USE(function(module){\n    // This internal func returns SHA-1 hashed data for KeyID generation\n    const __shim = USE('./shim')\n    const subtle = __shim.subtle\n    const ossl = __shim.ossl ? __shim.ossl : subtle\n    const sha1hash = (b) => ossl.digest({name: 'SHA-1'}, new ArrayBuffer(b))\n    module.exports = sha1hash\n  })(USE, './sha1');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.work = SEA.work || (async (data, pair, cb, opt) => { try { // used to be named `proof`\n      var salt = (pair||{}).epub || pair; // epub not recommended, salt should be random!\n      opt = opt || {};\n      if(salt instanceof Function){\n        cb = salt;\n        salt = u;\n      }\n      data = (typeof data == 'string')? data : await shim.stringify(data);\n      if('sha' === (opt.name||'').toLowerCase().slice(0,3)){\n        var rsha = shim.Buffer.from(await sha(data, opt.name), 'binary').toString(opt.encode || 'base64')\n        if(cb){ try{ cb(rsha) }catch(e){console.log(e)} }\n        return rsha;\n      }\n      salt = salt || shim.random(9);\n      var key = await (shim.ossl || shim.subtle).importKey('raw', new shim.TextEncoder().encode(data), {name: opt.name || 'PBKDF2'}, false, ['deriveBits']);\n      var work = await (shim.ossl || shim.subtle).deriveBits({\n        name: opt.name || 'PBKDF2',\n        iterations: opt.iterations || S.pbkdf2.iter,\n        salt: new shim.TextEncoder().encode(opt.salt || salt),\n        hash: opt.hash || S.pbkdf2.hash,\n      }, key, opt.length || (S.pbkdf2.ks * 8))\n      data = shim.random(data.length)  // Erase data in case of passphrase\n      var r = shim.Buffer.from(work, 'binary').toString(opt.encode || 'base64')\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) { \n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.work;\n  })(USE, './work');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n\n    SEA.name = SEA.name || (async (cb, opt) => { try {\n      if(cb){ try{ cb() }catch(e){console.log(e)} }\n      return;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    //SEA.pair = async (data, proof, cb) => { try {\n    SEA.pair = SEA.pair || (async (cb, opt) => { try {\n\n      var ecdhSubtle = shim.ossl || shim.subtle;\n      // First: ECDSA keys for signing/verifying...\n      var sa = await shim.subtle.generateKey({name: 'ECDSA', namedCurve: 'P-256'}, true, [ 'sign', 'verify' ])\n      .then(async (keys) => {\n        // privateKey scope doesn't leak out from here!\n        //const { d: priv } = await shim.subtle.exportKey('jwk', keys.privateKey)\n        var key = {};\n        key.priv = (await shim.subtle.exportKey('jwk', keys.privateKey)).d;\n        var pub = await shim.subtle.exportKey('jwk', keys.publicKey);\n        //const pub = Buff.from([ x, y ].join(':')).toString('base64') // old\n        key.pub = pub.x+'.'+pub.y; // new\n        // x and y are already base64\n        // pub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\n        // but split on a non-base64 letter.\n        return key;\n      })\n      \n      // To include PGPv4 kind of keyId:\n      // const pubId = await SEA.keyid(keys.pub)\n      // Next: ECDH keys for encryption/decryption...\n\n      try{\n      var dh = await ecdhSubtle.generateKey({name: 'ECDH', namedCurve: 'P-256'}, true, ['deriveKey'])\n      .then(async (keys) => {\n        // privateKey scope doesn't leak out from here!\n        var key = {};\n        key.epriv = (await ecdhSubtle.exportKey('jwk', keys.privateKey)).d;\n        var pub = await ecdhSubtle.exportKey('jwk', keys.publicKey);\n        //const epub = Buff.from([ ex, ey ].join(':')).toString('base64') // old\n        key.epub = pub.x+'.'+pub.y; // new\n        // ex and ey are already base64\n        // epub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\n        // but split on a non-base64 letter.\n        return key;\n      })\n      }catch(e){\n        if(SEA.window){ throw e }\n        if(e == 'Error: ECDH is not a supported algorithm'){ console.log('Ignoring ECDH...') }\n        else { throw e }\n      } dh = dh || {};\n\n      var r = { pub: sa.pub, priv: sa.priv, /* pubId, */ epub: dh.epub, epriv: dh.epriv }\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.pair;\n  })(USE, './pair');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.sign = SEA.sign || (async (data, pair, cb, opt) => { try {\n      opt = opt || {};\n      if(!(pair||opt).priv){\n        if(!SEA.I){ throw 'No signing key.' }\n        pair = await SEA.I(null, {what: data, how: 'sign', why: opt.why});\n      }\n      if(u === data){ throw '`undefined` not allowed.' }\n      var json = await S.parse(data);\n      var check = opt.check = opt.check || json;\n      if(SEA.verify && (SEA.opt.check(check) || (check && check.s && check.m))\n      && u !== await SEA.verify(check, pair)){ // don't sign if we already signed it.\n        var r = await S.parse(check);\n        if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\n        if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n        return r;\n      }\n      var pub = pair.pub;\n      var priv = pair.priv;\n      var jwk = S.jwk(pub, priv);\n      var hash = await sha(json);\n      var sig = await (shim.ossl || shim.subtle).importKey('jwk', jwk, {name: 'ECDSA', namedCurve: 'P-256'}, false, ['sign'])\n      .then((key) => (shim.ossl || shim.subtle).sign({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, new Uint8Array(hash))) // privateKey scope doesn't leak out from here!\n      var r = {m: json, s: shim.Buffer.from(sig, 'binary').toString(opt.encode || 'base64')}\n      if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\n\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.sign;\n  })(USE, './sign');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.verify = SEA.verify || (async (data, pair, cb, opt) => { try {\n      var json = await S.parse(data);\n      if(false === pair){ // don't verify!\n        var raw = await S.parse(json.m);\n        if(cb){ try{ cb(raw) }catch(e){console.log(e)} }\n        return raw;\n      }\n      opt = opt || {};\n      // SEA.I // verify is free! Requires no user permission.\n      var pub = pair.pub || pair;\n      var key = SEA.opt.slow_leak? await SEA.opt.slow_leak(pub) : await (shim.ossl || shim.subtle).importKey('jwk', S.jwk(pub), {name: 'ECDSA', namedCurve: 'P-256'}, false, ['verify']);\n      var hash = await sha(json.m);\n      var buf, sig, check, tmp; try{\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64'); // NEW DEFAULT!\n        sig = new Uint8Array(buf);\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash));\n        if(!check){ throw \"Signature did not match.\" }\n      }catch(e){\n        if(SEA.opt.fallback){\n          return await SEA.opt.fall_verify(data, pair, cb, opt);\n        }\n      }\n      var r = check? await S.parse(json.m) : u;\n\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e); // mismatched owner FOR MARTTI\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.verify;\n    // legacy & ossl memory leak mitigation:\n\n    var knownKeys = {};\n    var keyForPair = SEA.opt.slow_leak = pair => {\n      if (knownKeys[pair]) return knownKeys[pair];\n      var jwk = S.jwk(pair);\n      knownKeys[pair] = (shim.ossl || shim.subtle).importKey(\"jwk\", jwk, {name: 'ECDSA', namedCurve: 'P-256'}, false, [\"verify\"]);\n      return knownKeys[pair];\n    };\n\n    var O = SEA.opt;\n    SEA.opt.fall_verify = async function(data, pair, cb, opt, f){\n      if(f === SEA.opt.fallback){ throw \"Signature did not match\" } f = f || 1;\n      var tmp = data||'';\n      data = SEA.opt.unpack(data) || data;\n      var json = await S.parse(data), pub = pair.pub || pair, key = await SEA.opt.slow_leak(pub);\n      var hash = (f <= SEA.opt.fallback)? shim.Buffer.from(await shim.subtle.digest({name: 'SHA-256'}, new shim.TextEncoder().encode(await S.parse(json.m)))) : await sha(json.m); // this line is old bad buggy code but necessary for old compatibility.\n      var buf; var sig; var check; try{\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64') // NEW DEFAULT!\n        sig = new Uint8Array(buf)\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash))\n        if(!check){ throw \"Signature did not match.\" }\n      }catch(e){ try{\n        buf = shim.Buffer.from(json.s, 'utf8') // AUTO BACKWARD OLD UTF8 DATA!\n        sig = new Uint8Array(buf)\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash))\n        }catch(e){\n        if(!check){ throw \"Signature did not match.\" }\n        }\n      }\n      var r = check? await S.parse(json.m) : u;\n      O.fall_soul = tmp['#']; O.fall_key = tmp['.']; O.fall_val = data; O.fall_state = tmp['>'];\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    }\n    SEA.opt.fallback = 2;\n\n  })(USE, './verify');\n\n  ;USE(function(module){\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha256hash = USE('./sha256');\n\n    const importGen = async (key, salt, opt) => {\n      //const combo = shim.Buffer.concat([shim.Buffer.from(key, 'utf8'), salt || shim.random(8)]).toString('utf8') // old\n      opt = opt || {};\n      const combo = key + (salt || shim.random(8)).toString('utf8'); // new\n      const hash = shim.Buffer.from(await sha256hash(combo), 'binary')\n      \n      const jwkKey = S.keyToJwk(hash)      \n      return await shim.subtle.importKey('jwk', jwkKey, {name:'AES-GCM'}, false, ['encrypt', 'decrypt'])\n    }\n    module.exports = importGen;\n  })(USE, './aeskey');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var aeskey = USE('./aeskey');\n    var u;\n\n    SEA.encrypt = SEA.encrypt || (async (data, pair, cb, opt) => { try {\n      opt = opt || {};\n      var key = (pair||opt).epriv || pair;\n      if(u === data){ throw '`undefined` not allowed.' }\n      if(!key){\n        if(!SEA.I){ throw 'No encryption key.' }\n        pair = await SEA.I(null, {what: data, how: 'encrypt', why: opt.why});\n        key = pair.epriv || pair;\n      }\n      var msg = (typeof data == 'string')? data : await shim.stringify(data);\n      var rand = {s: shim.random(9), iv: shim.random(15)}; // consider making this 9 and 15 or 18 or 12 to reduce == padding.\n      var ct = await aeskey(key, rand.s, opt).then((aes) => (/*shim.ossl ||*/ shim.subtle).encrypt({ // Keeping the AES key scope as private as possible...\n        name: opt.name || 'AES-GCM', iv: new Uint8Array(rand.iv)\n      }, aes, new shim.TextEncoder().encode(msg)));\n      var r = {\n        ct: shim.Buffer.from(ct, 'binary').toString(opt.encode || 'base64'),\n        iv: rand.iv.toString(opt.encode || 'base64'),\n        s: rand.s.toString(opt.encode || 'base64')\n      }\n      if(!opt.raw){ r = 'SEA' + await shim.stringify(r) }\n\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) { \n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.encrypt;\n  })(USE, './encrypt');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var aeskey = USE('./aeskey');\n\n    SEA.decrypt = SEA.decrypt || (async (data, pair, cb, opt) => { try {\n      opt = opt || {};\n      var key = (pair||opt).epriv || pair;\n      if(!key){\n        if(!SEA.I){ throw 'No decryption key.' }\n        pair = await SEA.I(null, {what: data, how: 'decrypt', why: opt.why});\n        key = pair.epriv || pair;\n      }\n      var json = await S.parse(data);\n      var buf, bufiv, bufct; try{\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64');\n        bufiv = shim.Buffer.from(json.iv, opt.encode || 'base64');\n        bufct = shim.Buffer.from(json.ct, opt.encode || 'base64');\n        var ct = await aeskey(key, buf, opt).then((aes) => (/*shim.ossl ||*/ shim.subtle).decrypt({  // Keeping aesKey scope as private as possible...\n          name: opt.name || 'AES-GCM', iv: new Uint8Array(bufiv), tagLength: 128\n        }, aes, new Uint8Array(bufct)));\n      }catch(e){\n        if('utf8' === opt.encode){ throw \"Could not decrypt\" }\n        if(SEA.opt.fallback){\n          opt.encode = 'utf8';\n          return await SEA.decrypt(data, pair, cb, opt);\n        }\n      }\n      var r = await S.parse(new shim.TextDecoder('utf8').decode(ct));\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) { \n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.decrypt;\n  })(USE, './decrypt');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    // Derive shared secret from other's pub and my epub/epriv \n    SEA.secret = SEA.secret || (async (key, pair, cb, opt) => { try {\n      opt = opt || {};\n      if(!pair || !pair.epriv || !pair.epub){\n        if(!SEA.I){ throw 'No secret mix.' }\n        pair = await SEA.I(null, {what: key, how: 'secret', why: opt.why});\n      }\n      var pub = key.epub || key;\n      var epub = pair.epub;\n      var epriv = pair.epriv;\n      var ecdhSubtle = shim.ossl || shim.subtle;\n      var pubKeyData = keysToEcdhJwk(pub);\n      var props = Object.assign({ public: await ecdhSubtle.importKey(...pubKeyData, true, []) },{name: 'ECDH', namedCurve: 'P-256'}); // Thanks to @sirpy !\n      var privKeyData = keysToEcdhJwk(epub, epriv);\n      var derived = await ecdhSubtle.importKey(...privKeyData, false, ['deriveBits']).then(async (privKey) => {\n        // privateKey scope doesn't leak out from here!\n        var derivedBits = await ecdhSubtle.deriveBits(props, privKey, 256);\n        var rawBits = new Uint8Array(derivedBits);\n        var derivedKey = await ecdhSubtle.importKey('raw', rawBits,{ name: 'AES-GCM', length: 256 }, true, [ 'encrypt', 'decrypt' ]);\n        return ecdhSubtle.exportKey('jwk', derivedKey).then(({ k }) => k);\n      })\n      var r = derived;\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    // can this be replaced with settings.jwk?\n    var keysToEcdhJwk = (pub, d) => { // d === priv\n      //var [ x, y ] = shim.Buffer.from(pub, 'base64').toString('utf8').split(':') // old\n      var [ x, y ] = pub.split('.') // new\n      var jwk = d ? { d: d } : {}\n      return [  // Use with spread returned value...\n        'jwk',\n        Object.assign(\n          jwk,\n          { x: x, y: y, kty: 'EC', crv: 'P-256', ext: true }\n        ), // ??? refactor\n        {name: 'ECDH', namedCurve: 'P-256'}\n      ]\n    }\n\n    module.exports = SEA.secret;\n  })(USE, './secret');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    // This is to certify that a group of \"certificants\" can \"put\" anything at a group of matched \"paths\" to the certificate authority's graph\n    SEA.certify = SEA.certify || (async (certificants, policy = {}, authority, cb, opt = {}) => { try {\n      /*\n      The Certify Protocol was made out of love by a Vietnamese code enthusiast. Vietnamese people around the world deserve respect!\n      IMPORTANT: A Certificate is like a Signature. No one knows who (authority) created/signed a cert until you put it into their graph.\n      \"certificants\": '*' or a String (Bob.pub) || an Object that contains \"pub\" as a key || an array of [object || string]. These people will have the rights.\n      \"policy\": A string ('inbox'), or a RAD/LEX object {'*': 'inbox'}, or an Array of RAD/LEX objects or strings. RAD/LEX object can contain key \"?\" with indexOf(\"*\") > -1 to force key equals certificant pub. This rule is used to check against soul+'/'+key using Gun.text.match or String.match.\n      \"authority\": Key pair or priv of the certificate authority.\n      \"cb\": A callback function after all things are done.\n      \"opt\": If opt.expiry (a timestamp) is set, SEA won't sync data after opt.expiry. If opt.block is set, SEA will look for block before syncing.\n      */\n      console.log('SEA.certify() is an early experimental community supported method that may change API behavior without warning in any future version.')\n\n      certificants = (() => {\n        var data = []\n        if (certificants) {\n          if ((typeof certificants === 'string' || Array.isArray(certificants)) && certificants.indexOf('*') > -1) return '*'\n          if (typeof certificants === 'string') return certificants\n          if (Array.isArray(certificants)) {\n            if (certificants.length === 1 && certificants[0]) return typeof certificants[0] === 'object' && certificants[0].pub ? certificants[0].pub : typeof certificants[0] === 'string' ? certificants[0] : null\n            certificants.map(certificant => {\n              if (typeof certificant ==='string') data.push(certificant)\n              else if (typeof certificant === 'object' && certificant.pub) data.push(certificant.pub)\n            })\n          }\n\n          if (typeof certificants === 'object' && certificants.pub) return certificants.pub\n          return data.length > 0 ? data : null\n        }\n        return\n      })()\n\n      if (!certificants) return console.log(\"No certificant found.\")\n\n      const expiry = opt.expiry && (typeof opt.expiry === 'number' || typeof opt.expiry === 'string') ? parseFloat(opt.expiry) : null\n      const readPolicy = (policy || {}).read ? policy.read : null\n      const writePolicy = (policy || {}).write ? policy.write : typeof policy === 'string' || Array.isArray(policy) || policy[\"+\"] || policy[\"#\"] || policy[\".\"] || policy[\"=\"] || policy[\"*\"] || policy[\">\"] || policy[\"<\"] ? policy : null\n      // The \"blacklist\" feature is now renamed to \"block\". Why ? BECAUSE BLACK LIVES MATTER!\n      // We can now use 3 keys: block, blacklist, ban\n      const block = (opt || {}).block || (opt || {}).blacklist || (opt || {}).ban || {}\n      const readBlock = block.read && (typeof block.read === 'string' || (block.read || {})['#']) ? block.read : null\n      const writeBlock = typeof block === 'string' ? block : block.write && (typeof block.write === 'string' || block.write['#']) ? block.write : null\n\n      if (!readPolicy && !writePolicy) return console.log(\"No policy found.\")\n\n      // reserved keys: c, e, r, w, rb, wb\n      const data = JSON.stringify({\n        c: certificants,\n        ...(expiry ? {e: expiry} : {}), // inject expiry if possible\n        ...(readPolicy ? {r: readPolicy }  : {}), // \"r\" stands for read, which means read permission.\n        ...(writePolicy ? {w: writePolicy} : {}), // \"w\" stands for write, which means write permission.\n        ...(readBlock ? {rb: readBlock} : {}), // inject READ block if possible\n        ...(writeBlock ? {wb: writeBlock} : {}), // inject WRITE block if possible\n      })\n\n      const certificate = await SEA.sign(data, authority, null, {raw:1})\n\n      var r = certificate\n      if(!opt.raw){ r = 'SEA'+JSON.stringify(r) }\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.certify;\n  })(USE, './certify');\n\n  ;USE(function(module){\n    var shim = USE('./shim');\n    // Practical examples about usage found in tests.\n    var SEA = USE('./root');\n    SEA.work = USE('./work');\n    SEA.sign = USE('./sign');\n    SEA.verify = USE('./verify');\n    SEA.encrypt = USE('./encrypt');\n    SEA.decrypt = USE('./decrypt');\n    SEA.certify = USE('./certify');\n    //SEA.opt.aeskey = USE('./aeskey'); // not official! // this causes problems in latest WebCrypto.\n\n    SEA.random = SEA.random || shim.random;\n\n    // This is Buffer used in SEA and usable from Gun/SEA application also.\n    // For documentation see https://nodejs.org/api/buffer.html\n    SEA.Buffer = SEA.Buffer || USE('./buffer');\n\n    // These SEA functions support now ony Promises or\n    // async/await (compatible) code, use those like Promises.\n    //\n    // Creates a wrapper library around Web Crypto API\n    // for various AES, ECDSA, PBKDF2 functions we called above.\n    // Calculate public key KeyID aka PGPv4 (result: 8 bytes as hex string)\n    SEA.keyid = SEA.keyid || (async (pub) => {\n      try {\n        // base64('base64(x):base64(y)') => shim.Buffer(xy)\n        const pb = shim.Buffer.concat(\n          pub.replace(/-/g, '+').replace(/_/g, '/').split('.')\n          .map((t) => shim.Buffer.from(t, 'base64'))\n        )\n        // id is PGPv4 compliant raw key\n        const id = shim.Buffer.concat([\n          shim.Buffer.from([0x99, pb.length / 0x100, pb.length % 0x100]), pb\n        ])\n        const sha1 = await sha1hash(id)\n        const hash = shim.Buffer.from(sha1, 'binary')\n        return hash.toString('hex', hash.length - 8)  // 16-bit ID as hex\n      } catch (e) {\n        console.log(e)\n        throw e\n      }\n    });\n    // all done!\n    // Obviously it is missing MANY necessary features. This is only an alpha release.\n    // Please experiment with it, audit what I've done so far, and complain about what needs to be added.\n    // SEA should be a full suite that is easy and seamless to use.\n    // Again, scroll naer the top, where I provide an EXAMPLE of how to create a user and sign in.\n    // Once logged in, the rest of the code you just read handled automatically signing/validating data.\n    // But all other behavior needs to be equally easy, like opinionated ways of\n    // Adding friends (trusted public keys), sending private messages, etc.\n    // Cheers! Tell me what you think.\n    ((SEA.window||{}).GUN||{}).SEA = SEA;\n\n    module.exports = SEA\n    // -------------- END SEA MODULES --------------------\n    // -- BEGIN SEA+GUN MODULES: BUNDLED BY DEFAULT UNTIL OTHERS USE SEA ON OWN -------\n  })(USE, './sea');\n\n  ;USE(function(module){\n    var SEA = USE('./sea'), Gun, u;\n    if(SEA.window){\n      Gun = SEA.window.GUN || {chain:{}};\n    } else {\n      Gun = USE((u+'' == typeof MODULE?'.':'')+'./gun', 1);\n    }\n    SEA.GUN = Gun;\n\n    function User(root){ \n      this._ = {$: this};\n    }\n    User.prototype = (function(){ function F(){}; F.prototype = Gun.chain; return new F() }()) // Object.create polyfill\n    User.prototype.constructor = User;\n\n    // let's extend the gun chain with a `user` function.\n    // only one user can be logged in at a time, per gun instance.\n    Gun.chain.user = function(pub){\n      var gun = this, root = gun.back(-1), user;\n      if(pub){\n        pub = SEA.opt.pub((pub._||'')['#']) || pub;\n        return root.get('~'+pub);\n      }\n      if(user = root.back('user')){ return user }\n      var root = (root._), at = root, uuid = at.opt.uuid || lex;\n      (at = (user = at.user = gun.chain(new User))._).opt = {};\n      at.opt.uuid = function(cb){\n        var id = uuid(), pub = root.user;\n        if(!pub || !(pub = pub.is) || !(pub = pub.pub)){ return id }\n        id = '~' + pub + '/' + id;\n        if(cb && cb.call){ cb(null, id) }\n        return id;\n      }\n      return user;\n    }\n    function lex(){ return Gun.state().toString(36).replace('.','') }\n    Gun.User = User;\n    User.GUN = Gun;\n    User.SEA = Gun.SEA = SEA;\n    module.exports = User;\n  })(USE, './user');\n\n  ;USE(function(module){\n    var u, Gun = (''+u != typeof GUN)? (GUN||{chain:{}}) : USE((''+u === typeof MODULE?'.':'')+'./gun', 1);\n    Gun.chain.then = function(cb, opt){\n      var gun = this, p = (new Promise(function(res, rej){\n        gun.once(res, opt);\n      }));\n      return cb? p.then(cb) : p;\n    }\n  })(USE, './then');\n\n  ;USE(function(module){\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\n\n    // Well first we have to actually create a user. That is what this function does.\n    User.prototype.create = function(...args){\n      var pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\n      var alias = pair && (pair.pub || pair.epub) ? pair.pub : typeof args[0] === 'string' ? args[0] : null;\n      var pass = pair && (pair.pub || pair.epub) ? pair : alias && typeof args[1] === 'string' ? args[1] : null;\n      var cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\n      var opt = args && args.length > 1 && typeof args[args.length-1] === 'object' ? args[args.length-1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\n      \n      var gun = this, cat = (gun._), root = gun.back(-1);\n      cb = cb || noop;\n      opt = opt || {};\n      if(false !== opt.check){\n        var err;\n        if(!alias){ err = \"No user.\" }\n        if((pass||'').length < 8){ err = \"Password too short!\" }\n        if(err){\n          cb({err: Gun.log(err)});\n          return gun;\n        }\n      }\n      if(cat.ing){\n        (cb || noop)({err: Gun.log(\"User is already being created or authenticated!\"), wait: true});\n        return gun;\n      }\n      cat.ing = true;\n      var act = {}, u;\n      act.a = function(pubs){\n        act.pubs = pubs;\n        if(pubs && !opt.already){\n          // If we can enforce that a user name is already taken, it might be nice to try, but this is not guaranteed.\n          var ack = {err: Gun.log('User already created!')};\n          cat.ing = false;\n          (cb || noop)(ack);\n          gun.leave();\n          return;\n        }\n        act.salt = String.random(64); // pseudo-randomly create a salt, then use PBKDF2 function to extend the password with it.\n        SEA.work(pass, act.salt, act.b); // this will take some short amount of time to produce a proof, which slows brute force attacks.\n      }\n      act.b = function(proof){\n        act.proof = proof;\n        pair ? act.c(pair) : SEA.pair(act.c) // generate a brand new key pair or use the existing.\n      }\n      act.c = function(pair){\n        var tmp\n        act.pair = pair || {};\n        if(tmp = cat.root.user){\n          tmp._.sea = pair;\n          tmp.is = {pub: pair.pub, epub: pair.epub, alias: alias};\n        }\n        // the user's public key doesn't need to be signed. But everything else needs to be signed with it! // we have now automated it! clean up these extra steps now!\n        act.data = {pub: pair.pub};\n        act.d();\n      }\n      act.d = function(){\n        act.data.alias = alias;\n        act.e();\n      }\n      act.e = function(){\n        act.data.epub = act.pair.epub; \n        SEA.encrypt({priv: act.pair.priv, epriv: act.pair.epriv}, act.proof, act.f, {raw:1}); // to keep the private key safe, we AES encrypt it with the proof of work!\n      }\n      act.f = function(auth){\n        act.data.auth = JSON.stringify({ek: auth, s: act.salt}); \n        act.g(act.data.auth);\n      }\n      act.g = function(auth){ var tmp;\n        act.data.auth = act.data.auth || auth;\n        root.get(tmp = '~'+act.pair.pub).put(act.data).on(act.h); // awesome, now we can actually save the user with their public key as their ID.\n        var link = {}; link[tmp] = {'#': tmp}; root.get('~@'+alias).put(link).get(tmp).on(act.i); // next up, we want to associate the alias with the public key. So we add it to the alias list.\n      }\n      act.h = function(data, key, msg, eve){\n        eve.off(); act.h.ok = 1; act.i();\n      }\n      act.i = function(data, key, msg, eve){\n        if(eve){ act.i.ok = 1; eve.off() }\n        if(!act.h.ok || !act.i.ok){ return }\n        cat.ing = false;\n        cb({ok: 0, pub: act.pair.pub}); // callback that the user has been created. (Note: ok = 0 because we didn't wait for disk to ack)\n        if(noop === cb){ pair ? gun.auth(pair) : gun.auth(alias, pass) } // if no callback is passed, auto-login after signing up.\n      }\n      root.get('~@'+alias).once(act.a);\n      return gun;\n    }\n    User.prototype.leave = function(opt, cb){\n      var gun = this, user = (gun.back(-1)._).user;\n      if(user){\n        delete user.is;\n        delete user._.is;\n        delete user._.sea;\n      }\n      if(SEA.window){\n        try{var sS = {};\n        sS = SEA.window.sessionStorage;\n        delete sS.recall;\n        delete sS.pair;\n        }catch(e){};\n      }\n      return gun;\n    }\n  })(USE, './create');\n\n  ;USE(function(module){\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\n    // now that we have created a user, we want to authenticate them!\n    User.prototype.auth = function(...args){ // TODO: this PR with arguments need to be cleaned up / refactored.\n      var pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\n      var alias = !pair && typeof args[0] === 'string' ? args[0] : null;\n      var pass = (alias || (pair && !(pair.priv && pair.epriv))) && typeof args[1] === 'string' ? args[1] : null;\n      var cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\n      var opt = args && args.length > 1 && typeof args[args.length-1] === 'object' ? args[args.length-1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\n      \n      var gun = this, cat = (gun._), root = gun.back(-1);\n      \n      if(cat.ing){\n        (cb || noop)({err: Gun.log(\"User is already being created or authenticated!\"), wait: true});\n        return gun;\n      }\n      cat.ing = true;\n      \n      var act = {}, u, tries = 9;\n      act.a = function(data){\n        if(!data){ return act.b() }\n        if(!data.pub){\n          var tmp = []; Object.keys(data).forEach(function(k){ if('_'==k){ return } tmp.push(data[k]) })\n          return act.b(tmp);\n        }\n        if(act.name){ return act.f(data) }\n        act.c((act.data = data).auth);\n      }\n      act.b = function(list){\n        var get = (act.list = (act.list||[]).concat(list||[])).shift();\n        if(u === get){\n          if(act.name){ return act.err('Your user account is not published for dApps to access, please consider syncing it online, or allowing local access by adding your device as a peer.') }\n          if(alias && tries--){\n            root.get('~@'+alias).once(act.a);\n            return;\n          }\n          return act.err('Wrong user or password.') \n        }\n        root.get(get).once(act.a);\n      }\n      act.c = function(auth){\n        if(u === auth){ return act.b() }\n        if('string' == typeof auth){ return act.c(obj_ify(auth)) } // in case of legacy\n        SEA.work(pass, (act.auth = auth).s, act.d, act.enc); // the proof of work is evidence that we've spent some time/effort trying to log in, this slows brute force.\n      }\n      act.d = function(proof){\n        SEA.decrypt(act.auth.ek, proof, act.e, act.enc);\n      }\n      act.e = function(half){\n        if(u === half){\n          if(!act.enc){ // try old format\n            act.enc = {encode: 'utf8'};\n            return act.c(act.auth);\n          } act.enc = null; // end backwards\n          return act.b();\n        }\n        act.half = half;\n        act.f(act.data);\n      }\n      act.f = function(pair){\n        var half = act.half || {}, data = act.data || {};\n        act.g(act.lol = {pub: pair.pub || data.pub, epub: pair.epub || data.epub, priv: pair.priv || half.priv, epriv: pair.epriv || half.epriv});\n      }\n      act.g = function(pair){\n        if(!pair || !pair.pub || !pair.epub){ return act.b() }\n        act.pair = pair;\n        var user = (root._).user, at = (user._);\n        var tmp = at.tag;\n        var upt = at.opt;\n        at = user._ = root.get('~'+pair.pub)._;\n        at.opt = upt;\n        // add our credentials in-memory only to our root user instance\n        user.is = {pub: pair.pub, epub: pair.epub, alias: alias || pair.pub};\n        at.sea = act.pair;\n        cat.ing = false;\n        try{if(pass && u == (obj_ify(cat.root.graph['~'+pair.pub].auth)||'')[':']){ opt.shuffle = opt.change = pass; } }catch(e){} // migrate UTF8 & Shuffle!\n        opt.change? act.z() : (cb || noop)(at);\n        if(SEA.window && ((gun.back('user')._).opt||opt).remember){\n          // TODO: this needs to be modular.\n          try{var sS = {};\n          sS = SEA.window.sessionStorage; // TODO: FIX BUG putting on `.is`!\n          sS.recall = true;\n          sS.pair = JSON.stringify(pair); // auth using pair is more reliable than alias/pass\n          }catch(e){}\n        }\n        try{\n          if(root._.tag.auth){ // auth handle might not be registered yet\n          (root._).on('auth', at) // TODO: Deprecate this, emit on user instead! Update docs when you do.\n          } else { setTimeout(function(){ (root._).on('auth', at) },1) } // if not, hackily add a timeout.\n          //at.on('auth', at) // Arrgh, this doesn't work without event \"merge\" code, but \"merge\" code causes stack overflow and crashes after logging in & trying to write data.\n        }catch(e){\n          Gun.log(\"Your 'auth' callback crashed with:\", e);\n        }\n      }\n      act.h = function(data){\n        if(!data){ return act.b() }\n        alias = data.alias\n        if(!alias)\n          alias = data.alias = \"~\" + pair.pub        \n        if(!data.auth){\n          return act.g(pair);\n        }\n        pair = null;\n        act.c((act.data = data).auth);\n      }\n      act.z = function(){\n        // password update so encrypt private key using new pwd + salt\n        act.salt = String.random(64); // pseudo-random\n        SEA.work(opt.change, act.salt, act.y);\n      }\n      act.y = function(proof){\n        SEA.encrypt({priv: act.pair.priv, epriv: act.pair.epriv}, proof, act.x, {raw:1});\n      }\n      act.x = function(auth){\n        act.w(JSON.stringify({ek: auth, s: act.salt}));\n      }\n      act.w = function(auth){\n        if(opt.shuffle){ // delete in future!\n          console.log('migrate core account from UTF8 & shuffle');\n          var tmp = {}; Object.keys(act.data).forEach(function(k){ tmp[k] = act.data[k] });\n          delete tmp._;\n          tmp.auth = auth;\n          root.get('~'+act.pair.pub).put(tmp);\n        } // end delete\n        root.get('~'+act.pair.pub).get('auth').put(auth, cb || noop);\n      }\n      act.err = function(e){\n        var ack = {err: Gun.log(e || 'User cannot be found!')};\n        cat.ing = false;\n        (cb || noop)(ack);\n      }\n      act.plugin = function(name){\n        if(!(act.name = name)){ return act.err() }\n        var tmp = [name];\n        if('~' !== name[0]){\n          tmp[1] = '~'+name;\n          tmp[2] = '~@'+name;\n        }\n        act.b(tmp);\n      }\n      if(pair){\n        if(pair.priv && pair.epriv)\n          act.g(pair);\n        else\n          root.get('~'+pair.pub).once(act.h);\n      } else\n      if(alias){\n        root.get('~@'+alias).once(act.a);\n      } else\n      if(!alias && !pass){\n        SEA.name(act.plugin);\n      }\n      return gun;\n    }\n    function obj_ify(o){\n      if('string' != typeof o){ return o }\n      try{o = JSON.parse(o);\n      }catch(e){o={}};\n      return o;\n    }\n  })(USE, './auth');\n\n  ;USE(function(module){\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN;\n    User.prototype.recall = function(opt, cb){\n      var gun = this, root = gun.back(-1), tmp;\n      opt = opt || {};\n      if(opt && opt.sessionStorage){\n        if(SEA.window){\n          try{\n            var sS = {};\n            sS = SEA.window.sessionStorage; // TODO: FIX BUG putting on `.is`!\n            if(sS){\n              (root._).opt.remember = true;\n              ((gun.back('user')._).opt||opt).remember = true;\n              if(sS.recall || sS.pair) root.user().auth(JSON.parse(sS.pair), cb); // pair is more reliable than alias/pass\n            }\n          }catch(e){}\n        }\n        return gun;\n      }\n      /*\n        TODO: copy mhelander's expiry code back in.\n        Although, we should check with community,\n        should expiry be core or a plugin?\n      */\n      return gun;\n    }\n  })(USE, './recall');\n\n  ;USE(function(module){\n    var User = USE('./user'), SEA = User.SEA, Gun = User.GUN, noop = function(){};\n    User.prototype.pair = function(){\n      var user = this, proxy; // undeprecated, hiding with proxies.\n      try{ proxy = new Proxy({DANGER:'\\u2620'}, {get: function(t,p,r){\n        if(!user.is || !(user._||'').sea){ return }\n        return user._.sea[p];\n      }})}catch(e){}\n      return proxy;\n    }\n    // If authenticated user wants to delete his/her account, let's support it!\n    User.prototype.delete = async function(alias, pass, cb){\n      console.log(\"user.delete() IS DEPRECATED AND WILL BE MOVED TO A MODULE!!!\");\n      var gun = this, root = gun.back(-1), user = gun.back('user');\n      try {\n        user.auth(alias, pass, function(ack){\n          var pub = (user.is||{}).pub;\n          // Delete user data\n          user.map().once(function(){ this.put(null) });\n          // Wipe user data from memory\n          user.leave();\n          (cb || noop)({ok: 0});\n        });\n      } catch (e) {\n        Gun.log('User.delete failed! Error:', e);\n      }\n      return gun;\n    }\n    User.prototype.alive = async function(){\n      console.log(\"user.alive() IS DEPRECATED!!!\");\n      const gunRoot = this.back(-1)\n      try {\n        // All is good. Should we do something more with actual recalled data?\n        await authRecall(gunRoot)\n        return gunRoot._.user._\n      } catch (e) {\n        const err = 'No session!'\n        Gun.log(err)\n        throw { err }\n      }\n    }\n    User.prototype.trust = async function(user){\n      console.log(\"`.trust` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      // TODO: BUG!!! SEA `node` read listener needs to be async, which means core needs to be async too.\n      //gun.get('alice').get('age').trust(bob);\n      if (Gun.is(user)) {\n        user.get('pub').get((ctx, ev) => {\n          console.log(ctx, ev)\n        })\n      }\n      user.get('trust').get(path).put(theirPubkey);\n\n      // do a lookup on this gun chain directly (that gets bob's copy of the data)\n      // do a lookup on the metadata trust table for this path (that gets all the pubkeys allowed to write on this path)\n      // do a lookup on each of those pubKeys ON the path (to get the collab data \"layers\")\n      // THEN you perform Jachen's mix operation\n      // and return the result of that to...\n    }\n    User.prototype.grant = function(to, cb){\n      console.log(\"`.grant` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      var gun = this, user = gun.back(-1).user(), pair = user._.sea, path = '';\n      gun.back(function(at){ if(at.is){ return } path += (at.get||'') });\n      (async function(){\n      var enc, sec = await user.get('grant').get(pair.pub).get(path).then();\n      sec = await SEA.decrypt(sec, pair);\n      if(!sec){\n        sec = SEA.random(16).toString();\n        enc = await SEA.encrypt(sec, pair);\n        user.get('grant').get(pair.pub).get(path).put(enc);\n      }\n      var pub = to.get('pub').then();\n      var epub = to.get('epub').then();\n      pub = await pub; epub = await epub;\n      var dh = await SEA.secret(epub, pair);\n      enc = await SEA.encrypt(sec, dh);\n      user.get('grant').get(pub).get(path).put(enc, cb);\n      }());\n      return gun;\n    }\n    User.prototype.secret = function(data, cb){\n      console.log(\"`.secret` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      var gun = this, user = gun.back(-1).user(), pair = user.pair(), path = '';\n      gun.back(function(at){ if(at.is){ return } path += (at.get||'') });\n      (async function(){\n      var enc, sec = await user.get('trust').get(pair.pub).get(path).then();\n      sec = await SEA.decrypt(sec, pair);\n      if(!sec){\n        sec = SEA.random(16).toString();\n        enc = await SEA.encrypt(sec, pair);\n        user.get('trust').get(pair.pub).get(path).put(enc);\n      }\n      enc = await SEA.encrypt(data, sec);\n      gun.put(enc, cb);\n      }());\n      return gun;\n    }\n\n    /**\n     * returns the decrypted value, encrypted by secret\n     * @returns {Promise<any>}\n     // Mark needs to review 1st before officially supported\n    User.prototype.decrypt = function(cb) {\n      let gun = this,\n        path = ''\n      gun.back(function(at) {\n        if (at.is) {\n          return\n        }\n        path += at.get || ''\n      })\n      return gun\n        .then(async data => {\n          if (data == null) {\n            return\n          }\n          const user = gun.back(-1).user()\n          const pair = user.pair()\n          let sec = await user\n            .get('trust')\n            .get(pair.pub)\n            .get(path)\n          sec = await SEA.decrypt(sec, pair)\n          if (!sec) {\n            return data\n          }\n          let decrypted = await SEA.decrypt(data, sec)\n          return decrypted\n        })\n        .then(res => {\n          cb && cb(res)\n          return res\n        })\n    }\n    */\n    module.exports = User\n  })(USE, './share');\n\n  ;USE(function(module){\n    var SEA = USE('./sea'), S = USE('./settings'), noop = function() {}, u;\n    var Gun = (SEA.window||'').GUN || USE((''+u === typeof MODULE?'.':'')+'./gun', 1);\n    // After we have a GUN extension to make user registration/login easy, we then need to handle everything else.\n\n    // We do this with a GUN adapter, we first listen to when a gun instance is created (and when its options change)\n    Gun.on('opt', function(at){\n      if(!at.sea){ // only add SEA once per instance, on the \"at\" context.\n        at.sea = {own: {}};\n        at.on('put', check, at); // SEA now runs its firewall on HAM diffs, not all i/o.\n      }\n      this.to.next(at); // make sure to call the \"next\" middleware adapter.\n    });\n\n    // Alright, this next adapter gets run at the per node level in the graph database.\n    // correction: 2020 it gets run on each key/value pair in a node upon a HAM diff.\n    // This will let us verify that every property on a node has a value signed by a public key we trust.\n    // If the signature does not match, the data is just `undefined` so it doesn't get passed on.\n    // If it does match, then we transform the in-memory \"view\" of the data into its plain value (without the signature).\n    // Now NOTE! Some data is \"system\" data, not user data. Example: List of public keys, aliases, etc.\n    // This data is self-enforced (the value can only match its ID), but that is handled in the `security` function.\n    // From the self-enforced data, we can see all the edges in the graph that belong to a public key.\n    // Example: ~ASDF is the ID of a node with ASDF as its public key, signed alias and salt, and\n    // its encrypted private key, but it might also have other signed values on it like `profile = <ID>` edge.\n    // Using that directed edge's ID, we can then track (in memory) which IDs belong to which keys.\n    // Here is a problem: Multiple public keys can \"claim\" any node's ID, so this is dangerous!\n    // This means we should ONLY trust our \"friends\" (our key ring) public keys, not any ones.\n    // I have not yet added that to SEA yet in this alpha release. That is coming soon, but beware in the meanwhile!\n\n    function check(msg){ // REVISE / IMPROVE, NO NEED TO PASS MSG/EVE EACH SUB?\n      var eve = this, at = eve.as, put = msg.put, soul = put['#'], key = put['.'], val = put[':'], state = put['>'], id = msg['#'], tmp;\n      if(!soul || !key){ return }\n      if((msg._||'').faith && (at.opt||'').faith && 'function' == typeof msg._){\n        SEA.opt.pack(put, function(raw){\n        SEA.verify(raw, false, function(data){ // this is synchronous if false\n          put['='] = SEA.opt.unpack(data);\n          eve.to.next(msg);\n        })})\n        return \n      }\n      var no = function(why){ at.on('in', {'@': id, err: msg.err = why}) }; // exploit internal relay stun for now, maybe violates spec, but testing for now. // Note: this may be only the sharded message, not original batch.\n      //var no = function(why){ msg.ack(why) };\n      (msg._||'').DBG && ((msg._||'').DBG.c = +new Date);\n      if(0 <= soul.indexOf('<?')){ // special case for \"do not sync data X old\" forget\n        // 'a~pub.key/b<?9'\n        tmp = parseFloat(soul.split('<?')[1]||'');\n        if(tmp && (state < (Gun.state() - (tmp * 1000)))){ // sec to ms\n          (tmp = msg._) && (tmp.stun) && (tmp.stun--); // THIS IS BAD CODE! It assumes GUN internals do something that will probably change in future, but hacking in now.\n          return; // omit!\n        }\n      }\n      \n      if('~@' === soul){  // special case for shared system data, the list of aliases.\n        check.alias(eve, msg, val, key, soul, at, no); return;\n      }\n      if('~@' === soul.slice(0,2)){ // special case for shared system data, the list of public keys for an alias.\n        check.pubs(eve, msg, val, key, soul, at, no); return;\n      }\n      //if('~' === soul.slice(0,1) && 2 === (tmp = soul.slice(1)).split('.').length){ // special case, account data for a public key.\n      if(tmp = SEA.opt.pub(soul)){ // special case, account data for a public key.\n        check.pub(eve, msg, val, key, soul, at, no, at.user||'', tmp); return;\n      }\n      if(0 <= soul.indexOf('#')){ // special case for content addressing immutable hashed data.\n        check.hash(eve, msg, val, key, soul, at, no); return;\n      } \n      check.any(eve, msg, val, key, soul, at, no, at.user||''); return;\n      eve.to.next(msg); // not handled\n    }\n    check.hash = function(eve, msg, val, key, soul, at, no){ // mark unbuilt @i001962 's epic hex contrib!\n      SEA.work(val, null, function(data){\n        function hexToBase64(hexStr) {\n          let base64 = \"\";\n          for(let i = 0; i < hexStr.length; i++) {\n            base64 += !(i - 1 & 1) ? String.fromCharCode(parseInt(hexStr.substring(i - 1, i + 1), 16)) : \"\"}\n          return btoa(base64);}  \n        if(data && data === key.split('#').slice(-1)[0]){ return eve.to.next(msg) }\n          else if (data && data === hexToBase64(key.split('#').slice(-1)[0])){ \n          return eve.to.next(msg) }\n        no(\"Data hash not same as hash!\");\n      }, {name: 'SHA-256'});\n    }\n    check.alias = function(eve, msg, val, key, soul, at, no){ // Example: {_:#~@, ~@alice: {#~@alice}}\n      if(!val){ return no(\"Data must exist!\") } // data MUST exist\n      if('~@'+key === link_is(val)){ return eve.to.next(msg) } // in fact, it must be EXACTLY equal to itself\n      no(\"Alias not same!\"); // if it isn't, reject.\n    };\n    check.pubs = function(eve, msg, val, key, soul, at, no){ // Example: {_:#~@alice, ~asdf: {#~asdf}}\n      if(!val){ return no(\"Alias must exist!\") } // data MUST exist\n      if(key === link_is(val)){ return eve.to.next(msg) } // and the ID must be EXACTLY equal to its property\n      no(\"Alias not same!\"); // that way nobody can tamper with the list of public keys.\n    };\n    check.pub = async function(eve, msg, val, key, soul, at, no, user, pub){ var tmp // Example: {_:#~asdf, hello:'world'~fdsa}}\n      const raw = await S.parse(val) || {}\n      const verify = (certificate, certificant, cb) => {\n        if (certificate.m && certificate.s && certificant && pub)\n          // now verify certificate\n          return SEA.verify(certificate, pub, data => { // check if \"pub\" (of the graph owner) really issued this cert\n            if (u !== data && u !== data.e && msg.put['>'] && msg.put['>'] > parseFloat(data.e)) return no(\"Certificate expired.\") // certificate expired\n            // \"data.c\" = a list of certificants/certified users\n            // \"data.w\" = lex WRITE permission, in the future, there will be \"data.r\" which means lex READ permission\n            if (u !== data && data.c && data.w && (data.c === certificant || data.c.indexOf('*' || 0) > -1)) {\n              // ok, now \"certificant\" is in the \"certificants\" list, but is \"path\" allowed? Check path\n              let path = soul.indexOf('/') > -1 ? soul.replace(soul.substring(0, soul.indexOf('/') + 1), '') : ''\n              String.match = String.match || Gun.text.match\n              const w = Array.isArray(data.w) ? data.w : typeof data.w === 'object' || typeof data.w === 'string' ? [data.w] : []\n              for (const lex of w) {\n                if ((String.match(path, lex['#']) && String.match(key, lex['.'])) || (!lex['.'] && String.match(path, lex['#'])) || (!lex['#'] && String.match(key, lex['.'])) || String.match((path ? path + '/' + key : key), lex['#'] || lex)) {\n                  // is Certificant forced to present in Path\n                  if (lex['+'] && lex['+'].indexOf('*') > -1 && path && path.indexOf(certificant) == -1 && key.indexOf(certificant) == -1) return no(`Path \"${path}\" or key \"${key}\" must contain string \"${certificant}\".`)\n                  // path is allowed, but is there any WRITE block? Check it out\n                  if (data.wb && (typeof data.wb === 'string' || ((data.wb || {})['#']))) { // \"data.wb\" = path to the WRITE block\n                    var root = eve.as.root.$.back(-1)\n                    if (typeof data.wb === 'string' && '~' !== data.wb.slice(0, 1)) root = root.get('~' + pub)\n                    return root.get(data.wb).get(certificant).once(value => { // TODO: INTENT TO DEPRECATE.\n                      if (value && (value === 1 || value === true)) return no(`Certificant ${certificant} blocked.`)\n                      return cb(data)\n                    })\n                  }\n                  return cb(data)\n                }\n              }\n              return no(\"Certificate verification fail.\")\n            }\n          })\n        return\n      }\n      \n      if ('pub' === key && '~' + pub === soul) {\n        if (val === pub) return eve.to.next(msg) // the account MUST match `pub` property that equals the ID of the public key.\n        return no(\"Account not same!\")\n      }\n\n      if ((tmp = user.is) && tmp.pub && !raw['*'] && !raw['+'] && (pub === tmp.pub || (pub !== tmp.pub && ((msg._.msg || {}).opt || {}).cert))){\n        SEA.opt.pack(msg.put, packed => {\n          SEA.sign(packed, (user._).sea, async function(data) {\n            if (u === data) return no(SEA.err || 'Signature fail.')\n            msg.put[':'] = {':': tmp = SEA.opt.unpack(data.m), '~': data.s}\n            msg.put['='] = tmp\n  \n            // if writing to own graph, just allow it\n            if (pub === user.is.pub) {\n              if (tmp = link_is(val)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1\n              JSON.stringifyAsync(msg.put[':'], function(err,s){\n                if(err){ return no(err || \"Stringify error.\") }\n                msg.put[':'] = s;\n                return eve.to.next(msg);\n              })\n              return\n            }\n  \n            // if writing to other's graph, check if cert exists then try to inject cert into put, also inject self pub so that everyone can verify the put\n            if (pub !== user.is.pub && ((msg._.msg || {}).opt || {}).cert) {\n              const cert = await S.parse(msg._.msg.opt.cert)\n              // even if cert exists, we must verify it\n              if (cert && cert.m && cert.s)\n                verify(cert, user.is.pub, _ => {\n                  msg.put[':']['+'] = cert // '+' is a certificate\n                  msg.put[':']['*'] = user.is.pub // '*' is pub of the user who puts\n                  JSON.stringifyAsync(msg.put[':'], function(err,s){\n                    if(err){ return no(err || \"Stringify error.\") }\n                    msg.put[':'] = s;\n                    return eve.to.next(msg);\n                  })\n                  return\n                })\n            }\n          }, {raw: 1})\n        })\n        return;\n      }\n\n      SEA.opt.pack(msg.put, packed => {\n        SEA.verify(packed, raw['*'] || pub, function(data){ var tmp;\n          data = SEA.opt.unpack(data);\n          if (u === data) return no(\"Unverified data.\") // make sure the signature matches the account it claims to be on. // reject any updates that are signed with a mismatched account.\n          if ((tmp = link_is(data)) && pub === SEA.opt.pub(tmp)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1\n          \n          // check if cert ('+') and putter's pub ('*') exist\n          if (raw['+'] && raw['+']['m'] && raw['+']['s'] && raw['*'])\n            // now verify certificate\n            verify(raw['+'], raw['*'], _ => {\n              msg.put['='] = data;\n              return eve.to.next(msg);\n            })\n          else {\n            msg.put['='] = data;\n            return eve.to.next(msg);\n          }\n        });\n      })\n      return\n    };\n    check.any = function(eve, msg, val, key, soul, at, no, user){ var tmp, pub;\n      if(at.opt.secure){ return no(\"Soul missing public key at '\" + key + \"'.\") }\n      // TODO: Ask community if should auto-sign non user-graph data.\n      at.on('secure', function(msg){ this.off();\n        if(!at.opt.secure){ return eve.to.next(msg) }\n        no(\"Data cannot be changed.\");\n      }).on.on('secure', msg);\n      return;\n    }\n\n    var valid = Gun.valid, link_is = function(d,l){ return 'string' == typeof (l = valid(d)) && l }, state_ify = (Gun.state||'').ify;\n\n    var pubcut = /[^\\w_-]/; // anything not alphanumeric or _ -\n    SEA.opt.pub = function(s){\n      if(!s){ return }\n      s = s.split('~');\n      if(!s || !(s = s[1])){ return }\n      s = s.split(pubcut).slice(0,2);\n      if(!s || 2 != s.length){ return }\n      if('@' === (s[0]||'')[0]){ return }\n      s = s.slice(0,2).join('.');\n      return s;\n    }\n    SEA.opt.stringy = function(t){\n      // TODO: encrypt etc. need to check string primitive. Make as breaking change.\n    }\n    SEA.opt.pack = function(d,cb,k, n,s){ var tmp, f; // pack for verifying\n      if(SEA.opt.check(d)){ return cb(d) }\n      if(d && d['#'] && d['.'] && d['>']){ tmp = d[':']; f = 1 }\n      JSON.parseAsync(f? tmp : d, function(err, meta){\n        var sig = ((u !== (meta||'')[':']) && (meta||'')['~']); // or just ~ check?\n        if(!sig){ cb(d); return }\n        cb({m: {'#':s||d['#'],'.':k||d['.'],':':(meta||'')[':'],'>':d['>']||Gun.state.is(n, k)}, s: sig});\n      });\n    }\n    var O = SEA.opt;\n    SEA.opt.unpack = function(d, k, n){ var tmp;\n      if(u === d){ return }\n      if(d && (u !== (tmp = d[':']))){ return tmp }\n      k = k || O.fall_key; if(!n && O.fall_val){ n = {}; n[k] = O.fall_val }\n      if(!k || !n){ return }\n      if(d === n[k]){ return d }\n      if(!SEA.opt.check(n[k])){ return d }\n      var soul = (n && n._ && n._['#']) || O.fall_soul, s = Gun.state.is(n, k) || O.fall_state;\n      if(d && 4 === d.length && soul === d[0] && k === d[1] && fl(s) === fl(d[3])){\n        return d[2];\n      }\n      if(s < SEA.opt.shuffle_attack){\n        return d;\n      }\n    }\n    SEA.opt.shuffle_attack = 1546329600000; // Jan 1, 2019\n    var fl = Math.floor; // TODO: Still need to fix inconsistent state issue.\n    // TODO: Potential bug? If pub/priv key starts with `-`? IDK how possible.\n\n  })(USE, './index');\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXNCLFFBQVE7QUFDekQsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyx5QkFBeUI7QUFDekI7O0FBRUEsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIzLWNoYXQvLi9ub2RlX21vZHVsZXMvZ3VuL3NlYS5qcz9mMWM1Il0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24oKXtcblxuICAvKiBVTkJVSUxEICovXG4gIGZ1bmN0aW9uIFVTRShhcmcsIHJlcSl7XG4gICAgcmV0dXJuIHJlcT8gcmVxdWlyZShhcmcpIDogYXJnLnNsaWNlPyBVU0VbUihhcmcpXSA6IGZ1bmN0aW9uKG1vZCwgcGF0aCl7XG4gICAgICBhcmcobW9kID0ge2V4cG9ydHM6IHt9fSk7XG4gICAgICBVU0VbUihwYXRoKV0gPSBtb2QuZXhwb3J0cztcbiAgICB9XG4gICAgZnVuY3Rpb24gUihwKXtcbiAgICAgIHJldHVybiBwLnNwbGl0KCcvJykuc2xpY2UoLTEpLnRvU3RyaW5nKCkucmVwbGFjZSgnLmpzJywnJyk7XG4gICAgfVxuICB9XG4gIGlmKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpeyB2YXIgTU9EVUxFID0gbW9kdWxlIH1cbiAgLyogVU5CVUlMRCAqL1xuXG4gIDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcbiAgICAvLyBTZWN1cml0eSwgRW5jcnlwdGlvbiwgYW5kIEF1dGhvcml6YXRpb246IFNFQS5qc1xuICAgIC8vIE1BTkRBVE9SWSBSRUFESU5HOiBodHRwczovL2d1bi5lY28vZXhwbGFpbmVycy9kYXRhL3NlY3VyaXR5Lmh0bWxcbiAgICAvLyBJVCBJUyBJTVBMRU1FTlRFRCBJTiBBIFBPTFlGSUxML1NISU0gQVBQUk9BQ0guXG4gICAgLy8gVEhJUyBJUyBBTiBFQVJMWSBBTFBIQSFcblxuICAgIGlmKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXsgbW9kdWxlLndpbmRvdyA9IHNlbGYgfSAvLyBzaG91bGQgYmUgc2FmZSBmb3IgYXQgbGVhc3QgYnJvd3Nlci93b3JrZXIvbm9kZWpzLCBuZWVkIHRvIGNoZWNrIG90aGVyIGVudnMgbGlrZSBSTiBldGMuXG4gICAgaWYodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIil7IG1vZHVsZS53aW5kb3cgPSB3aW5kb3cgfVxuXG4gICAgdmFyIHRtcCA9IG1vZHVsZS53aW5kb3cgfHwgbW9kdWxlLCB1O1xuICAgIHZhciBTRUEgPSB0bXAuU0VBIHx8IHt9O1xuXG4gICAgaWYoU0VBLndpbmRvdyA9IG1vZHVsZS53aW5kb3cpeyBTRUEud2luZG93LlNFQSA9IFNFQSB9XG5cbiAgICB0cnl7IGlmKHUrJycgIT09IHR5cGVvZiBNT0RVTEUpeyBNT0RVTEUuZXhwb3J0cyA9IFNFQSB9IH1jYXRjaChlKXt9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTRUE7XG4gIH0pKFVTRSwgJy4vcm9vdCcpO1xuXG4gIDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcbiAgICB2YXIgU0VBID0gVVNFKCcuL3Jvb3QnKTtcbiAgICB0cnl7IGlmKFNFQS53aW5kb3cpe1xuICAgICAgaWYobG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZigncycpIDwgMFxuICAgICAgJiYgbG9jYXRpb24uaG9zdC5pbmRleE9mKCdsb2NhbGhvc3QnKSA8IDBcbiAgICAgICYmICEgL14xMjdcXC5cXGQrXFwuXFxkK1xcLlxcZCskLy50ZXN0KGxvY2F0aW9uLmhvc3RuYW1lKVxuICAgICAgJiYgbG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignZmlsZTonKSA8IDApe1xuICAgICAgICBjb25zb2xlLndhcm4oJ0hUVFBTIG5lZWRlZCBmb3IgV2ViQ3J5cHRvIGluIFNFQSwgcmVkaXJlY3RpbmcuLi4nKTtcbiAgICAgICAgbG9jYXRpb24ucHJvdG9jb2wgPSAnaHR0cHM6JzsgLy8gV2ViQ3J5cHRvIGRvZXMgTk9UIHdvcmsgd2l0aG91dCBIVFRQUyFcbiAgICAgIH1cbiAgICB9IH1jYXRjaChlKXt9XG4gIH0pKFVTRSwgJy4vaHR0cHMnKTtcblxuICA7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG4gICAgdmFyIHU7XG4gICAgaWYodSsnJz09IHR5cGVvZiBidG9hKXtcbiAgICAgIGlmKHUrJycgPT0gdHlwZW9mIEJ1ZmZlcil7XG4gICAgICAgIHRyeXsgZ2xvYmFsLkJ1ZmZlciA9IFVTRShcImJ1ZmZlclwiLCAxKS5CdWZmZXIgfWNhdGNoKGUpeyBjb25zb2xlLmxvZyhcIlBsZWFzZSBgbnBtIGluc3RhbGwgYnVmZmVyYCBvciBhZGQgaXQgdG8geW91ciBwYWNrYWdlLmpzb24gIVwiKSB9XG4gICAgICB9XG4gICAgICBnbG9iYWwuYnRvYSA9IGZ1bmN0aW9uKGRhdGEpeyByZXR1cm4gQnVmZmVyLmZyb20oZGF0YSwgXCJiaW5hcnlcIikudG9TdHJpbmcoXCJiYXNlNjRcIikgfTtcbiAgICAgIGdsb2JhbC5hdG9iID0gZnVuY3Rpb24oZGF0YSl7IHJldHVybiBCdWZmZXIuZnJvbShkYXRhLCBcImJhc2U2NFwiKS50b1N0cmluZyhcImJpbmFyeVwiKSB9O1xuICAgIH1cbiAgfSkoVVNFLCAnLi9iYXNlNjQnKTtcblxuICA7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG4gICAgVVNFKCcuL2Jhc2U2NCcpO1xuICAgIC8vIFRoaXMgaXMgQXJyYXkgZXh0ZW5kZWQgdG8gaGF2ZSAudG9TdHJpbmcoWyd1dGY4J3wnaGV4J3wnYmFzZTY0J10pXG4gICAgZnVuY3Rpb24gU2VhQXJyYXkoKSB7fVxuICAgIE9iamVjdC5hc3NpZ24oU2VhQXJyYXksIHsgZnJvbTogQXJyYXkuZnJvbSB9KVxuICAgIFNlYUFycmF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKVxuICAgIFNlYUFycmF5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuYywgc3RhcnQsIGVuZCkgeyBlbmMgPSBlbmMgfHwgJ3V0ZjgnOyBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgICAgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcylcbiAgICAgICAgcmV0dXJuIFsgLi4uQXJyYXkoKChlbmQgJiYgKGVuZCArIDEpKSB8fCBsZW5ndGgpIC0gc3RhcnQpLmtleXMoKV1cbiAgICAgICAgLm1hcCgoaSkgPT4gYnVmWyBpICsgc3RhcnQgXS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJylcbiAgICAgIH1cbiAgICAgIGlmIChlbmMgPT09ICd1dGY4Jykge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgICAgICB7IGxlbmd0aDogKGVuZCB8fCBsZW5ndGgpIC0gc3RhcnQgfSxcbiAgICAgICAgICAoXywgaSkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzWyBpICsgc3RhcnRdKVxuICAgICAgICApLmpvaW4oJycpXG4gICAgICB9XG4gICAgICBpZiAoZW5jID09PSAnYmFzZTY0Jykge1xuICAgICAgICByZXR1cm4gYnRvYSh0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNlYUFycmF5O1xuICB9KShVU0UsICcuL2FycmF5Jyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIFVTRSgnLi9iYXNlNjQnKTtcbiAgICAvLyBUaGlzIGlzIEJ1ZmZlciBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIFNFQS4gRnVuY3Rpb25hbGl0eSBpcyBtb3N0bHlcbiAgICAvLyBjb21wYXRpYmxlIHdpdGggTm9kZUpTICdzYWZlLWJ1ZmZlcicgYW5kIGlzIHVzZWQgZm9yIGVuY29kaW5nIGNvbnZlcnNpb25zXG4gICAgLy8gYmV0d2VlbiBiaW5hcnkgYW5kICdoZXgnIHwgJ3V0ZjgnIHwgJ2Jhc2U2NCdcbiAgICAvLyBTZWUgZG9jdW1lbnRhdGlvbiBhbmQgdmFsaWRhdGlvbiBmb3Igc2FmZSBpbXBsZW1lbnRhdGlvbiBpbjpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL3NhZmUtYnVmZmVyI3VwZGF0ZVxuICAgIHZhciBTZWFBcnJheSA9IFVTRSgnLi9hcnJheScpO1xuICAgIGZ1bmN0aW9uIFNhZmVCdWZmZXIoLi4ucHJvcHMpIHtcbiAgICAgIGNvbnNvbGUud2FybignbmV3IFNhZmVCdWZmZXIoKSBpcyBkZXByZWNpYXRlZCwgcGxlYXNlIHVzZSBTYWZlQnVmZmVyLmZyb20oKScpXG4gICAgICByZXR1cm4gU2FmZUJ1ZmZlci5mcm9tKC4uLnByb3BzKVxuICAgIH1cbiAgICBTYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5hc3NpZ24oU2FmZUJ1ZmZlciwge1xuICAgICAgLy8gKGRhdGEsIGVuYykgd2hlcmUgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHRoZW4gZW5jID09PSAndXRmOCd8J2hleCd8J2Jhc2U2NCdcbiAgICAgIGZyb20oKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoYXJndW1lbnRzKS5sZW5ndGggfHwgYXJndW1lbnRzWzBdPT1udWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXQgPSBhcmd1bWVudHNbMF1cbiAgICAgICAgbGV0IGJ1ZlxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGVuYyA9IGFyZ3VtZW50c1sxXSB8fCAndXRmOCdcbiAgICAgICAgICBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBpbnB1dC5tYXRjaCgvKFtcXGRhLWZBLUZdezJ9KS9nKVxuICAgICAgICAgICAgLm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKVxuICAgICAgICAgICAgaWYgKCFieXRlcyB8fCAhYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZmlyc3QgYXJndW1lbnQgZm9yIHR5cGUgXFwnaGV4XFwnLicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWYgPSBTZWFBcnJheS5mcm9tKGJ5dGVzKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZW5jID09PSAndXRmOCcgfHwgJ2JpbmFyeScgPT09IGVuYykgeyAvLyBFRElUIEJZIE1BUks6IEkgdGhpbmsgdGhpcyBpcyBzYWZlLCB0ZXN0ZWQgaXQgYWdhaW5zdCBhIGNvdXBsZSBcImJpbmFyeVwiIHN0cmluZ3MuIFRoaXMgbGV0cyBTYWZlQnVmZmVyIG1hdGNoIE5vZGVKUyBCdWZmZXIgYmVoYXZpb3IgbW9yZSB3aGVyZSBpdCBzYWZlbHkgYnRvYXMgcmVndWxhciBzdHJpbmdzLlxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoXG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IG5ldyBVaW50MTZBcnJheShsZW5ndGgpXG4gICAgICAgICAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiBsZW5ndGggfSwgKF8sIGkpID0+IHdvcmRzW2ldID0gaW5wdXQuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGJ1ZiA9IFNlYUFycmF5LmZyb20od29yZHMpXG4gICAgICAgICAgfSBlbHNlIGlmIChlbmMgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICBjb25zdCBkZWMgPSBhdG9iKGlucHV0KVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZGVjLmxlbmd0aFxuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgICAgICAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiBsZW5ndGggfSwgKF8sIGkpID0+IGJ5dGVzW2ldID0gZGVjLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBidWYgPSBTZWFBcnJheS5mcm9tKGJ5dGVzKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZW5jID09PSAnYmluYXJ5JykgeyAvLyBkZXByZWNhdGVkIGJ5IGFib3ZlIGNvbW1lbnRcbiAgICAgICAgICAgIGJ1ZiA9IFNlYUFycmF5LmZyb20oaW5wdXQpIC8vIHNvbWUgYnRvYXMgd2VyZSBtaXNoYW5kbGVkLlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ1NhZmVCdWZmZXIuZnJvbSB1bmtub3duIGVuY29kaW5nOiAnK2VuYylcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ1ZlxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBpbnB1dC5ieXRlTGVuZ3RoIC8vIHdoYXQgaXMgZ29pbmcgb24gaGVyZT8gRk9SIE1BUlRUSVxuICAgICAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5ieXRlTGVuZ3RoID8gaW5wdXQuYnl0ZUxlbmd0aCA6IGlucHV0Lmxlbmd0aFxuICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGJ1ZlxuICAgICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShpbnB1dClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFNlYUFycmF5LmZyb20oYnVmIHx8IGlucHV0KVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVGhpcyBpcyAnc2FmZS1idWZmZXIuYWxsb2MnIHNhbnMgZW5jb2Rpbmcgc3VwcG9ydFxuICAgICAgYWxsb2MobGVuZ3RoLCBmaWxsID0gMCAvKiwgZW5jKi8gKSB7XG4gICAgICAgIHJldHVybiBTZWFBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KEFycmF5LmZyb20oeyBsZW5ndGg6IGxlbmd0aCB9LCAoKSA9PiBmaWxsKSkpXG4gICAgICB9LFxuICAgICAgLy8gVGhpcyBpcyBub3JtYWwgVU5TQUZFICdidWZmZXIuYWxsb2MnIG9yICduZXcgQnVmZmVyKGxlbmd0aCknIC0gZG9uJ3QgdXNlIVxuICAgICAgYWxsb2NVbnNhZmUobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBTZWFBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KEFycmF5LmZyb20oeyBsZW5ndGggOiBsZW5ndGggfSkpKVxuICAgICAgfSxcbiAgICAgIC8vIFRoaXMgcHV0cyB0b2dldGhlciBhcnJheSBvZiBhcnJheSBsaWtlIG1lbWJlcnNcbiAgICAgIGNvbmNhdChhcnIpIHsgLy8gb2N0ZXQgYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIEFycmF5IGNvbnRhaW5pbmcgQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBpbnN0YW5jZXMuJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2VhQXJyYXkuZnJvbShhcnIucmVkdWNlKChyZXQsIGl0ZW0pID0+IHJldC5jb25jYXQoQXJyYXkuZnJvbShpdGVtKSksIFtdKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIFNhZmVCdWZmZXIucHJvdG90eXBlLmZyb20gPSBTYWZlQnVmZmVyLmZyb21cbiAgICBTYWZlQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IFNlYUFycmF5LnByb3RvdHlwZS50b1N0cmluZ1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTYWZlQnVmZmVyO1xuICB9KShVU0UsICcuL2J1ZmZlcicpO1xuXG4gIDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcbiAgICBjb25zdCBTRUEgPSBVU0UoJy4vcm9vdCcpXG4gICAgY29uc3QgYXBpID0ge0J1ZmZlcjogVVNFKCcuL2J1ZmZlcicpfVxuICAgIHZhciBvID0ge30sIHU7XG5cbiAgICAvLyBpZGVhbGx5IHdlIGNhbiBtb3ZlIGF3YXkgZnJvbSBKU09OIGVudGlyZWx5PyB1bmxpa2VseSBkdWUgdG8gY29tcGF0aWJpbGl0eSBpc3N1ZXMuLi4gb2ggd2VsbC5cbiAgICBKU09OLnBhcnNlQXN5bmMgPSBKU09OLnBhcnNlQXN5bmMgfHwgZnVuY3Rpb24odCxjYixyKXsgdmFyIHU7IHRyeXsgY2IodSwgSlNPTi5wYXJzZSh0LHIpKSB9Y2F0Y2goZSl7IGNiKGUpIH0gfVxuICAgIEpTT04uc3RyaW5naWZ5QXN5bmMgPSBKU09OLnN0cmluZ2lmeUFzeW5jIHx8IGZ1bmN0aW9uKHYsY2IscixzKXsgdmFyIHU7IHRyeXsgY2IodSwgSlNPTi5zdHJpbmdpZnkodixyLHMpKSB9Y2F0Y2goZSl7IGNiKGUpIH0gfVxuXG4gICAgYXBpLnBhcnNlID0gZnVuY3Rpb24odCxyKXsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlcywgcmVqKXtcbiAgICAgIEpTT04ucGFyc2VBc3luYyh0LGZ1bmN0aW9uKGVyciwgcmF3KXsgZXJyPyByZWooZXJyKSA6IHJlcyhyYXcpIH0scik7XG4gICAgfSl9XG4gICAgYXBpLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKHYscixzKXsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlcywgcmVqKXtcbiAgICAgIEpTT04uc3RyaW5naWZ5QXN5bmModixmdW5jdGlvbihlcnIsIHJhdyl7IGVycj8gcmVqKGVycikgOiByZXMocmF3KSB9LHIscyk7XG4gICAgfSl9XG5cbiAgICBpZihTRUEud2luZG93KXtcbiAgICAgIGFwaS5jcnlwdG8gPSBTRUEud2luZG93LmNyeXB0byB8fCBTRUEud2luZG93Lm1zQ3J5cHRvXG4gICAgICBhcGkuc3VidGxlID0gKGFwaS5jcnlwdG98fG8pLnN1YnRsZSB8fCAoYXBpLmNyeXB0b3x8bykud2Via2l0U3VidGxlO1xuICAgICAgYXBpLlRleHRFbmNvZGVyID0gU0VBLndpbmRvdy5UZXh0RW5jb2RlcjtcbiAgICAgIGFwaS5UZXh0RGVjb2RlciA9IFNFQS53aW5kb3cuVGV4dERlY29kZXI7XG4gICAgICBhcGkucmFuZG9tID0gKGxlbikgPT4gYXBpLkJ1ZmZlci5mcm9tKGFwaS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGFwaS5CdWZmZXIuYWxsb2MobGVuKSkpKTtcbiAgICB9XG4gICAgaWYoIWFwaS5UZXh0RGVjb2RlcilcbiAgICB7XG4gICAgICBjb25zdCB7IFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9ID0gVVNFKCh1KycnID09IHR5cGVvZiBNT0RVTEU/Jy4nOicnKSsnLi9saWIvdGV4dC1lbmNvZGluZycsIDEpO1xuICAgICAgYXBpLlRleHREZWNvZGVyID0gVGV4dERlY29kZXI7XG4gICAgICBhcGkuVGV4dEVuY29kZXIgPSBUZXh0RW5jb2RlcjtcbiAgICB9XG4gICAgaWYoIWFwaS5jcnlwdG8pXG4gICAge1xuICAgICAgdHJ5XG4gICAgICB7XG4gICAgICB2YXIgY3J5cHRvID0gVVNFKCdjcnlwdG8nLCAxKTtcbiAgICAgIE9iamVjdC5hc3NpZ24oYXBpLCB7XG4gICAgICAgIGNyeXB0byxcbiAgICAgICAgcmFuZG9tOiAobGVuKSA9PiBhcGkuQnVmZmVyLmZyb20oY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbikpXG4gICAgICB9KTsgICAgICBcbiAgICAgIGNvbnN0IHsgQ3J5cHRvOiBXZWJDcnlwdG8gfSA9IFVTRSgnQHBlY3VsaWFyL3dlYmNyeXB0bycsIDEpO1xuICAgICAgYXBpLm9zc2wgPSBhcGkuc3VidGxlID0gbmV3IFdlYkNyeXB0byh7ZGlyZWN0b3J5OiAnb3NzbCd9KS5zdWJ0bGUgLy8gRUNESFxuICAgIH1cbiAgICBjYXRjaChlKXtcbiAgICAgIGNvbnNvbGUubG9nKFwiUGxlYXNlIGBucG0gaW5zdGFsbCBAcGVjdWxpYXIvd2ViY3J5cHRvYCBvciBhZGQgaXQgdG8geW91ciBwYWNrYWdlLmpzb24gIVwiKTtcbiAgICB9fVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhcGlcbiAgfSkoVVNFLCAnLi9zaGltJyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBTRUEgPSBVU0UoJy4vcm9vdCcpO1xuICAgIHZhciBzaGltID0gVVNFKCcuL3NoaW0nKTtcbiAgICB2YXIgcyA9IHt9O1xuICAgIHMucGJrZGYyID0ge2hhc2g6IHtuYW1lIDogJ1NIQS0yNTYnfSwgaXRlcjogMTAwMDAwLCBrczogNjR9O1xuICAgIHMuZWNkc2EgPSB7XG4gICAgICBwYWlyOiB7bmFtZTogJ0VDRFNBJywgbmFtZWRDdXJ2ZTogJ1AtMjU2J30sXG4gICAgICBzaWduOiB7bmFtZTogJ0VDRFNBJywgaGFzaDoge25hbWU6ICdTSEEtMjU2J319XG4gICAgfTtcbiAgICBzLmVjZGggPSB7bmFtZTogJ0VDREgnLCBuYW1lZEN1cnZlOiAnUC0yNTYnfTtcblxuICAgIC8vIFRoaXMgY3JlYXRlcyBXZWIgQ3J5cHRvZ3JhcGh5IEFQSSBjb21wbGlhbnQgSldLIGZvciBzaWduL3ZlcmlmeSBwdXJwb3Nlc1xuICAgIHMuandrID0gZnVuY3Rpb24ocHViLCBkKXsgIC8vIGQgPT09IHByaXZcbiAgICAgIHB1YiA9IHB1Yi5zcGxpdCgnLicpO1xuICAgICAgdmFyIHggPSBwdWJbMF0sIHkgPSBwdWJbMV07XG4gICAgICB2YXIgandrID0ge2t0eTogXCJFQ1wiLCBjcnY6IFwiUC0yNTZcIiwgeDogeCwgeTogeSwgZXh0OiB0cnVlfTtcbiAgICAgIGp3ay5rZXlfb3BzID0gZCA/IFsnc2lnbiddIDogWyd2ZXJpZnknXTtcbiAgICAgIGlmKGQpeyBqd2suZCA9IGQgfVxuICAgICAgcmV0dXJuIGp3aztcbiAgICB9O1xuICAgIFxuICAgIHMua2V5VG9Kd2sgPSBmdW5jdGlvbihrZXlCeXRlcykge1xuICAgICAgY29uc3Qga2V5QjY0ID0ga2V5Qnl0ZXMudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgY29uc3QgayA9IGtleUI2NC5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC9cXD0vZywgJycpO1xuICAgICAgcmV0dXJuIHsga3R5OiAnb2N0JywgazogaywgZXh0OiBmYWxzZSwgYWxnOiAnQTI1NkdDTScgfTtcbiAgICB9XG5cbiAgICBzLnJlY2FsbCA9IHtcbiAgICAgIHZhbGlkaXR5OiAxMiAqIDYwICogNjAsIC8vIGludGVybmFsbHkgaW4gc2Vjb25kcyA6IDEyIGhvdXJzXG4gICAgICBob29rOiBmdW5jdGlvbihwcm9wcyl7IHJldHVybiBwcm9wcyB9IC8vIHsgaWF0LCBleHAsIGFsaWFzLCByZW1lbWJlciB9IC8vIG9yIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiByZXNvbHZlKHByb3BzKVxuICAgIH07XG5cbiAgICBzLmNoZWNrID0gZnVuY3Rpb24odCl7IHJldHVybiAodHlwZW9mIHQgPT0gJ3N0cmluZycpICYmICgnU0VBeycgPT09IHQuc2xpY2UoMCw0KSkgfVxuICAgIHMucGFyc2UgPSBhc3luYyBmdW5jdGlvbiBwKHQpeyB0cnkge1xuICAgICAgdmFyIHllcyA9ICh0eXBlb2YgdCA9PSAnc3RyaW5nJyk7XG4gICAgICBpZih5ZXMgJiYgJ1NFQXsnID09PSB0LnNsaWNlKDAsNCkpeyB0ID0gdC5zbGljZSgzKSB9XG4gICAgICByZXR1cm4geWVzID8gYXdhaXQgc2hpbS5wYXJzZSh0KSA6IHQ7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgU0VBLm9wdCA9IHM7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzXG4gIH0pKFVTRSwgJy4vc2V0dGluZ3MnKTtcblxuICA7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG4gICAgdmFyIHNoaW0gPSBVU0UoJy4vc2hpbScpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmMgZnVuY3Rpb24oZCwgbyl7XG4gICAgICB2YXIgdCA9ICh0eXBlb2YgZCA9PSAnc3RyaW5nJyk/IGQgOiBhd2FpdCBzaGltLnN0cmluZ2lmeShkKTtcbiAgICAgIHZhciBoYXNoID0gYXdhaXQgc2hpbS5zdWJ0bGUuZGlnZXN0KHtuYW1lOiBvfHwnU0hBLTI1Nid9LCBuZXcgc2hpbS5UZXh0RW5jb2RlcigpLmVuY29kZSh0KSk7XG4gICAgICByZXR1cm4gc2hpbS5CdWZmZXIuZnJvbShoYXNoKTtcbiAgICB9XG4gIH0pKFVTRSwgJy4vc2hhMjU2Jyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIC8vIFRoaXMgaW50ZXJuYWwgZnVuYyByZXR1cm5zIFNIQS0xIGhhc2hlZCBkYXRhIGZvciBLZXlJRCBnZW5lcmF0aW9uXG4gICAgY29uc3QgX19zaGltID0gVVNFKCcuL3NoaW0nKVxuICAgIGNvbnN0IHN1YnRsZSA9IF9fc2hpbS5zdWJ0bGVcbiAgICBjb25zdCBvc3NsID0gX19zaGltLm9zc2wgPyBfX3NoaW0ub3NzbCA6IHN1YnRsZVxuICAgIGNvbnN0IHNoYTFoYXNoID0gKGIpID0+IG9zc2wuZGlnZXN0KHtuYW1lOiAnU0hBLTEnfSwgbmV3IEFycmF5QnVmZmVyKGIpKVxuICAgIG1vZHVsZS5leHBvcnRzID0gc2hhMWhhc2hcbiAgfSkoVVNFLCAnLi9zaGExJyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBTRUEgPSBVU0UoJy4vcm9vdCcpO1xuICAgIHZhciBzaGltID0gVVNFKCcuL3NoaW0nKTtcbiAgICB2YXIgUyA9IFVTRSgnLi9zZXR0aW5ncycpO1xuICAgIHZhciBzaGEgPSBVU0UoJy4vc2hhMjU2Jyk7XG4gICAgdmFyIHU7XG5cbiAgICBTRUEud29yayA9IFNFQS53b3JrIHx8IChhc3luYyAoZGF0YSwgcGFpciwgY2IsIG9wdCkgPT4geyB0cnkgeyAvLyB1c2VkIHRvIGJlIG5hbWVkIGBwcm9vZmBcbiAgICAgIHZhciBzYWx0ID0gKHBhaXJ8fHt9KS5lcHViIHx8IHBhaXI7IC8vIGVwdWIgbm90IHJlY29tbWVuZGVkLCBzYWx0IHNob3VsZCBiZSByYW5kb20hXG4gICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICBpZihzYWx0IGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgICBjYiA9IHNhbHQ7XG4gICAgICAgIHNhbHQgPSB1O1xuICAgICAgfVxuICAgICAgZGF0YSA9ICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyk/IGRhdGEgOiBhd2FpdCBzaGltLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgIGlmKCdzaGEnID09PSAob3B0Lm5hbWV8fCcnKS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsMykpe1xuICAgICAgICB2YXIgcnNoYSA9IHNoaW0uQnVmZmVyLmZyb20oYXdhaXQgc2hhKGRhdGEsIG9wdC5uYW1lKSwgJ2JpbmFyeScpLnRvU3RyaW5nKG9wdC5lbmNvZGUgfHwgJ2Jhc2U2NCcpXG4gICAgICAgIGlmKGNiKXsgdHJ5eyBjYihyc2hhKSB9Y2F0Y2goZSl7Y29uc29sZS5sb2coZSl9IH1cbiAgICAgICAgcmV0dXJuIHJzaGE7XG4gICAgICB9XG4gICAgICBzYWx0ID0gc2FsdCB8fCBzaGltLnJhbmRvbSg5KTtcbiAgICAgIHZhciBrZXkgPSBhd2FpdCAoc2hpbS5vc3NsIHx8IHNoaW0uc3VidGxlKS5pbXBvcnRLZXkoJ3JhdycsIG5ldyBzaGltLlRleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpLCB7bmFtZTogb3B0Lm5hbWUgfHwgJ1BCS0RGMid9LCBmYWxzZSwgWydkZXJpdmVCaXRzJ10pO1xuICAgICAgdmFyIHdvcmsgPSBhd2FpdCAoc2hpbS5vc3NsIHx8IHNoaW0uc3VidGxlKS5kZXJpdmVCaXRzKHtcbiAgICAgICAgbmFtZTogb3B0Lm5hbWUgfHwgJ1BCS0RGMicsXG4gICAgICAgIGl0ZXJhdGlvbnM6IG9wdC5pdGVyYXRpb25zIHx8IFMucGJrZGYyLml0ZXIsXG4gICAgICAgIHNhbHQ6IG5ldyBzaGltLlRleHRFbmNvZGVyKCkuZW5jb2RlKG9wdC5zYWx0IHx8IHNhbHQpLFxuICAgICAgICBoYXNoOiBvcHQuaGFzaCB8fCBTLnBia2RmMi5oYXNoLFxuICAgICAgfSwga2V5LCBvcHQubGVuZ3RoIHx8IChTLnBia2RmMi5rcyAqIDgpKVxuICAgICAgZGF0YSA9IHNoaW0ucmFuZG9tKGRhdGEubGVuZ3RoKSAgLy8gRXJhc2UgZGF0YSBpbiBjYXNlIG9mIHBhc3NwaHJhc2VcbiAgICAgIHZhciByID0gc2hpbS5CdWZmZXIuZnJvbSh3b3JrLCAnYmluYXJ5JykudG9TdHJpbmcob3B0LmVuY29kZSB8fCAnYmFzZTY0JylcbiAgICAgIGlmKGNiKXsgdHJ5eyBjYihyKSB9Y2F0Y2goZSl7Y29uc29sZS5sb2coZSl9IH1cbiAgICAgIHJldHVybiByO1xuICAgIH0gY2F0Y2goZSkgeyBcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgU0VBLmVyciA9IGU7XG4gICAgICBpZihTRUEudGhyb3cpeyB0aHJvdyBlIH1cbiAgICAgIGlmKGNiKXsgY2IoKSB9XG4gICAgICByZXR1cm47XG4gICAgfX0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTRUEud29yaztcbiAgfSkoVVNFLCAnLi93b3JrJyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBTRUEgPSBVU0UoJy4vcm9vdCcpO1xuICAgIHZhciBzaGltID0gVVNFKCcuL3NoaW0nKTtcbiAgICB2YXIgUyA9IFVTRSgnLi9zZXR0aW5ncycpO1xuXG4gICAgU0VBLm5hbWUgPSBTRUEubmFtZSB8fCAoYXN5bmMgKGNiLCBvcHQpID0+IHsgdHJ5IHtcbiAgICAgIGlmKGNiKXsgdHJ5eyBjYigpIH1jYXRjaChlKXtjb25zb2xlLmxvZyhlKX0gfVxuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICBTRUEuZXJyID0gZTtcbiAgICAgIGlmKFNFQS50aHJvdyl7IHRocm93IGUgfVxuICAgICAgaWYoY2IpeyBjYigpIH1cbiAgICAgIHJldHVybjtcbiAgICB9fSk7XG5cbiAgICAvL1NFQS5wYWlyID0gYXN5bmMgKGRhdGEsIHByb29mLCBjYikgPT4geyB0cnkge1xuICAgIFNFQS5wYWlyID0gU0VBLnBhaXIgfHwgKGFzeW5jIChjYiwgb3B0KSA9PiB7IHRyeSB7XG5cbiAgICAgIHZhciBlY2RoU3VidGxlID0gc2hpbS5vc3NsIHx8IHNoaW0uc3VidGxlO1xuICAgICAgLy8gRmlyc3Q6IEVDRFNBIGtleXMgZm9yIHNpZ25pbmcvdmVyaWZ5aW5nLi4uXG4gICAgICB2YXIgc2EgPSBhd2FpdCBzaGltLnN1YnRsZS5nZW5lcmF0ZUtleSh7bmFtZTogJ0VDRFNBJywgbmFtZWRDdXJ2ZTogJ1AtMjU2J30sIHRydWUsIFsgJ3NpZ24nLCAndmVyaWZ5JyBdKVxuICAgICAgLnRoZW4oYXN5bmMgKGtleXMpID0+IHtcbiAgICAgICAgLy8gcHJpdmF0ZUtleSBzY29wZSBkb2Vzbid0IGxlYWsgb3V0IGZyb20gaGVyZSFcbiAgICAgICAgLy9jb25zdCB7IGQ6IHByaXYgfSA9IGF3YWl0IHNoaW0uc3VidGxlLmV4cG9ydEtleSgnandrJywga2V5cy5wcml2YXRlS2V5KVxuICAgICAgICB2YXIga2V5ID0ge307XG4gICAgICAgIGtleS5wcml2ID0gKGF3YWl0IHNoaW0uc3VidGxlLmV4cG9ydEtleSgnandrJywga2V5cy5wcml2YXRlS2V5KSkuZDtcbiAgICAgICAgdmFyIHB1YiA9IGF3YWl0IHNoaW0uc3VidGxlLmV4cG9ydEtleSgnandrJywga2V5cy5wdWJsaWNLZXkpO1xuICAgICAgICAvL2NvbnN0IHB1YiA9IEJ1ZmYuZnJvbShbIHgsIHkgXS5qb2luKCc6JykpLnRvU3RyaW5nKCdiYXNlNjQnKSAvLyBvbGRcbiAgICAgICAga2V5LnB1YiA9IHB1Yi54KycuJytwdWIueTsgLy8gbmV3XG4gICAgICAgIC8vIHggYW5kIHkgYXJlIGFscmVhZHkgYmFzZTY0XG4gICAgICAgIC8vIHB1YiBpcyBVVEY4IGJ1dCBmaWxlbmFtZS9VUkwgc2FmZSAoaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzM5ODYudHh0KVxuICAgICAgICAvLyBidXQgc3BsaXQgb24gYSBub24tYmFzZTY0IGxldHRlci5cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIFRvIGluY2x1ZGUgUEdQdjQga2luZCBvZiBrZXlJZDpcbiAgICAgIC8vIGNvbnN0IHB1YklkID0gYXdhaXQgU0VBLmtleWlkKGtleXMucHViKVxuICAgICAgLy8gTmV4dDogRUNESCBrZXlzIGZvciBlbmNyeXB0aW9uL2RlY3J5cHRpb24uLi5cblxuICAgICAgdHJ5e1xuICAgICAgdmFyIGRoID0gYXdhaXQgZWNkaFN1YnRsZS5nZW5lcmF0ZUtleSh7bmFtZTogJ0VDREgnLCBuYW1lZEN1cnZlOiAnUC0yNTYnfSwgdHJ1ZSwgWydkZXJpdmVLZXknXSlcbiAgICAgIC50aGVuKGFzeW5jIChrZXlzKSA9PiB7XG4gICAgICAgIC8vIHByaXZhdGVLZXkgc2NvcGUgZG9lc24ndCBsZWFrIG91dCBmcm9tIGhlcmUhXG4gICAgICAgIHZhciBrZXkgPSB7fTtcbiAgICAgICAga2V5LmVwcml2ID0gKGF3YWl0IGVjZGhTdWJ0bGUuZXhwb3J0S2V5KCdqd2snLCBrZXlzLnByaXZhdGVLZXkpKS5kO1xuICAgICAgICB2YXIgcHViID0gYXdhaXQgZWNkaFN1YnRsZS5leHBvcnRLZXkoJ2p3aycsIGtleXMucHVibGljS2V5KTtcbiAgICAgICAgLy9jb25zdCBlcHViID0gQnVmZi5mcm9tKFsgZXgsIGV5IF0uam9pbignOicpKS50b1N0cmluZygnYmFzZTY0JykgLy8gb2xkXG4gICAgICAgIGtleS5lcHViID0gcHViLngrJy4nK3B1Yi55OyAvLyBuZXdcbiAgICAgICAgLy8gZXggYW5kIGV5IGFyZSBhbHJlYWR5IGJhc2U2NFxuICAgICAgICAvLyBlcHViIGlzIFVURjggYnV0IGZpbGVuYW1lL1VSTCBzYWZlIChodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzk4Ni50eHQpXG4gICAgICAgIC8vIGJ1dCBzcGxpdCBvbiBhIG5vbi1iYXNlNjQgbGV0dGVyLlxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSlcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgaWYoU0VBLndpbmRvdyl7IHRocm93IGUgfVxuICAgICAgICBpZihlID09ICdFcnJvcjogRUNESCBpcyBub3QgYSBzdXBwb3J0ZWQgYWxnb3JpdGhtJyl7IGNvbnNvbGUubG9nKCdJZ25vcmluZyBFQ0RILi4uJykgfVxuICAgICAgICBlbHNlIHsgdGhyb3cgZSB9XG4gICAgICB9IGRoID0gZGggfHwge307XG5cbiAgICAgIHZhciByID0geyBwdWI6IHNhLnB1YiwgcHJpdjogc2EucHJpdiwgLyogcHViSWQsICovIGVwdWI6IGRoLmVwdWIsIGVwcml2OiBkaC5lcHJpdiB9XG4gICAgICBpZihjYil7IHRyeXsgY2IocikgfWNhdGNoKGUpe2NvbnNvbGUubG9nKGUpfSB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgU0VBLmVyciA9IGU7XG4gICAgICBpZihTRUEudGhyb3cpeyB0aHJvdyBlIH1cbiAgICAgIGlmKGNiKXsgY2IoKSB9XG4gICAgICByZXR1cm47XG4gICAgfX0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTRUEucGFpcjtcbiAgfSkoVVNFLCAnLi9wYWlyJyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBTRUEgPSBVU0UoJy4vcm9vdCcpO1xuICAgIHZhciBzaGltID0gVVNFKCcuL3NoaW0nKTtcbiAgICB2YXIgUyA9IFVTRSgnLi9zZXR0aW5ncycpO1xuICAgIHZhciBzaGEgPSBVU0UoJy4vc2hhMjU2Jyk7XG4gICAgdmFyIHU7XG5cbiAgICBTRUEuc2lnbiA9IFNFQS5zaWduIHx8IChhc3luYyAoZGF0YSwgcGFpciwgY2IsIG9wdCkgPT4geyB0cnkge1xuICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgaWYoIShwYWlyfHxvcHQpLnByaXYpe1xuICAgICAgICBpZighU0VBLkkpeyB0aHJvdyAnTm8gc2lnbmluZyBrZXkuJyB9XG4gICAgICAgIHBhaXIgPSBhd2FpdCBTRUEuSShudWxsLCB7d2hhdDogZGF0YSwgaG93OiAnc2lnbicsIHdoeTogb3B0LndoeX0pO1xuICAgICAgfVxuICAgICAgaWYodSA9PT0gZGF0YSl7IHRocm93ICdgdW5kZWZpbmVkYCBub3QgYWxsb3dlZC4nIH1cbiAgICAgIHZhciBqc29uID0gYXdhaXQgUy5wYXJzZShkYXRhKTtcbiAgICAgIHZhciBjaGVjayA9IG9wdC5jaGVjayA9IG9wdC5jaGVjayB8fCBqc29uO1xuICAgICAgaWYoU0VBLnZlcmlmeSAmJiAoU0VBLm9wdC5jaGVjayhjaGVjaykgfHwgKGNoZWNrICYmIGNoZWNrLnMgJiYgY2hlY2subSkpXG4gICAgICAmJiB1ICE9PSBhd2FpdCBTRUEudmVyaWZ5KGNoZWNrLCBwYWlyKSl7IC8vIGRvbid0IHNpZ24gaWYgd2UgYWxyZWFkeSBzaWduZWQgaXQuXG4gICAgICAgIHZhciByID0gYXdhaXQgUy5wYXJzZShjaGVjayk7XG4gICAgICAgIGlmKCFvcHQucmF3KXsgciA9ICdTRUEnICsgYXdhaXQgc2hpbS5zdHJpbmdpZnkocikgfVxuICAgICAgICBpZihjYil7IHRyeXsgY2IocikgfWNhdGNoKGUpe2NvbnNvbGUubG9nKGUpfSB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgICAgdmFyIHB1YiA9IHBhaXIucHViO1xuICAgICAgdmFyIHByaXYgPSBwYWlyLnByaXY7XG4gICAgICB2YXIgandrID0gUy5qd2socHViLCBwcml2KTtcbiAgICAgIHZhciBoYXNoID0gYXdhaXQgc2hhKGpzb24pO1xuICAgICAgdmFyIHNpZyA9IGF3YWl0IChzaGltLm9zc2wgfHwgc2hpbS5zdWJ0bGUpLmltcG9ydEtleSgnandrJywgandrLCB7bmFtZTogJ0VDRFNBJywgbmFtZWRDdXJ2ZTogJ1AtMjU2J30sIGZhbHNlLCBbJ3NpZ24nXSlcbiAgICAgIC50aGVuKChrZXkpID0+IChzaGltLm9zc2wgfHwgc2hpbS5zdWJ0bGUpLnNpZ24oe25hbWU6ICdFQ0RTQScsIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9fSwga2V5LCBuZXcgVWludDhBcnJheShoYXNoKSkpIC8vIHByaXZhdGVLZXkgc2NvcGUgZG9lc24ndCBsZWFrIG91dCBmcm9tIGhlcmUhXG4gICAgICB2YXIgciA9IHttOiBqc29uLCBzOiBzaGltLkJ1ZmZlci5mcm9tKHNpZywgJ2JpbmFyeScpLnRvU3RyaW5nKG9wdC5lbmNvZGUgfHwgJ2Jhc2U2NCcpfVxuICAgICAgaWYoIW9wdC5yYXcpeyByID0gJ1NFQScgKyBhd2FpdCBzaGltLnN0cmluZ2lmeShyKSB9XG5cbiAgICAgIGlmKGNiKXsgdHJ5eyBjYihyKSB9Y2F0Y2goZSl7Y29uc29sZS5sb2coZSl9IH1cbiAgICAgIHJldHVybiByO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICBTRUEuZXJyID0gZTtcbiAgICAgIGlmKFNFQS50aHJvdyl7IHRocm93IGUgfVxuICAgICAgaWYoY2IpeyBjYigpIH1cbiAgICAgIHJldHVybjtcbiAgICB9fSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNFQS5zaWduO1xuICB9KShVU0UsICcuL3NpZ24nKTtcblxuICA7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG4gICAgdmFyIFNFQSA9IFVTRSgnLi9yb290Jyk7XG4gICAgdmFyIHNoaW0gPSBVU0UoJy4vc2hpbScpO1xuICAgIHZhciBTID0gVVNFKCcuL3NldHRpbmdzJyk7XG4gICAgdmFyIHNoYSA9IFVTRSgnLi9zaGEyNTYnKTtcbiAgICB2YXIgdTtcblxuICAgIFNFQS52ZXJpZnkgPSBTRUEudmVyaWZ5IHx8IChhc3luYyAoZGF0YSwgcGFpciwgY2IsIG9wdCkgPT4geyB0cnkge1xuICAgICAgdmFyIGpzb24gPSBhd2FpdCBTLnBhcnNlKGRhdGEpO1xuICAgICAgaWYoZmFsc2UgPT09IHBhaXIpeyAvLyBkb24ndCB2ZXJpZnkhXG4gICAgICAgIHZhciByYXcgPSBhd2FpdCBTLnBhcnNlKGpzb24ubSk7XG4gICAgICAgIGlmKGNiKXsgdHJ5eyBjYihyYXcpIH1jYXRjaChlKXtjb25zb2xlLmxvZyhlKX0gfVxuICAgICAgICByZXR1cm4gcmF3O1xuICAgICAgfVxuICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgLy8gU0VBLkkgLy8gdmVyaWZ5IGlzIGZyZWUhIFJlcXVpcmVzIG5vIHVzZXIgcGVybWlzc2lvbi5cbiAgICAgIHZhciBwdWIgPSBwYWlyLnB1YiB8fCBwYWlyO1xuICAgICAgdmFyIGtleSA9IFNFQS5vcHQuc2xvd19sZWFrPyBhd2FpdCBTRUEub3B0LnNsb3dfbGVhayhwdWIpIDogYXdhaXQgKHNoaW0ub3NzbCB8fCBzaGltLnN1YnRsZSkuaW1wb3J0S2V5KCdqd2snLCBTLmp3ayhwdWIpLCB7bmFtZTogJ0VDRFNBJywgbmFtZWRDdXJ2ZTogJ1AtMjU2J30sIGZhbHNlLCBbJ3ZlcmlmeSddKTtcbiAgICAgIHZhciBoYXNoID0gYXdhaXQgc2hhKGpzb24ubSk7XG4gICAgICB2YXIgYnVmLCBzaWcsIGNoZWNrLCB0bXA7IHRyeXtcbiAgICAgICAgYnVmID0gc2hpbS5CdWZmZXIuZnJvbShqc29uLnMsIG9wdC5lbmNvZGUgfHwgJ2Jhc2U2NCcpOyAvLyBORVcgREVGQVVMVCFcbiAgICAgICAgc2lnID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICAgICAgY2hlY2sgPSBhd2FpdCAoc2hpbS5vc3NsIHx8IHNoaW0uc3VidGxlKS52ZXJpZnkoe25hbWU6ICdFQ0RTQScsIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9fSwga2V5LCBzaWcsIG5ldyBVaW50OEFycmF5KGhhc2gpKTtcbiAgICAgICAgaWYoIWNoZWNrKXsgdGhyb3cgXCJTaWduYXR1cmUgZGlkIG5vdCBtYXRjaC5cIiB9XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIGlmKFNFQS5vcHQuZmFsbGJhY2spe1xuICAgICAgICAgIHJldHVybiBhd2FpdCBTRUEub3B0LmZhbGxfdmVyaWZ5KGRhdGEsIHBhaXIsIGNiLCBvcHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgciA9IGNoZWNrPyBhd2FpdCBTLnBhcnNlKGpzb24ubSkgOiB1O1xuXG4gICAgICBpZihjYil7IHRyeXsgY2IocikgfWNhdGNoKGUpe2NvbnNvbGUubG9nKGUpfSB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGUpOyAvLyBtaXNtYXRjaGVkIG93bmVyIEZPUiBNQVJUVElcbiAgICAgIFNFQS5lcnIgPSBlO1xuICAgICAgaWYoU0VBLnRocm93KXsgdGhyb3cgZSB9XG4gICAgICBpZihjYil7IGNiKCkgfVxuICAgICAgcmV0dXJuO1xuICAgIH19KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU0VBLnZlcmlmeTtcbiAgICAvLyBsZWdhY3kgJiBvc3NsIG1lbW9yeSBsZWFrIG1pdGlnYXRpb246XG5cbiAgICB2YXIga25vd25LZXlzID0ge307XG4gICAgdmFyIGtleUZvclBhaXIgPSBTRUEub3B0LnNsb3dfbGVhayA9IHBhaXIgPT4ge1xuICAgICAgaWYgKGtub3duS2V5c1twYWlyXSkgcmV0dXJuIGtub3duS2V5c1twYWlyXTtcbiAgICAgIHZhciBqd2sgPSBTLmp3ayhwYWlyKTtcbiAgICAgIGtub3duS2V5c1twYWlyXSA9IChzaGltLm9zc2wgfHwgc2hpbS5zdWJ0bGUpLmltcG9ydEtleShcImp3a1wiLCBqd2ssIHtuYW1lOiAnRUNEU0EnLCBuYW1lZEN1cnZlOiAnUC0yNTYnfSwgZmFsc2UsIFtcInZlcmlmeVwiXSk7XG4gICAgICByZXR1cm4ga25vd25LZXlzW3BhaXJdO1xuICAgIH07XG5cbiAgICB2YXIgTyA9IFNFQS5vcHQ7XG4gICAgU0VBLm9wdC5mYWxsX3ZlcmlmeSA9IGFzeW5jIGZ1bmN0aW9uKGRhdGEsIHBhaXIsIGNiLCBvcHQsIGYpe1xuICAgICAgaWYoZiA9PT0gU0VBLm9wdC5mYWxsYmFjayl7IHRocm93IFwiU2lnbmF0dXJlIGRpZCBub3QgbWF0Y2hcIiB9IGYgPSBmIHx8IDE7XG4gICAgICB2YXIgdG1wID0gZGF0YXx8Jyc7XG4gICAgICBkYXRhID0gU0VBLm9wdC51bnBhY2soZGF0YSkgfHwgZGF0YTtcbiAgICAgIHZhciBqc29uID0gYXdhaXQgUy5wYXJzZShkYXRhKSwgcHViID0gcGFpci5wdWIgfHwgcGFpciwga2V5ID0gYXdhaXQgU0VBLm9wdC5zbG93X2xlYWsocHViKTtcbiAgICAgIHZhciBoYXNoID0gKGYgPD0gU0VBLm9wdC5mYWxsYmFjayk/IHNoaW0uQnVmZmVyLmZyb20oYXdhaXQgc2hpbS5zdWJ0bGUuZGlnZXN0KHtuYW1lOiAnU0hBLTI1Nid9LCBuZXcgc2hpbS5UZXh0RW5jb2RlcigpLmVuY29kZShhd2FpdCBTLnBhcnNlKGpzb24ubSkpKSkgOiBhd2FpdCBzaGEoanNvbi5tKTsgLy8gdGhpcyBsaW5lIGlzIG9sZCBiYWQgYnVnZ3kgY29kZSBidXQgbmVjZXNzYXJ5IGZvciBvbGQgY29tcGF0aWJpbGl0eS5cbiAgICAgIHZhciBidWY7IHZhciBzaWc7IHZhciBjaGVjazsgdHJ5e1xuICAgICAgICBidWYgPSBzaGltLkJ1ZmZlci5mcm9tKGpzb24ucywgb3B0LmVuY29kZSB8fCAnYmFzZTY0JykgLy8gTkVXIERFRkFVTFQhXG4gICAgICAgIHNpZyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICAgICAgY2hlY2sgPSBhd2FpdCAoc2hpbS5vc3NsIHx8IHNoaW0uc3VidGxlKS52ZXJpZnkoe25hbWU6ICdFQ0RTQScsIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9fSwga2V5LCBzaWcsIG5ldyBVaW50OEFycmF5KGhhc2gpKVxuICAgICAgICBpZighY2hlY2speyB0aHJvdyBcIlNpZ25hdHVyZSBkaWQgbm90IG1hdGNoLlwiIH1cbiAgICAgIH1jYXRjaChlKXsgdHJ5e1xuICAgICAgICBidWYgPSBzaGltLkJ1ZmZlci5mcm9tKGpzb24ucywgJ3V0ZjgnKSAvLyBBVVRPIEJBQ0tXQVJEIE9MRCBVVEY4IERBVEEhXG4gICAgICAgIHNpZyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICAgICAgY2hlY2sgPSBhd2FpdCAoc2hpbS5vc3NsIHx8IHNoaW0uc3VidGxlKS52ZXJpZnkoe25hbWU6ICdFQ0RTQScsIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9fSwga2V5LCBzaWcsIG5ldyBVaW50OEFycmF5KGhhc2gpKVxuICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIGlmKCFjaGVjayl7IHRocm93IFwiU2lnbmF0dXJlIGRpZCBub3QgbWF0Y2guXCIgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgciA9IGNoZWNrPyBhd2FpdCBTLnBhcnNlKGpzb24ubSkgOiB1O1xuICAgICAgTy5mYWxsX3NvdWwgPSB0bXBbJyMnXTsgTy5mYWxsX2tleSA9IHRtcFsnLiddOyBPLmZhbGxfdmFsID0gZGF0YTsgTy5mYWxsX3N0YXRlID0gdG1wWyc+J107XG4gICAgICBpZihjYil7IHRyeXsgY2IocikgfWNhdGNoKGUpe2NvbnNvbGUubG9nKGUpfSB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgU0VBLm9wdC5mYWxsYmFjayA9IDI7XG5cbiAgfSkoVVNFLCAnLi92ZXJpZnknKTtcblxuICA7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG4gICAgdmFyIHNoaW0gPSBVU0UoJy4vc2hpbScpO1xuICAgIHZhciBTID0gVVNFKCcuL3NldHRpbmdzJyk7XG4gICAgdmFyIHNoYTI1Nmhhc2ggPSBVU0UoJy4vc2hhMjU2Jyk7XG5cbiAgICBjb25zdCBpbXBvcnRHZW4gPSBhc3luYyAoa2V5LCBzYWx0LCBvcHQpID0+IHtcbiAgICAgIC8vY29uc3QgY29tYm8gPSBzaGltLkJ1ZmZlci5jb25jYXQoW3NoaW0uQnVmZmVyLmZyb20oa2V5LCAndXRmOCcpLCBzYWx0IHx8IHNoaW0ucmFuZG9tKDgpXSkudG9TdHJpbmcoJ3V0ZjgnKSAvLyBvbGRcbiAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgIGNvbnN0IGNvbWJvID0ga2V5ICsgKHNhbHQgfHwgc2hpbS5yYW5kb20oOCkpLnRvU3RyaW5nKCd1dGY4Jyk7IC8vIG5ld1xuICAgICAgY29uc3QgaGFzaCA9IHNoaW0uQnVmZmVyLmZyb20oYXdhaXQgc2hhMjU2aGFzaChjb21ibyksICdiaW5hcnknKVxuICAgICAgXG4gICAgICBjb25zdCBqd2tLZXkgPSBTLmtleVRvSndrKGhhc2gpICAgICAgXG4gICAgICByZXR1cm4gYXdhaXQgc2hpbS5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBqd2tLZXksIHtuYW1lOidBRVMtR0NNJ30sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGltcG9ydEdlbjtcbiAgfSkoVVNFLCAnLi9hZXNrZXknKTtcblxuICA7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG4gICAgdmFyIFNFQSA9IFVTRSgnLi9yb290Jyk7XG4gICAgdmFyIHNoaW0gPSBVU0UoJy4vc2hpbScpO1xuICAgIHZhciBTID0gVVNFKCcuL3NldHRpbmdzJyk7XG4gICAgdmFyIGFlc2tleSA9IFVTRSgnLi9hZXNrZXknKTtcbiAgICB2YXIgdTtcblxuICAgIFNFQS5lbmNyeXB0ID0gU0VBLmVuY3J5cHQgfHwgKGFzeW5jIChkYXRhLCBwYWlyLCBjYiwgb3B0KSA9PiB7IHRyeSB7XG4gICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICB2YXIga2V5ID0gKHBhaXJ8fG9wdCkuZXByaXYgfHwgcGFpcjtcbiAgICAgIGlmKHUgPT09IGRhdGEpeyB0aHJvdyAnYHVuZGVmaW5lZGAgbm90IGFsbG93ZWQuJyB9XG4gICAgICBpZigha2V5KXtcbiAgICAgICAgaWYoIVNFQS5JKXsgdGhyb3cgJ05vIGVuY3J5cHRpb24ga2V5LicgfVxuICAgICAgICBwYWlyID0gYXdhaXQgU0VBLkkobnVsbCwge3doYXQ6IGRhdGEsIGhvdzogJ2VuY3J5cHQnLCB3aHk6IG9wdC53aHl9KTtcbiAgICAgICAga2V5ID0gcGFpci5lcHJpdiB8fCBwYWlyO1xuICAgICAgfVxuICAgICAgdmFyIG1zZyA9ICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyk/IGRhdGEgOiBhd2FpdCBzaGltLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgIHZhciByYW5kID0ge3M6IHNoaW0ucmFuZG9tKDkpLCBpdjogc2hpbS5yYW5kb20oMTUpfTsgLy8gY29uc2lkZXIgbWFraW5nIHRoaXMgOSBhbmQgMTUgb3IgMTggb3IgMTIgdG8gcmVkdWNlID09IHBhZGRpbmcuXG4gICAgICB2YXIgY3QgPSBhd2FpdCBhZXNrZXkoa2V5LCByYW5kLnMsIG9wdCkudGhlbigoYWVzKSA9PiAoLypzaGltLm9zc2wgfHwqLyBzaGltLnN1YnRsZSkuZW5jcnlwdCh7IC8vIEtlZXBpbmcgdGhlIEFFUyBrZXkgc2NvcGUgYXMgcHJpdmF0ZSBhcyBwb3NzaWJsZS4uLlxuICAgICAgICBuYW1lOiBvcHQubmFtZSB8fCAnQUVTLUdDTScsIGl2OiBuZXcgVWludDhBcnJheShyYW5kLml2KVxuICAgICAgfSwgYWVzLCBuZXcgc2hpbS5UZXh0RW5jb2RlcigpLmVuY29kZShtc2cpKSk7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgY3Q6IHNoaW0uQnVmZmVyLmZyb20oY3QsICdiaW5hcnknKS50b1N0cmluZyhvcHQuZW5jb2RlIHx8ICdiYXNlNjQnKSxcbiAgICAgICAgaXY6IHJhbmQuaXYudG9TdHJpbmcob3B0LmVuY29kZSB8fCAnYmFzZTY0JyksXG4gICAgICAgIHM6IHJhbmQucy50b1N0cmluZyhvcHQuZW5jb2RlIHx8ICdiYXNlNjQnKVxuICAgICAgfVxuICAgICAgaWYoIW9wdC5yYXcpeyByID0gJ1NFQScgKyBhd2FpdCBzaGltLnN0cmluZ2lmeShyKSB9XG5cbiAgICAgIGlmKGNiKXsgdHJ5eyBjYihyKSB9Y2F0Y2goZSl7Y29uc29sZS5sb2coZSl9IH1cbiAgICAgIHJldHVybiByO1xuICAgIH0gY2F0Y2goZSkgeyBcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgU0VBLmVyciA9IGU7XG4gICAgICBpZihTRUEudGhyb3cpeyB0aHJvdyBlIH1cbiAgICAgIGlmKGNiKXsgY2IoKSB9XG4gICAgICByZXR1cm47XG4gICAgfX0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTRUEuZW5jcnlwdDtcbiAgfSkoVVNFLCAnLi9lbmNyeXB0Jyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBTRUEgPSBVU0UoJy4vcm9vdCcpO1xuICAgIHZhciBzaGltID0gVVNFKCcuL3NoaW0nKTtcbiAgICB2YXIgUyA9IFVTRSgnLi9zZXR0aW5ncycpO1xuICAgIHZhciBhZXNrZXkgPSBVU0UoJy4vYWVza2V5Jyk7XG5cbiAgICBTRUEuZGVjcnlwdCA9IFNFQS5kZWNyeXB0IHx8IChhc3luYyAoZGF0YSwgcGFpciwgY2IsIG9wdCkgPT4geyB0cnkge1xuICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgdmFyIGtleSA9IChwYWlyfHxvcHQpLmVwcml2IHx8IHBhaXI7XG4gICAgICBpZigha2V5KXtcbiAgICAgICAgaWYoIVNFQS5JKXsgdGhyb3cgJ05vIGRlY3J5cHRpb24ga2V5LicgfVxuICAgICAgICBwYWlyID0gYXdhaXQgU0VBLkkobnVsbCwge3doYXQ6IGRhdGEsIGhvdzogJ2RlY3J5cHQnLCB3aHk6IG9wdC53aHl9KTtcbiAgICAgICAga2V5ID0gcGFpci5lcHJpdiB8fCBwYWlyO1xuICAgICAgfVxuICAgICAgdmFyIGpzb24gPSBhd2FpdCBTLnBhcnNlKGRhdGEpO1xuICAgICAgdmFyIGJ1ZiwgYnVmaXYsIGJ1ZmN0OyB0cnl7XG4gICAgICAgIGJ1ZiA9IHNoaW0uQnVmZmVyLmZyb20oanNvbi5zLCBvcHQuZW5jb2RlIHx8ICdiYXNlNjQnKTtcbiAgICAgICAgYnVmaXYgPSBzaGltLkJ1ZmZlci5mcm9tKGpzb24uaXYsIG9wdC5lbmNvZGUgfHwgJ2Jhc2U2NCcpO1xuICAgICAgICBidWZjdCA9IHNoaW0uQnVmZmVyLmZyb20oanNvbi5jdCwgb3B0LmVuY29kZSB8fCAnYmFzZTY0Jyk7XG4gICAgICAgIHZhciBjdCA9IGF3YWl0IGFlc2tleShrZXksIGJ1Ziwgb3B0KS50aGVuKChhZXMpID0+ICgvKnNoaW0ub3NzbCB8fCovIHNoaW0uc3VidGxlKS5kZWNyeXB0KHsgIC8vIEtlZXBpbmcgYWVzS2V5IHNjb3BlIGFzIHByaXZhdGUgYXMgcG9zc2libGUuLi5cbiAgICAgICAgICBuYW1lOiBvcHQubmFtZSB8fCAnQUVTLUdDTScsIGl2OiBuZXcgVWludDhBcnJheShidWZpdiksIHRhZ0xlbmd0aDogMTI4XG4gICAgICAgIH0sIGFlcywgbmV3IFVpbnQ4QXJyYXkoYnVmY3QpKSk7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIGlmKCd1dGY4JyA9PT0gb3B0LmVuY29kZSl7IHRocm93IFwiQ291bGQgbm90IGRlY3J5cHRcIiB9XG4gICAgICAgIGlmKFNFQS5vcHQuZmFsbGJhY2spe1xuICAgICAgICAgIG9wdC5lbmNvZGUgPSAndXRmOCc7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IFNFQS5kZWNyeXB0KGRhdGEsIHBhaXIsIGNiLCBvcHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgciA9IGF3YWl0IFMucGFyc2UobmV3IHNoaW0uVGV4dERlY29kZXIoJ3V0ZjgnKS5kZWNvZGUoY3QpKTtcbiAgICAgIGlmKGNiKXsgdHJ5eyBjYihyKSB9Y2F0Y2goZSl7Y29uc29sZS5sb2coZSl9IH1cbiAgICAgIHJldHVybiByO1xuICAgIH0gY2F0Y2goZSkgeyBcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgU0VBLmVyciA9IGU7XG4gICAgICBpZihTRUEudGhyb3cpeyB0aHJvdyBlIH1cbiAgICAgIGlmKGNiKXsgY2IoKSB9XG4gICAgICByZXR1cm47XG4gICAgfX0pO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTRUEuZGVjcnlwdDtcbiAgfSkoVVNFLCAnLi9kZWNyeXB0Jyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBTRUEgPSBVU0UoJy4vcm9vdCcpO1xuICAgIHZhciBzaGltID0gVVNFKCcuL3NoaW0nKTtcbiAgICB2YXIgUyA9IFVTRSgnLi9zZXR0aW5ncycpO1xuICAgIC8vIERlcml2ZSBzaGFyZWQgc2VjcmV0IGZyb20gb3RoZXIncyBwdWIgYW5kIG15IGVwdWIvZXByaXYgXG4gICAgU0VBLnNlY3JldCA9IFNFQS5zZWNyZXQgfHwgKGFzeW5jIChrZXksIHBhaXIsIGNiLCBvcHQpID0+IHsgdHJ5IHtcbiAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgIGlmKCFwYWlyIHx8ICFwYWlyLmVwcml2IHx8ICFwYWlyLmVwdWIpe1xuICAgICAgICBpZighU0VBLkkpeyB0aHJvdyAnTm8gc2VjcmV0IG1peC4nIH1cbiAgICAgICAgcGFpciA9IGF3YWl0IFNFQS5JKG51bGwsIHt3aGF0OiBrZXksIGhvdzogJ3NlY3JldCcsIHdoeTogb3B0LndoeX0pO1xuICAgICAgfVxuICAgICAgdmFyIHB1YiA9IGtleS5lcHViIHx8IGtleTtcbiAgICAgIHZhciBlcHViID0gcGFpci5lcHViO1xuICAgICAgdmFyIGVwcml2ID0gcGFpci5lcHJpdjtcbiAgICAgIHZhciBlY2RoU3VidGxlID0gc2hpbS5vc3NsIHx8IHNoaW0uc3VidGxlO1xuICAgICAgdmFyIHB1YktleURhdGEgPSBrZXlzVG9FY2RoSndrKHB1Yik7XG4gICAgICB2YXIgcHJvcHMgPSBPYmplY3QuYXNzaWduKHsgcHVibGljOiBhd2FpdCBlY2RoU3VidGxlLmltcG9ydEtleSguLi5wdWJLZXlEYXRhLCB0cnVlLCBbXSkgfSx7bmFtZTogJ0VDREgnLCBuYW1lZEN1cnZlOiAnUC0yNTYnfSk7IC8vIFRoYW5rcyB0byBAc2lycHkgIVxuICAgICAgdmFyIHByaXZLZXlEYXRhID0ga2V5c1RvRWNkaEp3ayhlcHViLCBlcHJpdik7XG4gICAgICB2YXIgZGVyaXZlZCA9IGF3YWl0IGVjZGhTdWJ0bGUuaW1wb3J0S2V5KC4uLnByaXZLZXlEYXRhLCBmYWxzZSwgWydkZXJpdmVCaXRzJ10pLnRoZW4oYXN5bmMgKHByaXZLZXkpID0+IHtcbiAgICAgICAgLy8gcHJpdmF0ZUtleSBzY29wZSBkb2Vzbid0IGxlYWsgb3V0IGZyb20gaGVyZSFcbiAgICAgICAgdmFyIGRlcml2ZWRCaXRzID0gYXdhaXQgZWNkaFN1YnRsZS5kZXJpdmVCaXRzKHByb3BzLCBwcml2S2V5LCAyNTYpO1xuICAgICAgICB2YXIgcmF3Qml0cyA9IG5ldyBVaW50OEFycmF5KGRlcml2ZWRCaXRzKTtcbiAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBhd2FpdCBlY2RoU3VidGxlLmltcG9ydEtleSgncmF3JywgcmF3Qml0cyx7IG5hbWU6ICdBRVMtR0NNJywgbGVuZ3RoOiAyNTYgfSwgdHJ1ZSwgWyAnZW5jcnlwdCcsICdkZWNyeXB0JyBdKTtcbiAgICAgICAgcmV0dXJuIGVjZGhTdWJ0bGUuZXhwb3J0S2V5KCdqd2snLCBkZXJpdmVkS2V5KS50aGVuKCh7IGsgfSkgPT4gayk7XG4gICAgICB9KVxuICAgICAgdmFyIHIgPSBkZXJpdmVkO1xuICAgICAgaWYoY2IpeyB0cnl7IGNiKHIpIH1jYXRjaChlKXtjb25zb2xlLmxvZyhlKX0gfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgIFNFQS5lcnIgPSBlO1xuICAgICAgaWYoU0VBLnRocm93KXsgdGhyb3cgZSB9XG4gICAgICBpZihjYil7IGNiKCkgfVxuICAgICAgcmV0dXJuO1xuICAgIH19KTtcblxuICAgIC8vIGNhbiB0aGlzIGJlIHJlcGxhY2VkIHdpdGggc2V0dGluZ3MuandrP1xuICAgIHZhciBrZXlzVG9FY2RoSndrID0gKHB1YiwgZCkgPT4geyAvLyBkID09PSBwcml2XG4gICAgICAvL3ZhciBbIHgsIHkgXSA9IHNoaW0uQnVmZmVyLmZyb20ocHViLCAnYmFzZTY0JykudG9TdHJpbmcoJ3V0ZjgnKS5zcGxpdCgnOicpIC8vIG9sZFxuICAgICAgdmFyIFsgeCwgeSBdID0gcHViLnNwbGl0KCcuJykgLy8gbmV3XG4gICAgICB2YXIgandrID0gZCA/IHsgZDogZCB9IDoge31cbiAgICAgIHJldHVybiBbICAvLyBVc2Ugd2l0aCBzcHJlYWQgcmV0dXJuZWQgdmFsdWUuLi5cbiAgICAgICAgJ2p3aycsXG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgandrLFxuICAgICAgICAgIHsgeDogeCwgeTogeSwga3R5OiAnRUMnLCBjcnY6ICdQLTI1NicsIGV4dDogdHJ1ZSB9XG4gICAgICAgICksIC8vID8/PyByZWZhY3RvclxuICAgICAgICB7bmFtZTogJ0VDREgnLCBuYW1lZEN1cnZlOiAnUC0yNTYnfVxuICAgICAgXVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gU0VBLnNlY3JldDtcbiAgfSkoVVNFLCAnLi9zZWNyZXQnKTtcblxuICA7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG4gICAgdmFyIFNFQSA9IFVTRSgnLi9yb290Jyk7XG4gICAgLy8gVGhpcyBpcyB0byBjZXJ0aWZ5IHRoYXQgYSBncm91cCBvZiBcImNlcnRpZmljYW50c1wiIGNhbiBcInB1dFwiIGFueXRoaW5nIGF0IGEgZ3JvdXAgb2YgbWF0Y2hlZCBcInBhdGhzXCIgdG8gdGhlIGNlcnRpZmljYXRlIGF1dGhvcml0eSdzIGdyYXBoXG4gICAgU0VBLmNlcnRpZnkgPSBTRUEuY2VydGlmeSB8fCAoYXN5bmMgKGNlcnRpZmljYW50cywgcG9saWN5ID0ge30sIGF1dGhvcml0eSwgY2IsIG9wdCA9IHt9KSA9PiB7IHRyeSB7XG4gICAgICAvKlxuICAgICAgVGhlIENlcnRpZnkgUHJvdG9jb2wgd2FzIG1hZGUgb3V0IG9mIGxvdmUgYnkgYSBWaWV0bmFtZXNlIGNvZGUgZW50aHVzaWFzdC4gVmlldG5hbWVzZSBwZW9wbGUgYXJvdW5kIHRoZSB3b3JsZCBkZXNlcnZlIHJlc3BlY3QhXG4gICAgICBJTVBPUlRBTlQ6IEEgQ2VydGlmaWNhdGUgaXMgbGlrZSBhIFNpZ25hdHVyZS4gTm8gb25lIGtub3dzIHdobyAoYXV0aG9yaXR5KSBjcmVhdGVkL3NpZ25lZCBhIGNlcnQgdW50aWwgeW91IHB1dCBpdCBpbnRvIHRoZWlyIGdyYXBoLlxuICAgICAgXCJjZXJ0aWZpY2FudHNcIjogJyonIG9yIGEgU3RyaW5nIChCb2IucHViKSB8fCBhbiBPYmplY3QgdGhhdCBjb250YWlucyBcInB1YlwiIGFzIGEga2V5IHx8IGFuIGFycmF5IG9mIFtvYmplY3QgfHwgc3RyaW5nXS4gVGhlc2UgcGVvcGxlIHdpbGwgaGF2ZSB0aGUgcmlnaHRzLlxuICAgICAgXCJwb2xpY3lcIjogQSBzdHJpbmcgKCdpbmJveCcpLCBvciBhIFJBRC9MRVggb2JqZWN0IHsnKic6ICdpbmJveCd9LCBvciBhbiBBcnJheSBvZiBSQUQvTEVYIG9iamVjdHMgb3Igc3RyaW5ncy4gUkFEL0xFWCBvYmplY3QgY2FuIGNvbnRhaW4ga2V5IFwiP1wiIHdpdGggaW5kZXhPZihcIipcIikgPiAtMSB0byBmb3JjZSBrZXkgZXF1YWxzIGNlcnRpZmljYW50IHB1Yi4gVGhpcyBydWxlIGlzIHVzZWQgdG8gY2hlY2sgYWdhaW5zdCBzb3VsKycvJytrZXkgdXNpbmcgR3VuLnRleHQubWF0Y2ggb3IgU3RyaW5nLm1hdGNoLlxuICAgICAgXCJhdXRob3JpdHlcIjogS2V5IHBhaXIgb3IgcHJpdiBvZiB0aGUgY2VydGlmaWNhdGUgYXV0aG9yaXR5LlxuICAgICAgXCJjYlwiOiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGFmdGVyIGFsbCB0aGluZ3MgYXJlIGRvbmUuXG4gICAgICBcIm9wdFwiOiBJZiBvcHQuZXhwaXJ5IChhIHRpbWVzdGFtcCkgaXMgc2V0LCBTRUEgd29uJ3Qgc3luYyBkYXRhIGFmdGVyIG9wdC5leHBpcnkuIElmIG9wdC5ibG9jayBpcyBzZXQsIFNFQSB3aWxsIGxvb2sgZm9yIGJsb2NrIGJlZm9yZSBzeW5jaW5nLlxuICAgICAgKi9cbiAgICAgIGNvbnNvbGUubG9nKCdTRUEuY2VydGlmeSgpIGlzIGFuIGVhcmx5IGV4cGVyaW1lbnRhbCBjb21tdW5pdHkgc3VwcG9ydGVkIG1ldGhvZCB0aGF0IG1heSBjaGFuZ2UgQVBJIGJlaGF2aW9yIHdpdGhvdXQgd2FybmluZyBpbiBhbnkgZnV0dXJlIHZlcnNpb24uJylcblxuICAgICAgY2VydGlmaWNhbnRzID0gKCgpID0+IHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXVxuICAgICAgICBpZiAoY2VydGlmaWNhbnRzKSB7XG4gICAgICAgICAgaWYgKCh0eXBlb2YgY2VydGlmaWNhbnRzID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGNlcnRpZmljYW50cykpICYmIGNlcnRpZmljYW50cy5pbmRleE9mKCcqJykgPiAtMSkgcmV0dXJuICcqJ1xuICAgICAgICAgIGlmICh0eXBlb2YgY2VydGlmaWNhbnRzID09PSAnc3RyaW5nJykgcmV0dXJuIGNlcnRpZmljYW50c1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNlcnRpZmljYW50cykpIHtcbiAgICAgICAgICAgIGlmIChjZXJ0aWZpY2FudHMubGVuZ3RoID09PSAxICYmIGNlcnRpZmljYW50c1swXSkgcmV0dXJuIHR5cGVvZiBjZXJ0aWZpY2FudHNbMF0gPT09ICdvYmplY3QnICYmIGNlcnRpZmljYW50c1swXS5wdWIgPyBjZXJ0aWZpY2FudHNbMF0ucHViIDogdHlwZW9mIGNlcnRpZmljYW50c1swXSA9PT0gJ3N0cmluZycgPyBjZXJ0aWZpY2FudHNbMF0gOiBudWxsXG4gICAgICAgICAgICBjZXJ0aWZpY2FudHMubWFwKGNlcnRpZmljYW50ID0+IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjZXJ0aWZpY2FudCA9PT0nc3RyaW5nJykgZGF0YS5wdXNoKGNlcnRpZmljYW50KVxuICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2VydGlmaWNhbnQgPT09ICdvYmplY3QnICYmIGNlcnRpZmljYW50LnB1YikgZGF0YS5wdXNoKGNlcnRpZmljYW50LnB1YilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjZXJ0aWZpY2FudHMgPT09ICdvYmplY3QnICYmIGNlcnRpZmljYW50cy5wdWIpIHJldHVybiBjZXJ0aWZpY2FudHMucHViXG4gICAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoID4gMCA/IGRhdGEgOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9KSgpXG5cbiAgICAgIGlmICghY2VydGlmaWNhbnRzKSByZXR1cm4gY29uc29sZS5sb2coXCJObyBjZXJ0aWZpY2FudCBmb3VuZC5cIilcblxuICAgICAgY29uc3QgZXhwaXJ5ID0gb3B0LmV4cGlyeSAmJiAodHlwZW9mIG9wdC5leHBpcnkgPT09ICdudW1iZXInIHx8IHR5cGVvZiBvcHQuZXhwaXJ5ID09PSAnc3RyaW5nJykgPyBwYXJzZUZsb2F0KG9wdC5leHBpcnkpIDogbnVsbFxuICAgICAgY29uc3QgcmVhZFBvbGljeSA9IChwb2xpY3kgfHwge30pLnJlYWQgPyBwb2xpY3kucmVhZCA6IG51bGxcbiAgICAgIGNvbnN0IHdyaXRlUG9saWN5ID0gKHBvbGljeSB8fCB7fSkud3JpdGUgPyBwb2xpY3kud3JpdGUgOiB0eXBlb2YgcG9saWN5ID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHBvbGljeSkgfHwgcG9saWN5W1wiK1wiXSB8fCBwb2xpY3lbXCIjXCJdIHx8IHBvbGljeVtcIi5cIl0gfHwgcG9saWN5W1wiPVwiXSB8fCBwb2xpY3lbXCIqXCJdIHx8IHBvbGljeVtcIj5cIl0gfHwgcG9saWN5W1wiPFwiXSA/IHBvbGljeSA6IG51bGxcbiAgICAgIC8vIFRoZSBcImJsYWNrbGlzdFwiIGZlYXR1cmUgaXMgbm93IHJlbmFtZWQgdG8gXCJibG9ja1wiLiBXaHkgPyBCRUNBVVNFIEJMQUNLIExJVkVTIE1BVFRFUiFcbiAgICAgIC8vIFdlIGNhbiBub3cgdXNlIDMga2V5czogYmxvY2ssIGJsYWNrbGlzdCwgYmFuXG4gICAgICBjb25zdCBibG9jayA9IChvcHQgfHwge30pLmJsb2NrIHx8IChvcHQgfHwge30pLmJsYWNrbGlzdCB8fCAob3B0IHx8IHt9KS5iYW4gfHwge31cbiAgICAgIGNvbnN0IHJlYWRCbG9jayA9IGJsb2NrLnJlYWQgJiYgKHR5cGVvZiBibG9jay5yZWFkID09PSAnc3RyaW5nJyB8fCAoYmxvY2sucmVhZCB8fCB7fSlbJyMnXSkgPyBibG9jay5yZWFkIDogbnVsbFxuICAgICAgY29uc3Qgd3JpdGVCbG9jayA9IHR5cGVvZiBibG9jayA9PT0gJ3N0cmluZycgPyBibG9jayA6IGJsb2NrLndyaXRlICYmICh0eXBlb2YgYmxvY2sud3JpdGUgPT09ICdzdHJpbmcnIHx8IGJsb2NrLndyaXRlWycjJ10pID8gYmxvY2sud3JpdGUgOiBudWxsXG5cbiAgICAgIGlmICghcmVhZFBvbGljeSAmJiAhd3JpdGVQb2xpY3kpIHJldHVybiBjb25zb2xlLmxvZyhcIk5vIHBvbGljeSBmb3VuZC5cIilcblxuICAgICAgLy8gcmVzZXJ2ZWQga2V5czogYywgZSwgciwgdywgcmIsIHdiXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBjOiBjZXJ0aWZpY2FudHMsXG4gICAgICAgIC4uLihleHBpcnkgPyB7ZTogZXhwaXJ5fSA6IHt9KSwgLy8gaW5qZWN0IGV4cGlyeSBpZiBwb3NzaWJsZVxuICAgICAgICAuLi4ocmVhZFBvbGljeSA/IHtyOiByZWFkUG9saWN5IH0gIDoge30pLCAvLyBcInJcIiBzdGFuZHMgZm9yIHJlYWQsIHdoaWNoIG1lYW5zIHJlYWQgcGVybWlzc2lvbi5cbiAgICAgICAgLi4uKHdyaXRlUG9saWN5ID8ge3c6IHdyaXRlUG9saWN5fSA6IHt9KSwgLy8gXCJ3XCIgc3RhbmRzIGZvciB3cml0ZSwgd2hpY2ggbWVhbnMgd3JpdGUgcGVybWlzc2lvbi5cbiAgICAgICAgLi4uKHJlYWRCbG9jayA/IHtyYjogcmVhZEJsb2NrfSA6IHt9KSwgLy8gaW5qZWN0IFJFQUQgYmxvY2sgaWYgcG9zc2libGVcbiAgICAgICAgLi4uKHdyaXRlQmxvY2sgPyB7d2I6IHdyaXRlQmxvY2t9IDoge30pLCAvLyBpbmplY3QgV1JJVEUgYmxvY2sgaWYgcG9zc2libGVcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGNlcnRpZmljYXRlID0gYXdhaXQgU0VBLnNpZ24oZGF0YSwgYXV0aG9yaXR5LCBudWxsLCB7cmF3OjF9KVxuXG4gICAgICB2YXIgciA9IGNlcnRpZmljYXRlXG4gICAgICBpZighb3B0LnJhdyl7IHIgPSAnU0VBJytKU09OLnN0cmluZ2lmeShyKSB9XG4gICAgICBpZihjYil7IHRyeXsgY2IocikgfWNhdGNoKGUpe2NvbnNvbGUubG9nKGUpfSB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIFNFQS5lcnIgPSBlO1xuICAgICAgaWYoU0VBLnRocm93KXsgdGhyb3cgZSB9XG4gICAgICBpZihjYil7IGNiKCkgfVxuICAgICAgcmV0dXJuO1xuICAgIH19KTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU0VBLmNlcnRpZnk7XG4gIH0pKFVTRSwgJy4vY2VydGlmeScpO1xuXG4gIDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcbiAgICB2YXIgc2hpbSA9IFVTRSgnLi9zaGltJyk7XG4gICAgLy8gUHJhY3RpY2FsIGV4YW1wbGVzIGFib3V0IHVzYWdlIGZvdW5kIGluIHRlc3RzLlxuICAgIHZhciBTRUEgPSBVU0UoJy4vcm9vdCcpO1xuICAgIFNFQS53b3JrID0gVVNFKCcuL3dvcmsnKTtcbiAgICBTRUEuc2lnbiA9IFVTRSgnLi9zaWduJyk7XG4gICAgU0VBLnZlcmlmeSA9IFVTRSgnLi92ZXJpZnknKTtcbiAgICBTRUEuZW5jcnlwdCA9IFVTRSgnLi9lbmNyeXB0Jyk7XG4gICAgU0VBLmRlY3J5cHQgPSBVU0UoJy4vZGVjcnlwdCcpO1xuICAgIFNFQS5jZXJ0aWZ5ID0gVVNFKCcuL2NlcnRpZnknKTtcbiAgICAvL1NFQS5vcHQuYWVza2V5ID0gVVNFKCcuL2Flc2tleScpOyAvLyBub3Qgb2ZmaWNpYWwhIC8vIHRoaXMgY2F1c2VzIHByb2JsZW1zIGluIGxhdGVzdCBXZWJDcnlwdG8uXG5cbiAgICBTRUEucmFuZG9tID0gU0VBLnJhbmRvbSB8fCBzaGltLnJhbmRvbTtcblxuICAgIC8vIFRoaXMgaXMgQnVmZmVyIHVzZWQgaW4gU0VBIGFuZCB1c2FibGUgZnJvbSBHdW4vU0VBIGFwcGxpY2F0aW9uIGFsc28uXG4gICAgLy8gRm9yIGRvY3VtZW50YXRpb24gc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvYnVmZmVyLmh0bWxcbiAgICBTRUEuQnVmZmVyID0gU0VBLkJ1ZmZlciB8fCBVU0UoJy4vYnVmZmVyJyk7XG5cbiAgICAvLyBUaGVzZSBTRUEgZnVuY3Rpb25zIHN1cHBvcnQgbm93IG9ueSBQcm9taXNlcyBvclxuICAgIC8vIGFzeW5jL2F3YWl0IChjb21wYXRpYmxlKSBjb2RlLCB1c2UgdGhvc2UgbGlrZSBQcm9taXNlcy5cbiAgICAvL1xuICAgIC8vIENyZWF0ZXMgYSB3cmFwcGVyIGxpYnJhcnkgYXJvdW5kIFdlYiBDcnlwdG8gQVBJXG4gICAgLy8gZm9yIHZhcmlvdXMgQUVTLCBFQ0RTQSwgUEJLREYyIGZ1bmN0aW9ucyB3ZSBjYWxsZWQgYWJvdmUuXG4gICAgLy8gQ2FsY3VsYXRlIHB1YmxpYyBrZXkgS2V5SUQgYWthIFBHUHY0IChyZXN1bHQ6IDggYnl0ZXMgYXMgaGV4IHN0cmluZylcbiAgICBTRUEua2V5aWQgPSBTRUEua2V5aWQgfHwgKGFzeW5jIChwdWIpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGJhc2U2NCgnYmFzZTY0KHgpOmJhc2U2NCh5KScpID0+IHNoaW0uQnVmZmVyKHh5KVxuICAgICAgICBjb25zdCBwYiA9IHNoaW0uQnVmZmVyLmNvbmNhdChcbiAgICAgICAgICBwdWIucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKS5zcGxpdCgnLicpXG4gICAgICAgICAgLm1hcCgodCkgPT4gc2hpbS5CdWZmZXIuZnJvbSh0LCAnYmFzZTY0JykpXG4gICAgICAgIClcbiAgICAgICAgLy8gaWQgaXMgUEdQdjQgY29tcGxpYW50IHJhdyBrZXlcbiAgICAgICAgY29uc3QgaWQgPSBzaGltLkJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgIHNoaW0uQnVmZmVyLmZyb20oWzB4OTksIHBiLmxlbmd0aCAvIDB4MTAwLCBwYi5sZW5ndGggJSAweDEwMF0pLCBwYlxuICAgICAgICBdKVxuICAgICAgICBjb25zdCBzaGExID0gYXdhaXQgc2hhMWhhc2goaWQpXG4gICAgICAgIGNvbnN0IGhhc2ggPSBzaGltLkJ1ZmZlci5mcm9tKHNoYTEsICdiaW5hcnknKVxuICAgICAgICByZXR1cm4gaGFzaC50b1N0cmluZygnaGV4JywgaGFzaC5sZW5ndGggLSA4KSAgLy8gMTYtYml0IElEIGFzIGhleFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhlKVxuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gYWxsIGRvbmUhXG4gICAgLy8gT2J2aW91c2x5IGl0IGlzIG1pc3NpbmcgTUFOWSBuZWNlc3NhcnkgZmVhdHVyZXMuIFRoaXMgaXMgb25seSBhbiBhbHBoYSByZWxlYXNlLlxuICAgIC8vIFBsZWFzZSBleHBlcmltZW50IHdpdGggaXQsIGF1ZGl0IHdoYXQgSSd2ZSBkb25lIHNvIGZhciwgYW5kIGNvbXBsYWluIGFib3V0IHdoYXQgbmVlZHMgdG8gYmUgYWRkZWQuXG4gICAgLy8gU0VBIHNob3VsZCBiZSBhIGZ1bGwgc3VpdGUgdGhhdCBpcyBlYXN5IGFuZCBzZWFtbGVzcyB0byB1c2UuXG4gICAgLy8gQWdhaW4sIHNjcm9sbCBuYWVyIHRoZSB0b3AsIHdoZXJlIEkgcHJvdmlkZSBhbiBFWEFNUExFIG9mIGhvdyB0byBjcmVhdGUgYSB1c2VyIGFuZCBzaWduIGluLlxuICAgIC8vIE9uY2UgbG9nZ2VkIGluLCB0aGUgcmVzdCBvZiB0aGUgY29kZSB5b3UganVzdCByZWFkIGhhbmRsZWQgYXV0b21hdGljYWxseSBzaWduaW5nL3ZhbGlkYXRpbmcgZGF0YS5cbiAgICAvLyBCdXQgYWxsIG90aGVyIGJlaGF2aW9yIG5lZWRzIHRvIGJlIGVxdWFsbHkgZWFzeSwgbGlrZSBvcGluaW9uYXRlZCB3YXlzIG9mXG4gICAgLy8gQWRkaW5nIGZyaWVuZHMgKHRydXN0ZWQgcHVibGljIGtleXMpLCBzZW5kaW5nIHByaXZhdGUgbWVzc2FnZXMsIGV0Yy5cbiAgICAvLyBDaGVlcnMhIFRlbGwgbWUgd2hhdCB5b3UgdGhpbmsuXG4gICAgKChTRUEud2luZG93fHx7fSkuR1VOfHx7fSkuU0VBID0gU0VBO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTRUFcbiAgICAvLyAtLS0tLS0tLS0tLS0tLSBFTkQgU0VBIE1PRFVMRVMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAtLSBCRUdJTiBTRUErR1VOIE1PRFVMRVM6IEJVTkRMRUQgQlkgREVGQVVMVCBVTlRJTCBPVEhFUlMgVVNFIFNFQSBPTiBPV04gLS0tLS0tLVxuICB9KShVU0UsICcuL3NlYScpO1xuXG4gIDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcbiAgICB2YXIgU0VBID0gVVNFKCcuL3NlYScpLCBHdW4sIHU7XG4gICAgaWYoU0VBLndpbmRvdyl7XG4gICAgICBHdW4gPSBTRUEud2luZG93LkdVTiB8fCB7Y2hhaW46e319O1xuICAgIH0gZWxzZSB7XG4gICAgICBHdW4gPSBVU0UoKHUrJycgPT0gdHlwZW9mIE1PRFVMRT8nLic6JycpKycuL2d1bicsIDEpO1xuICAgIH1cbiAgICBTRUEuR1VOID0gR3VuO1xuXG4gICAgZnVuY3Rpb24gVXNlcihyb290KXsgXG4gICAgICB0aGlzLl8gPSB7JDogdGhpc307XG4gICAgfVxuICAgIFVzZXIucHJvdG90eXBlID0gKGZ1bmN0aW9uKCl7IGZ1bmN0aW9uIEYoKXt9OyBGLnByb3RvdHlwZSA9IEd1bi5jaGFpbjsgcmV0dXJuIG5ldyBGKCkgfSgpKSAvLyBPYmplY3QuY3JlYXRlIHBvbHlmaWxsXG4gICAgVXNlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVc2VyO1xuXG4gICAgLy8gbGV0J3MgZXh0ZW5kIHRoZSBndW4gY2hhaW4gd2l0aCBhIGB1c2VyYCBmdW5jdGlvbi5cbiAgICAvLyBvbmx5IG9uZSB1c2VyIGNhbiBiZSBsb2dnZWQgaW4gYXQgYSB0aW1lLCBwZXIgZ3VuIGluc3RhbmNlLlxuICAgIEd1bi5jaGFpbi51c2VyID0gZnVuY3Rpb24ocHViKXtcbiAgICAgIHZhciBndW4gPSB0aGlzLCByb290ID0gZ3VuLmJhY2soLTEpLCB1c2VyO1xuICAgICAgaWYocHViKXtcbiAgICAgICAgcHViID0gU0VBLm9wdC5wdWIoKHB1Yi5ffHwnJylbJyMnXSkgfHwgcHViO1xuICAgICAgICByZXR1cm4gcm9vdC5nZXQoJ34nK3B1Yik7XG4gICAgICB9XG4gICAgICBpZih1c2VyID0gcm9vdC5iYWNrKCd1c2VyJykpeyByZXR1cm4gdXNlciB9XG4gICAgICB2YXIgcm9vdCA9IChyb290Ll8pLCBhdCA9IHJvb3QsIHV1aWQgPSBhdC5vcHQudXVpZCB8fCBsZXg7XG4gICAgICAoYXQgPSAodXNlciA9IGF0LnVzZXIgPSBndW4uY2hhaW4obmV3IFVzZXIpKS5fKS5vcHQgPSB7fTtcbiAgICAgIGF0Lm9wdC51dWlkID0gZnVuY3Rpb24oY2Ipe1xuICAgICAgICB2YXIgaWQgPSB1dWlkKCksIHB1YiA9IHJvb3QudXNlcjtcbiAgICAgICAgaWYoIXB1YiB8fCAhKHB1YiA9IHB1Yi5pcykgfHwgIShwdWIgPSBwdWIucHViKSl7IHJldHVybiBpZCB9XG4gICAgICAgIGlkID0gJ34nICsgcHViICsgJy8nICsgaWQ7XG4gICAgICAgIGlmKGNiICYmIGNiLmNhbGwpeyBjYihudWxsLCBpZCkgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGV4KCl7IHJldHVybiBHdW4uc3RhdGUoKS50b1N0cmluZygzNikucmVwbGFjZSgnLicsJycpIH1cbiAgICBHdW4uVXNlciA9IFVzZXI7XG4gICAgVXNlci5HVU4gPSBHdW47XG4gICAgVXNlci5TRUEgPSBHdW4uU0VBID0gU0VBO1xuICAgIG1vZHVsZS5leHBvcnRzID0gVXNlcjtcbiAgfSkoVVNFLCAnLi91c2VyJyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciB1LCBHdW4gPSAoJycrdSAhPSB0eXBlb2YgR1VOKT8gKEdVTnx8e2NoYWluOnt9fSkgOiBVU0UoKCcnK3UgPT09IHR5cGVvZiBNT0RVTEU/Jy4nOicnKSsnLi9ndW4nLCAxKTtcbiAgICBHdW4uY2hhaW4udGhlbiA9IGZ1bmN0aW9uKGNiLCBvcHQpe1xuICAgICAgdmFyIGd1biA9IHRoaXMsIHAgPSAobmV3IFByb21pc2UoZnVuY3Rpb24ocmVzLCByZWope1xuICAgICAgICBndW4ub25jZShyZXMsIG9wdCk7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gY2I/IHAudGhlbihjYikgOiBwO1xuICAgIH1cbiAgfSkoVVNFLCAnLi90aGVuJyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBVc2VyID0gVVNFKCcuL3VzZXInKSwgU0VBID0gVXNlci5TRUEsIEd1biA9IFVzZXIuR1VOLCBub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gICAgLy8gV2VsbCBmaXJzdCB3ZSBoYXZlIHRvIGFjdHVhbGx5IGNyZWF0ZSBhIHVzZXIuIFRoYXQgaXMgd2hhdCB0aGlzIGZ1bmN0aW9uIGRvZXMuXG4gICAgVXNlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oLi4uYXJncyl7XG4gICAgICB2YXIgcGFpciA9IHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiAoYXJnc1swXS5wdWIgfHwgYXJnc1swXS5lcHViKSA/IGFyZ3NbMF0gOiB0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcgJiYgKGFyZ3NbMV0ucHViIHx8IGFyZ3NbMV0uZXB1YikgPyBhcmdzWzFdIDogbnVsbDtcbiAgICAgIHZhciBhbGlhcyA9IHBhaXIgJiYgKHBhaXIucHViIHx8IHBhaXIuZXB1YikgPyBwYWlyLnB1YiA6IHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyA/IGFyZ3NbMF0gOiBudWxsO1xuICAgICAgdmFyIHBhc3MgPSBwYWlyICYmIChwYWlyLnB1YiB8fCBwYWlyLmVwdWIpID8gcGFpciA6IGFsaWFzICYmIHR5cGVvZiBhcmdzWzFdID09PSAnc3RyaW5nJyA/IGFyZ3NbMV0gOiBudWxsO1xuICAgICAgdmFyIGNiID0gYXJncy5maWx0ZXIoYXJnID0+IHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpWzBdIHx8IG51bGw7IC8vIGNiIG5vdyBjYW4gc3RhbmQgYW55d2hlcmUsIGFmdGVyIGFsaWFzL3Bhc3Mgb3IgcGFpclxuICAgICAgdmFyIG9wdCA9IGFyZ3MgJiYgYXJncy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoLTFdID09PSAnb2JqZWN0JyA/IGFyZ3NbYXJncy5sZW5ndGgtMV0gOiB7fTsgLy8gb3B0IGlzIGFsd2F5cyB0aGUgbGFzdCBwYXJhbWV0ZXIgd2hpY2ggdHlwZW9mID09PSAnb2JqZWN0JyBhbmQgc3RhbmRzIGFmdGVyIGNiXG4gICAgICBcbiAgICAgIHZhciBndW4gPSB0aGlzLCBjYXQgPSAoZ3VuLl8pLCByb290ID0gZ3VuLmJhY2soLTEpO1xuICAgICAgY2IgPSBjYiB8fCBub29wO1xuICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgaWYoZmFsc2UgIT09IG9wdC5jaGVjayl7XG4gICAgICAgIHZhciBlcnI7XG4gICAgICAgIGlmKCFhbGlhcyl7IGVyciA9IFwiTm8gdXNlci5cIiB9XG4gICAgICAgIGlmKChwYXNzfHwnJykubGVuZ3RoIDwgOCl7IGVyciA9IFwiUGFzc3dvcmQgdG9vIHNob3J0IVwiIH1cbiAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICBjYih7ZXJyOiBHdW4ubG9nKGVycil9KTtcbiAgICAgICAgICByZXR1cm4gZ3VuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihjYXQuaW5nKXtcbiAgICAgICAgKGNiIHx8IG5vb3ApKHtlcnI6IEd1bi5sb2coXCJVc2VyIGlzIGFscmVhZHkgYmVpbmcgY3JlYXRlZCBvciBhdXRoZW50aWNhdGVkIVwiKSwgd2FpdDogdHJ1ZX0pO1xuICAgICAgICByZXR1cm4gZ3VuO1xuICAgICAgfVxuICAgICAgY2F0LmluZyA9IHRydWU7XG4gICAgICB2YXIgYWN0ID0ge30sIHU7XG4gICAgICBhY3QuYSA9IGZ1bmN0aW9uKHB1YnMpe1xuICAgICAgICBhY3QucHVicyA9IHB1YnM7XG4gICAgICAgIGlmKHB1YnMgJiYgIW9wdC5hbHJlYWR5KXtcbiAgICAgICAgICAvLyBJZiB3ZSBjYW4gZW5mb3JjZSB0aGF0IGEgdXNlciBuYW1lIGlzIGFscmVhZHkgdGFrZW4sIGl0IG1pZ2h0IGJlIG5pY2UgdG8gdHJ5LCBidXQgdGhpcyBpcyBub3QgZ3VhcmFudGVlZC5cbiAgICAgICAgICB2YXIgYWNrID0ge2VycjogR3VuLmxvZygnVXNlciBhbHJlYWR5IGNyZWF0ZWQhJyl9O1xuICAgICAgICAgIGNhdC5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAoY2IgfHwgbm9vcCkoYWNrKTtcbiAgICAgICAgICBndW4ubGVhdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWN0LnNhbHQgPSBTdHJpbmcucmFuZG9tKDY0KTsgLy8gcHNldWRvLXJhbmRvbWx5IGNyZWF0ZSBhIHNhbHQsIHRoZW4gdXNlIFBCS0RGMiBmdW5jdGlvbiB0byBleHRlbmQgdGhlIHBhc3N3b3JkIHdpdGggaXQuXG4gICAgICAgIFNFQS53b3JrKHBhc3MsIGFjdC5zYWx0LCBhY3QuYik7IC8vIHRoaXMgd2lsbCB0YWtlIHNvbWUgc2hvcnQgYW1vdW50IG9mIHRpbWUgdG8gcHJvZHVjZSBhIHByb29mLCB3aGljaCBzbG93cyBicnV0ZSBmb3JjZSBhdHRhY2tzLlxuICAgICAgfVxuICAgICAgYWN0LmIgPSBmdW5jdGlvbihwcm9vZil7XG4gICAgICAgIGFjdC5wcm9vZiA9IHByb29mO1xuICAgICAgICBwYWlyID8gYWN0LmMocGFpcikgOiBTRUEucGFpcihhY3QuYykgLy8gZ2VuZXJhdGUgYSBicmFuZCBuZXcga2V5IHBhaXIgb3IgdXNlIHRoZSBleGlzdGluZy5cbiAgICAgIH1cbiAgICAgIGFjdC5jID0gZnVuY3Rpb24ocGFpcil7XG4gICAgICAgIHZhciB0bXBcbiAgICAgICAgYWN0LnBhaXIgPSBwYWlyIHx8IHt9O1xuICAgICAgICBpZih0bXAgPSBjYXQucm9vdC51c2VyKXtcbiAgICAgICAgICB0bXAuXy5zZWEgPSBwYWlyO1xuICAgICAgICAgIHRtcC5pcyA9IHtwdWI6IHBhaXIucHViLCBlcHViOiBwYWlyLmVwdWIsIGFsaWFzOiBhbGlhc307XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIHVzZXIncyBwdWJsaWMga2V5IGRvZXNuJ3QgbmVlZCB0byBiZSBzaWduZWQuIEJ1dCBldmVyeXRoaW5nIGVsc2UgbmVlZHMgdG8gYmUgc2lnbmVkIHdpdGggaXQhIC8vIHdlIGhhdmUgbm93IGF1dG9tYXRlZCBpdCEgY2xlYW4gdXAgdGhlc2UgZXh0cmEgc3RlcHMgbm93IVxuICAgICAgICBhY3QuZGF0YSA9IHtwdWI6IHBhaXIucHVifTtcbiAgICAgICAgYWN0LmQoKTtcbiAgICAgIH1cbiAgICAgIGFjdC5kID0gZnVuY3Rpb24oKXtcbiAgICAgICAgYWN0LmRhdGEuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgYWN0LmUoKTtcbiAgICAgIH1cbiAgICAgIGFjdC5lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgYWN0LmRhdGEuZXB1YiA9IGFjdC5wYWlyLmVwdWI7IFxuICAgICAgICBTRUEuZW5jcnlwdCh7cHJpdjogYWN0LnBhaXIucHJpdiwgZXByaXY6IGFjdC5wYWlyLmVwcml2fSwgYWN0LnByb29mLCBhY3QuZiwge3JhdzoxfSk7IC8vIHRvIGtlZXAgdGhlIHByaXZhdGUga2V5IHNhZmUsIHdlIEFFUyBlbmNyeXB0IGl0IHdpdGggdGhlIHByb29mIG9mIHdvcmshXG4gICAgICB9XG4gICAgICBhY3QuZiA9IGZ1bmN0aW9uKGF1dGgpe1xuICAgICAgICBhY3QuZGF0YS5hdXRoID0gSlNPTi5zdHJpbmdpZnkoe2VrOiBhdXRoLCBzOiBhY3Quc2FsdH0pOyBcbiAgICAgICAgYWN0LmcoYWN0LmRhdGEuYXV0aCk7XG4gICAgICB9XG4gICAgICBhY3QuZyA9IGZ1bmN0aW9uKGF1dGgpeyB2YXIgdG1wO1xuICAgICAgICBhY3QuZGF0YS5hdXRoID0gYWN0LmRhdGEuYXV0aCB8fCBhdXRoO1xuICAgICAgICByb290LmdldCh0bXAgPSAnficrYWN0LnBhaXIucHViKS5wdXQoYWN0LmRhdGEpLm9uKGFjdC5oKTsgLy8gYXdlc29tZSwgbm93IHdlIGNhbiBhY3R1YWxseSBzYXZlIHRoZSB1c2VyIHdpdGggdGhlaXIgcHVibGljIGtleSBhcyB0aGVpciBJRC5cbiAgICAgICAgdmFyIGxpbmsgPSB7fTsgbGlua1t0bXBdID0geycjJzogdG1wfTsgcm9vdC5nZXQoJ35AJythbGlhcykucHV0KGxpbmspLmdldCh0bXApLm9uKGFjdC5pKTsgLy8gbmV4dCB1cCwgd2Ugd2FudCB0byBhc3NvY2lhdGUgdGhlIGFsaWFzIHdpdGggdGhlIHB1YmxpYyBrZXkuIFNvIHdlIGFkZCBpdCB0byB0aGUgYWxpYXMgbGlzdC5cbiAgICAgIH1cbiAgICAgIGFjdC5oID0gZnVuY3Rpb24oZGF0YSwga2V5LCBtc2csIGV2ZSl7XG4gICAgICAgIGV2ZS5vZmYoKTsgYWN0Lmgub2sgPSAxOyBhY3QuaSgpO1xuICAgICAgfVxuICAgICAgYWN0LmkgPSBmdW5jdGlvbihkYXRhLCBrZXksIG1zZywgZXZlKXtcbiAgICAgICAgaWYoZXZlKXsgYWN0Lmkub2sgPSAxOyBldmUub2ZmKCkgfVxuICAgICAgICBpZighYWN0Lmgub2sgfHwgIWFjdC5pLm9rKXsgcmV0dXJuIH1cbiAgICAgICAgY2F0LmluZyA9IGZhbHNlO1xuICAgICAgICBjYih7b2s6IDAsIHB1YjogYWN0LnBhaXIucHVifSk7IC8vIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgaGFzIGJlZW4gY3JlYXRlZC4gKE5vdGU6IG9rID0gMCBiZWNhdXNlIHdlIGRpZG4ndCB3YWl0IGZvciBkaXNrIHRvIGFjaylcbiAgICAgICAgaWYobm9vcCA9PT0gY2IpeyBwYWlyID8gZ3VuLmF1dGgocGFpcikgOiBndW4uYXV0aChhbGlhcywgcGFzcykgfSAvLyBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWQsIGF1dG8tbG9naW4gYWZ0ZXIgc2lnbmluZyB1cC5cbiAgICAgIH1cbiAgICAgIHJvb3QuZ2V0KCd+QCcrYWxpYXMpLm9uY2UoYWN0LmEpO1xuICAgICAgcmV0dXJuIGd1bjtcbiAgICB9XG4gICAgVXNlci5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbihvcHQsIGNiKXtcbiAgICAgIHZhciBndW4gPSB0aGlzLCB1c2VyID0gKGd1bi5iYWNrKC0xKS5fKS51c2VyO1xuICAgICAgaWYodXNlcil7XG4gICAgICAgIGRlbGV0ZSB1c2VyLmlzO1xuICAgICAgICBkZWxldGUgdXNlci5fLmlzO1xuICAgICAgICBkZWxldGUgdXNlci5fLnNlYTtcbiAgICAgIH1cbiAgICAgIGlmKFNFQS53aW5kb3cpe1xuICAgICAgICB0cnl7dmFyIHNTID0ge307XG4gICAgICAgIHNTID0gU0VBLndpbmRvdy5zZXNzaW9uU3RvcmFnZTtcbiAgICAgICAgZGVsZXRlIHNTLnJlY2FsbDtcbiAgICAgICAgZGVsZXRlIHNTLnBhaXI7XG4gICAgICAgIH1jYXRjaChlKXt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGd1bjtcbiAgICB9XG4gIH0pKFVTRSwgJy4vY3JlYXRlJyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBVc2VyID0gVVNFKCcuL3VzZXInKSwgU0VBID0gVXNlci5TRUEsIEd1biA9IFVzZXIuR1VOLCBub29wID0gZnVuY3Rpb24oKXt9O1xuICAgIC8vIG5vdyB0aGF0IHdlIGhhdmUgY3JlYXRlZCBhIHVzZXIsIHdlIHdhbnQgdG8gYXV0aGVudGljYXRlIHRoZW0hXG4gICAgVXNlci5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKC4uLmFyZ3MpeyAvLyBUT0RPOiB0aGlzIFBSIHdpdGggYXJndW1lbnRzIG5lZWQgdG8gYmUgY2xlYW5lZCB1cCAvIHJlZmFjdG9yZWQuXG4gICAgICB2YXIgcGFpciA9IHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiAoYXJnc1swXS5wdWIgfHwgYXJnc1swXS5lcHViKSA/IGFyZ3NbMF0gOiB0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcgJiYgKGFyZ3NbMV0ucHViIHx8IGFyZ3NbMV0uZXB1YikgPyBhcmdzWzFdIDogbnVsbDtcbiAgICAgIHZhciBhbGlhcyA9ICFwYWlyICYmIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyA/IGFyZ3NbMF0gOiBudWxsO1xuICAgICAgdmFyIHBhc3MgPSAoYWxpYXMgfHwgKHBhaXIgJiYgIShwYWlyLnByaXYgJiYgcGFpci5lcHJpdikpKSAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gJ3N0cmluZycgPyBhcmdzWzFdIDogbnVsbDtcbiAgICAgIHZhciBjYiA9IGFyZ3MuZmlsdGVyKGFyZyA9PiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKVswXSB8fCBudWxsOyAvLyBjYiBub3cgY2FuIHN0YW5kIGFueXdoZXJlLCBhZnRlciBhbGlhcy9wYXNzIG9yIHBhaXJcbiAgICAgIHZhciBvcHQgPSBhcmdzICYmIGFyZ3MubGVuZ3RoID4gMSAmJiB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aC0xXSA9PT0gJ29iamVjdCcgPyBhcmdzW2FyZ3MubGVuZ3RoLTFdIDoge307IC8vIG9wdCBpcyBhbHdheXMgdGhlIGxhc3QgcGFyYW1ldGVyIHdoaWNoIHR5cGVvZiA9PT0gJ29iamVjdCcgYW5kIHN0YW5kcyBhZnRlciBjYlxuICAgICAgXG4gICAgICB2YXIgZ3VuID0gdGhpcywgY2F0ID0gKGd1bi5fKSwgcm9vdCA9IGd1bi5iYWNrKC0xKTtcbiAgICAgIFxuICAgICAgaWYoY2F0LmluZyl7XG4gICAgICAgIChjYiB8fCBub29wKSh7ZXJyOiBHdW4ubG9nKFwiVXNlciBpcyBhbHJlYWR5IGJlaW5nIGNyZWF0ZWQgb3IgYXV0aGVudGljYXRlZCFcIiksIHdhaXQ6IHRydWV9KTtcbiAgICAgICAgcmV0dXJuIGd1bjtcbiAgICAgIH1cbiAgICAgIGNhdC5pbmcgPSB0cnVlO1xuICAgICAgXG4gICAgICB2YXIgYWN0ID0ge30sIHUsIHRyaWVzID0gOTtcbiAgICAgIGFjdC5hID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIGlmKCFkYXRhKXsgcmV0dXJuIGFjdC5iKCkgfVxuICAgICAgICBpZighZGF0YS5wdWIpe1xuICAgICAgICAgIHZhciB0bXAgPSBbXTsgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbihrKXsgaWYoJ18nPT1rKXsgcmV0dXJuIH0gdG1wLnB1c2goZGF0YVtrXSkgfSlcbiAgICAgICAgICByZXR1cm4gYWN0LmIodG1wKTtcbiAgICAgICAgfVxuICAgICAgICBpZihhY3QubmFtZSl7IHJldHVybiBhY3QuZihkYXRhKSB9XG4gICAgICAgIGFjdC5jKChhY3QuZGF0YSA9IGRhdGEpLmF1dGgpO1xuICAgICAgfVxuICAgICAgYWN0LmIgPSBmdW5jdGlvbihsaXN0KXtcbiAgICAgICAgdmFyIGdldCA9IChhY3QubGlzdCA9IChhY3QubGlzdHx8W10pLmNvbmNhdChsaXN0fHxbXSkpLnNoaWZ0KCk7XG4gICAgICAgIGlmKHUgPT09IGdldCl7XG4gICAgICAgICAgaWYoYWN0Lm5hbWUpeyByZXR1cm4gYWN0LmVycignWW91ciB1c2VyIGFjY291bnQgaXMgbm90IHB1Ymxpc2hlZCBmb3IgZEFwcHMgdG8gYWNjZXNzLCBwbGVhc2UgY29uc2lkZXIgc3luY2luZyBpdCBvbmxpbmUsIG9yIGFsbG93aW5nIGxvY2FsIGFjY2VzcyBieSBhZGRpbmcgeW91ciBkZXZpY2UgYXMgYSBwZWVyLicpIH1cbiAgICAgICAgICBpZihhbGlhcyAmJiB0cmllcy0tKXtcbiAgICAgICAgICAgIHJvb3QuZ2V0KCd+QCcrYWxpYXMpLm9uY2UoYWN0LmEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWN0LmVycignV3JvbmcgdXNlciBvciBwYXNzd29yZC4nKSBcbiAgICAgICAgfVxuICAgICAgICByb290LmdldChnZXQpLm9uY2UoYWN0LmEpO1xuICAgICAgfVxuICAgICAgYWN0LmMgPSBmdW5jdGlvbihhdXRoKXtcbiAgICAgICAgaWYodSA9PT0gYXV0aCl7IHJldHVybiBhY3QuYigpIH1cbiAgICAgICAgaWYoJ3N0cmluZycgPT0gdHlwZW9mIGF1dGgpeyByZXR1cm4gYWN0LmMob2JqX2lmeShhdXRoKSkgfSAvLyBpbiBjYXNlIG9mIGxlZ2FjeVxuICAgICAgICBTRUEud29yayhwYXNzLCAoYWN0LmF1dGggPSBhdXRoKS5zLCBhY3QuZCwgYWN0LmVuYyk7IC8vIHRoZSBwcm9vZiBvZiB3b3JrIGlzIGV2aWRlbmNlIHRoYXQgd2UndmUgc3BlbnQgc29tZSB0aW1lL2VmZm9ydCB0cnlpbmcgdG8gbG9nIGluLCB0aGlzIHNsb3dzIGJydXRlIGZvcmNlLlxuICAgICAgfVxuICAgICAgYWN0LmQgPSBmdW5jdGlvbihwcm9vZil7XG4gICAgICAgIFNFQS5kZWNyeXB0KGFjdC5hdXRoLmVrLCBwcm9vZiwgYWN0LmUsIGFjdC5lbmMpO1xuICAgICAgfVxuICAgICAgYWN0LmUgPSBmdW5jdGlvbihoYWxmKXtcbiAgICAgICAgaWYodSA9PT0gaGFsZil7XG4gICAgICAgICAgaWYoIWFjdC5lbmMpeyAvLyB0cnkgb2xkIGZvcm1hdFxuICAgICAgICAgICAgYWN0LmVuYyA9IHtlbmNvZGU6ICd1dGY4J307XG4gICAgICAgICAgICByZXR1cm4gYWN0LmMoYWN0LmF1dGgpO1xuICAgICAgICAgIH0gYWN0LmVuYyA9IG51bGw7IC8vIGVuZCBiYWNrd2FyZHNcbiAgICAgICAgICByZXR1cm4gYWN0LmIoKTtcbiAgICAgICAgfVxuICAgICAgICBhY3QuaGFsZiA9IGhhbGY7XG4gICAgICAgIGFjdC5mKGFjdC5kYXRhKTtcbiAgICAgIH1cbiAgICAgIGFjdC5mID0gZnVuY3Rpb24ocGFpcil7XG4gICAgICAgIHZhciBoYWxmID0gYWN0LmhhbGYgfHwge30sIGRhdGEgPSBhY3QuZGF0YSB8fCB7fTtcbiAgICAgICAgYWN0LmcoYWN0LmxvbCA9IHtwdWI6IHBhaXIucHViIHx8IGRhdGEucHViLCBlcHViOiBwYWlyLmVwdWIgfHwgZGF0YS5lcHViLCBwcml2OiBwYWlyLnByaXYgfHwgaGFsZi5wcml2LCBlcHJpdjogcGFpci5lcHJpdiB8fCBoYWxmLmVwcml2fSk7XG4gICAgICB9XG4gICAgICBhY3QuZyA9IGZ1bmN0aW9uKHBhaXIpe1xuICAgICAgICBpZighcGFpciB8fCAhcGFpci5wdWIgfHwgIXBhaXIuZXB1Yil7IHJldHVybiBhY3QuYigpIH1cbiAgICAgICAgYWN0LnBhaXIgPSBwYWlyO1xuICAgICAgICB2YXIgdXNlciA9IChyb290Ll8pLnVzZXIsIGF0ID0gKHVzZXIuXyk7XG4gICAgICAgIHZhciB0bXAgPSBhdC50YWc7XG4gICAgICAgIHZhciB1cHQgPSBhdC5vcHQ7XG4gICAgICAgIGF0ID0gdXNlci5fID0gcm9vdC5nZXQoJ34nK3BhaXIucHViKS5fO1xuICAgICAgICBhdC5vcHQgPSB1cHQ7XG4gICAgICAgIC8vIGFkZCBvdXIgY3JlZGVudGlhbHMgaW4tbWVtb3J5IG9ubHkgdG8gb3VyIHJvb3QgdXNlciBpbnN0YW5jZVxuICAgICAgICB1c2VyLmlzID0ge3B1YjogcGFpci5wdWIsIGVwdWI6IHBhaXIuZXB1YiwgYWxpYXM6IGFsaWFzIHx8IHBhaXIucHVifTtcbiAgICAgICAgYXQuc2VhID0gYWN0LnBhaXI7XG4gICAgICAgIGNhdC5pbmcgPSBmYWxzZTtcbiAgICAgICAgdHJ5e2lmKHBhc3MgJiYgdSA9PSAob2JqX2lmeShjYXQucm9vdC5ncmFwaFsnficrcGFpci5wdWJdLmF1dGgpfHwnJylbJzonXSl7IG9wdC5zaHVmZmxlID0gb3B0LmNoYW5nZSA9IHBhc3M7IH0gfWNhdGNoKGUpe30gLy8gbWlncmF0ZSBVVEY4ICYgU2h1ZmZsZSFcbiAgICAgICAgb3B0LmNoYW5nZT8gYWN0LnooKSA6IChjYiB8fCBub29wKShhdCk7XG4gICAgICAgIGlmKFNFQS53aW5kb3cgJiYgKChndW4uYmFjaygndXNlcicpLl8pLm9wdHx8b3B0KS5yZW1lbWJlcil7XG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBuZWVkcyB0byBiZSBtb2R1bGFyLlxuICAgICAgICAgIHRyeXt2YXIgc1MgPSB7fTtcbiAgICAgICAgICBzUyA9IFNFQS53aW5kb3cuc2Vzc2lvblN0b3JhZ2U7IC8vIFRPRE86IEZJWCBCVUcgcHV0dGluZyBvbiBgLmlzYCFcbiAgICAgICAgICBzUy5yZWNhbGwgPSB0cnVlO1xuICAgICAgICAgIHNTLnBhaXIgPSBKU09OLnN0cmluZ2lmeShwYWlyKTsgLy8gYXV0aCB1c2luZyBwYWlyIGlzIG1vcmUgcmVsaWFibGUgdGhhbiBhbGlhcy9wYXNzXG4gICAgICAgICAgfWNhdGNoKGUpe31cbiAgICAgICAgfVxuICAgICAgICB0cnl7XG4gICAgICAgICAgaWYocm9vdC5fLnRhZy5hdXRoKXsgLy8gYXV0aCBoYW5kbGUgbWlnaHQgbm90IGJlIHJlZ2lzdGVyZWQgeWV0XG4gICAgICAgICAgKHJvb3QuXykub24oJ2F1dGgnLCBhdCkgLy8gVE9ETzogRGVwcmVjYXRlIHRoaXMsIGVtaXQgb24gdXNlciBpbnN0ZWFkISBVcGRhdGUgZG9jcyB3aGVuIHlvdSBkby5cbiAgICAgICAgICB9IGVsc2UgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IChyb290Ll8pLm9uKCdhdXRoJywgYXQpIH0sMSkgfSAvLyBpZiBub3QsIGhhY2tpbHkgYWRkIGEgdGltZW91dC5cbiAgICAgICAgICAvL2F0Lm9uKCdhdXRoJywgYXQpIC8vIEFycmdoLCB0aGlzIGRvZXNuJ3Qgd29yayB3aXRob3V0IGV2ZW50IFwibWVyZ2VcIiBjb2RlLCBidXQgXCJtZXJnZVwiIGNvZGUgY2F1c2VzIHN0YWNrIG92ZXJmbG93IGFuZCBjcmFzaGVzIGFmdGVyIGxvZ2dpbmcgaW4gJiB0cnlpbmcgdG8gd3JpdGUgZGF0YS5cbiAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgIEd1bi5sb2coXCJZb3VyICdhdXRoJyBjYWxsYmFjayBjcmFzaGVkIHdpdGg6XCIsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhY3QuaCA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICBpZighZGF0YSl7IHJldHVybiBhY3QuYigpIH1cbiAgICAgICAgYWxpYXMgPSBkYXRhLmFsaWFzXG4gICAgICAgIGlmKCFhbGlhcylcbiAgICAgICAgICBhbGlhcyA9IGRhdGEuYWxpYXMgPSBcIn5cIiArIHBhaXIucHViICAgICAgICBcbiAgICAgICAgaWYoIWRhdGEuYXV0aCl7XG4gICAgICAgICAgcmV0dXJuIGFjdC5nKHBhaXIpO1xuICAgICAgICB9XG4gICAgICAgIHBhaXIgPSBudWxsO1xuICAgICAgICBhY3QuYygoYWN0LmRhdGEgPSBkYXRhKS5hdXRoKTtcbiAgICAgIH1cbiAgICAgIGFjdC56ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gcGFzc3dvcmQgdXBkYXRlIHNvIGVuY3J5cHQgcHJpdmF0ZSBrZXkgdXNpbmcgbmV3IHB3ZCArIHNhbHRcbiAgICAgICAgYWN0LnNhbHQgPSBTdHJpbmcucmFuZG9tKDY0KTsgLy8gcHNldWRvLXJhbmRvbVxuICAgICAgICBTRUEud29yayhvcHQuY2hhbmdlLCBhY3Quc2FsdCwgYWN0LnkpO1xuICAgICAgfVxuICAgICAgYWN0LnkgPSBmdW5jdGlvbihwcm9vZil7XG4gICAgICAgIFNFQS5lbmNyeXB0KHtwcml2OiBhY3QucGFpci5wcml2LCBlcHJpdjogYWN0LnBhaXIuZXByaXZ9LCBwcm9vZiwgYWN0LngsIHtyYXc6MX0pO1xuICAgICAgfVxuICAgICAgYWN0LnggPSBmdW5jdGlvbihhdXRoKXtcbiAgICAgICAgYWN0LncoSlNPTi5zdHJpbmdpZnkoe2VrOiBhdXRoLCBzOiBhY3Quc2FsdH0pKTtcbiAgICAgIH1cbiAgICAgIGFjdC53ID0gZnVuY3Rpb24oYXV0aCl7XG4gICAgICAgIGlmKG9wdC5zaHVmZmxlKXsgLy8gZGVsZXRlIGluIGZ1dHVyZSFcbiAgICAgICAgICBjb25zb2xlLmxvZygnbWlncmF0ZSBjb3JlIGFjY291bnQgZnJvbSBVVEY4ICYgc2h1ZmZsZScpO1xuICAgICAgICAgIHZhciB0bXAgPSB7fTsgT2JqZWN0LmtleXMoYWN0LmRhdGEpLmZvckVhY2goZnVuY3Rpb24oayl7IHRtcFtrXSA9IGFjdC5kYXRhW2tdIH0pO1xuICAgICAgICAgIGRlbGV0ZSB0bXAuXztcbiAgICAgICAgICB0bXAuYXV0aCA9IGF1dGg7XG4gICAgICAgICAgcm9vdC5nZXQoJ34nK2FjdC5wYWlyLnB1YikucHV0KHRtcCk7XG4gICAgICAgIH0gLy8gZW5kIGRlbGV0ZVxuICAgICAgICByb290LmdldCgnficrYWN0LnBhaXIucHViKS5nZXQoJ2F1dGgnKS5wdXQoYXV0aCwgY2IgfHwgbm9vcCk7XG4gICAgICB9XG4gICAgICBhY3QuZXJyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciBhY2sgPSB7ZXJyOiBHdW4ubG9nKGUgfHwgJ1VzZXIgY2Fubm90IGJlIGZvdW5kIScpfTtcbiAgICAgICAgY2F0LmluZyA9IGZhbHNlO1xuICAgICAgICAoY2IgfHwgbm9vcCkoYWNrKTtcbiAgICAgIH1cbiAgICAgIGFjdC5wbHVnaW4gPSBmdW5jdGlvbihuYW1lKXtcbiAgICAgICAgaWYoIShhY3QubmFtZSA9IG5hbWUpKXsgcmV0dXJuIGFjdC5lcnIoKSB9XG4gICAgICAgIHZhciB0bXAgPSBbbmFtZV07XG4gICAgICAgIGlmKCd+JyAhPT0gbmFtZVswXSl7XG4gICAgICAgICAgdG1wWzFdID0gJ34nK25hbWU7XG4gICAgICAgICAgdG1wWzJdID0gJ35AJytuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGFjdC5iKHRtcCk7XG4gICAgICB9XG4gICAgICBpZihwYWlyKXtcbiAgICAgICAgaWYocGFpci5wcml2ICYmIHBhaXIuZXByaXYpXG4gICAgICAgICAgYWN0LmcocGFpcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByb290LmdldCgnficrcGFpci5wdWIpLm9uY2UoYWN0LmgpO1xuICAgICAgfSBlbHNlXG4gICAgICBpZihhbGlhcyl7XG4gICAgICAgIHJvb3QuZ2V0KCd+QCcrYWxpYXMpLm9uY2UoYWN0LmEpO1xuICAgICAgfSBlbHNlXG4gICAgICBpZighYWxpYXMgJiYgIXBhc3Mpe1xuICAgICAgICBTRUEubmFtZShhY3QucGx1Z2luKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBndW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9ial9pZnkobyl7XG4gICAgICBpZignc3RyaW5nJyAhPSB0eXBlb2Ygbyl7IHJldHVybiBvIH1cbiAgICAgIHRyeXtvID0gSlNPTi5wYXJzZShvKTtcbiAgICAgIH1jYXRjaChlKXtvPXt9fTtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgfSkoVVNFLCAnLi9hdXRoJyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBVc2VyID0gVVNFKCcuL3VzZXInKSwgU0VBID0gVXNlci5TRUEsIEd1biA9IFVzZXIuR1VOO1xuICAgIFVzZXIucHJvdG90eXBlLnJlY2FsbCA9IGZ1bmN0aW9uKG9wdCwgY2Ipe1xuICAgICAgdmFyIGd1biA9IHRoaXMsIHJvb3QgPSBndW4uYmFjaygtMSksIHRtcDtcbiAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgIGlmKG9wdCAmJiBvcHQuc2Vzc2lvblN0b3JhZ2Upe1xuICAgICAgICBpZihTRUEud2luZG93KXtcbiAgICAgICAgICB0cnl7XG4gICAgICAgICAgICB2YXIgc1MgPSB7fTtcbiAgICAgICAgICAgIHNTID0gU0VBLndpbmRvdy5zZXNzaW9uU3RvcmFnZTsgLy8gVE9ETzogRklYIEJVRyBwdXR0aW5nIG9uIGAuaXNgIVxuICAgICAgICAgICAgaWYoc1Mpe1xuICAgICAgICAgICAgICAocm9vdC5fKS5vcHQucmVtZW1iZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAoKGd1bi5iYWNrKCd1c2VyJykuXykub3B0fHxvcHQpLnJlbWVtYmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYoc1MucmVjYWxsIHx8IHNTLnBhaXIpIHJvb3QudXNlcigpLmF1dGgoSlNPTi5wYXJzZShzUy5wYWlyKSwgY2IpOyAvLyBwYWlyIGlzIG1vcmUgcmVsaWFibGUgdGhhbiBhbGlhcy9wYXNzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWNhdGNoKGUpe31cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3VuO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAgVE9ETzogY29weSBtaGVsYW5kZXIncyBleHBpcnkgY29kZSBiYWNrIGluLlxuICAgICAgICBBbHRob3VnaCwgd2Ugc2hvdWxkIGNoZWNrIHdpdGggY29tbXVuaXR5LFxuICAgICAgICBzaG91bGQgZXhwaXJ5IGJlIGNvcmUgb3IgYSBwbHVnaW4/XG4gICAgICAqL1xuICAgICAgcmV0dXJuIGd1bjtcbiAgICB9XG4gIH0pKFVTRSwgJy4vcmVjYWxsJyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBVc2VyID0gVVNFKCcuL3VzZXInKSwgU0VBID0gVXNlci5TRUEsIEd1biA9IFVzZXIuR1VOLCBub29wID0gZnVuY3Rpb24oKXt9O1xuICAgIFVzZXIucHJvdG90eXBlLnBhaXIgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIHVzZXIgPSB0aGlzLCBwcm94eTsgLy8gdW5kZXByZWNhdGVkLCBoaWRpbmcgd2l0aCBwcm94aWVzLlxuICAgICAgdHJ5eyBwcm94eSA9IG5ldyBQcm94eSh7REFOR0VSOidcXHUyNjIwJ30sIHtnZXQ6IGZ1bmN0aW9uKHQscCxyKXtcbiAgICAgICAgaWYoIXVzZXIuaXMgfHwgISh1c2VyLl98fCcnKS5zZWEpeyByZXR1cm4gfVxuICAgICAgICByZXR1cm4gdXNlci5fLnNlYVtwXTtcbiAgICAgIH19KX1jYXRjaChlKXt9XG4gICAgICByZXR1cm4gcHJveHk7XG4gICAgfVxuICAgIC8vIElmIGF1dGhlbnRpY2F0ZWQgdXNlciB3YW50cyB0byBkZWxldGUgaGlzL2hlciBhY2NvdW50LCBsZXQncyBzdXBwb3J0IGl0IVxuICAgIFVzZXIucHJvdG90eXBlLmRlbGV0ZSA9IGFzeW5jIGZ1bmN0aW9uKGFsaWFzLCBwYXNzLCBjYil7XG4gICAgICBjb25zb2xlLmxvZyhcInVzZXIuZGVsZXRlKCkgSVMgREVQUkVDQVRFRCBBTkQgV0lMTCBCRSBNT1ZFRCBUTyBBIE1PRFVMRSEhIVwiKTtcbiAgICAgIHZhciBndW4gPSB0aGlzLCByb290ID0gZ3VuLmJhY2soLTEpLCB1c2VyID0gZ3VuLmJhY2soJ3VzZXInKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVzZXIuYXV0aChhbGlhcywgcGFzcywgZnVuY3Rpb24oYWNrKXtcbiAgICAgICAgICB2YXIgcHViID0gKHVzZXIuaXN8fHt9KS5wdWI7XG4gICAgICAgICAgLy8gRGVsZXRlIHVzZXIgZGF0YVxuICAgICAgICAgIHVzZXIubWFwKCkub25jZShmdW5jdGlvbigpeyB0aGlzLnB1dChudWxsKSB9KTtcbiAgICAgICAgICAvLyBXaXBlIHVzZXIgZGF0YSBmcm9tIG1lbW9yeVxuICAgICAgICAgIHVzZXIubGVhdmUoKTtcbiAgICAgICAgICAoY2IgfHwgbm9vcCkoe29rOiAwfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBHdW4ubG9nKCdVc2VyLmRlbGV0ZSBmYWlsZWQhIEVycm9yOicsIGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGd1bjtcbiAgICB9XG4gICAgVXNlci5wcm90b3R5cGUuYWxpdmUgPSBhc3luYyBmdW5jdGlvbigpe1xuICAgICAgY29uc29sZS5sb2coXCJ1c2VyLmFsaXZlKCkgSVMgREVQUkVDQVRFRCEhIVwiKTtcbiAgICAgIGNvbnN0IGd1blJvb3QgPSB0aGlzLmJhY2soLTEpXG4gICAgICB0cnkge1xuICAgICAgICAvLyBBbGwgaXMgZ29vZC4gU2hvdWxkIHdlIGRvIHNvbWV0aGluZyBtb3JlIHdpdGggYWN0dWFsIHJlY2FsbGVkIGRhdGE/XG4gICAgICAgIGF3YWl0IGF1dGhSZWNhbGwoZ3VuUm9vdClcbiAgICAgICAgcmV0dXJuIGd1blJvb3QuXy51c2VyLl9cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gJ05vIHNlc3Npb24hJ1xuICAgICAgICBHdW4ubG9nKGVycilcbiAgICAgICAgdGhyb3cgeyBlcnIgfVxuICAgICAgfVxuICAgIH1cbiAgICBVc2VyLnByb3RvdHlwZS50cnVzdCA9IGFzeW5jIGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgY29uc29sZS5sb2coXCJgLnRydXN0YCBBUEkgTUFZIEJFIERFTEVURUQgT1IgQ0hBTkdFRCBPUiBSRU5BTUVELCBETyBOT1QgVVNFIVwiKTtcbiAgICAgIC8vIFRPRE86IEJVRyEhISBTRUEgYG5vZGVgIHJlYWQgbGlzdGVuZXIgbmVlZHMgdG8gYmUgYXN5bmMsIHdoaWNoIG1lYW5zIGNvcmUgbmVlZHMgdG8gYmUgYXN5bmMgdG9vLlxuICAgICAgLy9ndW4uZ2V0KCdhbGljZScpLmdldCgnYWdlJykudHJ1c3QoYm9iKTtcbiAgICAgIGlmIChHdW4uaXModXNlcikpIHtcbiAgICAgICAgdXNlci5nZXQoJ3B1YicpLmdldCgoY3R4LCBldikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGN0eCwgZXYpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICB1c2VyLmdldCgndHJ1c3QnKS5nZXQocGF0aCkucHV0KHRoZWlyUHVia2V5KTtcblxuICAgICAgLy8gZG8gYSBsb29rdXAgb24gdGhpcyBndW4gY2hhaW4gZGlyZWN0bHkgKHRoYXQgZ2V0cyBib2IncyBjb3B5IG9mIHRoZSBkYXRhKVxuICAgICAgLy8gZG8gYSBsb29rdXAgb24gdGhlIG1ldGFkYXRhIHRydXN0IHRhYmxlIGZvciB0aGlzIHBhdGggKHRoYXQgZ2V0cyBhbGwgdGhlIHB1YmtleXMgYWxsb3dlZCB0byB3cml0ZSBvbiB0aGlzIHBhdGgpXG4gICAgICAvLyBkbyBhIGxvb2t1cCBvbiBlYWNoIG9mIHRob3NlIHB1YktleXMgT04gdGhlIHBhdGggKHRvIGdldCB0aGUgY29sbGFiIGRhdGEgXCJsYXllcnNcIilcbiAgICAgIC8vIFRIRU4geW91IHBlcmZvcm0gSmFjaGVuJ3MgbWl4IG9wZXJhdGlvblxuICAgICAgLy8gYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXQgdG8uLi5cbiAgICB9XG4gICAgVXNlci5wcm90b3R5cGUuZ3JhbnQgPSBmdW5jdGlvbih0bywgY2Ipe1xuICAgICAgY29uc29sZS5sb2coXCJgLmdyYW50YCBBUEkgTUFZIEJFIERFTEVURUQgT1IgQ0hBTkdFRCBPUiBSRU5BTUVELCBETyBOT1QgVVNFIVwiKTtcbiAgICAgIHZhciBndW4gPSB0aGlzLCB1c2VyID0gZ3VuLmJhY2soLTEpLnVzZXIoKSwgcGFpciA9IHVzZXIuXy5zZWEsIHBhdGggPSAnJztcbiAgICAgIGd1bi5iYWNrKGZ1bmN0aW9uKGF0KXsgaWYoYXQuaXMpeyByZXR1cm4gfSBwYXRoICs9IChhdC5nZXR8fCcnKSB9KTtcbiAgICAgIChhc3luYyBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVuYywgc2VjID0gYXdhaXQgdXNlci5nZXQoJ2dyYW50JykuZ2V0KHBhaXIucHViKS5nZXQocGF0aCkudGhlbigpO1xuICAgICAgc2VjID0gYXdhaXQgU0VBLmRlY3J5cHQoc2VjLCBwYWlyKTtcbiAgICAgIGlmKCFzZWMpe1xuICAgICAgICBzZWMgPSBTRUEucmFuZG9tKDE2KS50b1N0cmluZygpO1xuICAgICAgICBlbmMgPSBhd2FpdCBTRUEuZW5jcnlwdChzZWMsIHBhaXIpO1xuICAgICAgICB1c2VyLmdldCgnZ3JhbnQnKS5nZXQocGFpci5wdWIpLmdldChwYXRoKS5wdXQoZW5jKTtcbiAgICAgIH1cbiAgICAgIHZhciBwdWIgPSB0by5nZXQoJ3B1YicpLnRoZW4oKTtcbiAgICAgIHZhciBlcHViID0gdG8uZ2V0KCdlcHViJykudGhlbigpO1xuICAgICAgcHViID0gYXdhaXQgcHViOyBlcHViID0gYXdhaXQgZXB1YjtcbiAgICAgIHZhciBkaCA9IGF3YWl0IFNFQS5zZWNyZXQoZXB1YiwgcGFpcik7XG4gICAgICBlbmMgPSBhd2FpdCBTRUEuZW5jcnlwdChzZWMsIGRoKTtcbiAgICAgIHVzZXIuZ2V0KCdncmFudCcpLmdldChwdWIpLmdldChwYXRoKS5wdXQoZW5jLCBjYik7XG4gICAgICB9KCkpO1xuICAgICAgcmV0dXJuIGd1bjtcbiAgICB9XG4gICAgVXNlci5wcm90b3R5cGUuc2VjcmV0ID0gZnVuY3Rpb24oZGF0YSwgY2Ipe1xuICAgICAgY29uc29sZS5sb2coXCJgLnNlY3JldGAgQVBJIE1BWSBCRSBERUxFVEVEIE9SIENIQU5HRUQgT1IgUkVOQU1FRCwgRE8gTk9UIFVTRSFcIik7XG4gICAgICB2YXIgZ3VuID0gdGhpcywgdXNlciA9IGd1bi5iYWNrKC0xKS51c2VyKCksIHBhaXIgPSB1c2VyLnBhaXIoKSwgcGF0aCA9ICcnO1xuICAgICAgZ3VuLmJhY2soZnVuY3Rpb24oYXQpeyBpZihhdC5pcyl7IHJldHVybiB9IHBhdGggKz0gKGF0LmdldHx8JycpIH0pO1xuICAgICAgKGFzeW5jIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZW5jLCBzZWMgPSBhd2FpdCB1c2VyLmdldCgndHJ1c3QnKS5nZXQocGFpci5wdWIpLmdldChwYXRoKS50aGVuKCk7XG4gICAgICBzZWMgPSBhd2FpdCBTRUEuZGVjcnlwdChzZWMsIHBhaXIpO1xuICAgICAgaWYoIXNlYyl7XG4gICAgICAgIHNlYyA9IFNFQS5yYW5kb20oMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgIGVuYyA9IGF3YWl0IFNFQS5lbmNyeXB0KHNlYywgcGFpcik7XG4gICAgICAgIHVzZXIuZ2V0KCd0cnVzdCcpLmdldChwYWlyLnB1YikuZ2V0KHBhdGgpLnB1dChlbmMpO1xuICAgICAgfVxuICAgICAgZW5jID0gYXdhaXQgU0VBLmVuY3J5cHQoZGF0YSwgc2VjKTtcbiAgICAgIGd1bi5wdXQoZW5jLCBjYik7XG4gICAgICB9KCkpO1xuICAgICAgcmV0dXJuIGd1bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBkZWNyeXB0ZWQgdmFsdWUsIGVuY3J5cHRlZCBieSBzZWNyZXRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAvLyBNYXJrIG5lZWRzIHRvIHJldmlldyAxc3QgYmVmb3JlIG9mZmljaWFsbHkgc3VwcG9ydGVkXG4gICAgVXNlci5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICBsZXQgZ3VuID0gdGhpcyxcbiAgICAgICAgcGF0aCA9ICcnXG4gICAgICBndW4uYmFjayhmdW5jdGlvbihhdCkge1xuICAgICAgICBpZiAoYXQuaXMpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBwYXRoICs9IGF0LmdldCB8fCAnJ1xuICAgICAgfSlcbiAgICAgIHJldHVybiBndW5cbiAgICAgICAgLnRoZW4oYXN5bmMgZGF0YSA9PiB7XG4gICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHVzZXIgPSBndW4uYmFjaygtMSkudXNlcigpXG4gICAgICAgICAgY29uc3QgcGFpciA9IHVzZXIucGFpcigpXG4gICAgICAgICAgbGV0IHNlYyA9IGF3YWl0IHVzZXJcbiAgICAgICAgICAgIC5nZXQoJ3RydXN0JylcbiAgICAgICAgICAgIC5nZXQocGFpci5wdWIpXG4gICAgICAgICAgICAuZ2V0KHBhdGgpXG4gICAgICAgICAgc2VjID0gYXdhaXQgU0VBLmRlY3J5cHQoc2VjLCBwYWlyKVxuICAgICAgICAgIGlmICghc2VjKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZGVjcnlwdGVkID0gYXdhaXQgU0VBLmRlY3J5cHQoZGF0YSwgc2VjKVxuICAgICAgICAgIHJldHVybiBkZWNyeXB0ZWRcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICBjYiAmJiBjYihyZXMpXG4gICAgICAgICAgcmV0dXJuIHJlc1xuICAgICAgICB9KVxuICAgIH1cbiAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gVXNlclxuICB9KShVU0UsICcuL3NoYXJlJyk7XG5cbiAgO1VTRShmdW5jdGlvbihtb2R1bGUpe1xuICAgIHZhciBTRUEgPSBVU0UoJy4vc2VhJyksIFMgPSBVU0UoJy4vc2V0dGluZ3MnKSwgbm9vcCA9IGZ1bmN0aW9uKCkge30sIHU7XG4gICAgdmFyIEd1biA9IChTRUEud2luZG93fHwnJykuR1VOIHx8IFVTRSgoJycrdSA9PT0gdHlwZW9mIE1PRFVMRT8nLic6JycpKycuL2d1bicsIDEpO1xuICAgIC8vIEFmdGVyIHdlIGhhdmUgYSBHVU4gZXh0ZW5zaW9uIHRvIG1ha2UgdXNlciByZWdpc3RyYXRpb24vbG9naW4gZWFzeSwgd2UgdGhlbiBuZWVkIHRvIGhhbmRsZSBldmVyeXRoaW5nIGVsc2UuXG5cbiAgICAvLyBXZSBkbyB0aGlzIHdpdGggYSBHVU4gYWRhcHRlciwgd2UgZmlyc3QgbGlzdGVuIHRvIHdoZW4gYSBndW4gaW5zdGFuY2UgaXMgY3JlYXRlZCAoYW5kIHdoZW4gaXRzIG9wdGlvbnMgY2hhbmdlKVxuICAgIEd1bi5vbignb3B0JywgZnVuY3Rpb24oYXQpe1xuICAgICAgaWYoIWF0LnNlYSl7IC8vIG9ubHkgYWRkIFNFQSBvbmNlIHBlciBpbnN0YW5jZSwgb24gdGhlIFwiYXRcIiBjb250ZXh0LlxuICAgICAgICBhdC5zZWEgPSB7b3duOiB7fX07XG4gICAgICAgIGF0Lm9uKCdwdXQnLCBjaGVjaywgYXQpOyAvLyBTRUEgbm93IHJ1bnMgaXRzIGZpcmV3YWxsIG9uIEhBTSBkaWZmcywgbm90IGFsbCBpL28uXG4gICAgICB9XG4gICAgICB0aGlzLnRvLm5leHQoYXQpOyAvLyBtYWtlIHN1cmUgdG8gY2FsbCB0aGUgXCJuZXh0XCIgbWlkZGxld2FyZSBhZGFwdGVyLlxuICAgIH0pO1xuXG4gICAgLy8gQWxyaWdodCwgdGhpcyBuZXh0IGFkYXB0ZXIgZ2V0cyBydW4gYXQgdGhlIHBlciBub2RlIGxldmVsIGluIHRoZSBncmFwaCBkYXRhYmFzZS5cbiAgICAvLyBjb3JyZWN0aW9uOiAyMDIwIGl0IGdldHMgcnVuIG9uIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gYSBub2RlIHVwb24gYSBIQU0gZGlmZi5cbiAgICAvLyBUaGlzIHdpbGwgbGV0IHVzIHZlcmlmeSB0aGF0IGV2ZXJ5IHByb3BlcnR5IG9uIGEgbm9kZSBoYXMgYSB2YWx1ZSBzaWduZWQgYnkgYSBwdWJsaWMga2V5IHdlIHRydXN0LlxuICAgIC8vIElmIHRoZSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2gsIHRoZSBkYXRhIGlzIGp1c3QgYHVuZGVmaW5lZGAgc28gaXQgZG9lc24ndCBnZXQgcGFzc2VkIG9uLlxuICAgIC8vIElmIGl0IGRvZXMgbWF0Y2gsIHRoZW4gd2UgdHJhbnNmb3JtIHRoZSBpbi1tZW1vcnkgXCJ2aWV3XCIgb2YgdGhlIGRhdGEgaW50byBpdHMgcGxhaW4gdmFsdWUgKHdpdGhvdXQgdGhlIHNpZ25hdHVyZSkuXG4gICAgLy8gTm93IE5PVEUhIFNvbWUgZGF0YSBpcyBcInN5c3RlbVwiIGRhdGEsIG5vdCB1c2VyIGRhdGEuIEV4YW1wbGU6IExpc3Qgb2YgcHVibGljIGtleXMsIGFsaWFzZXMsIGV0Yy5cbiAgICAvLyBUaGlzIGRhdGEgaXMgc2VsZi1lbmZvcmNlZCAodGhlIHZhbHVlIGNhbiBvbmx5IG1hdGNoIGl0cyBJRCksIGJ1dCB0aGF0IGlzIGhhbmRsZWQgaW4gdGhlIGBzZWN1cml0eWAgZnVuY3Rpb24uXG4gICAgLy8gRnJvbSB0aGUgc2VsZi1lbmZvcmNlZCBkYXRhLCB3ZSBjYW4gc2VlIGFsbCB0aGUgZWRnZXMgaW4gdGhlIGdyYXBoIHRoYXQgYmVsb25nIHRvIGEgcHVibGljIGtleS5cbiAgICAvLyBFeGFtcGxlOiB+QVNERiBpcyB0aGUgSUQgb2YgYSBub2RlIHdpdGggQVNERiBhcyBpdHMgcHVibGljIGtleSwgc2lnbmVkIGFsaWFzIGFuZCBzYWx0LCBhbmRcbiAgICAvLyBpdHMgZW5jcnlwdGVkIHByaXZhdGUga2V5LCBidXQgaXQgbWlnaHQgYWxzbyBoYXZlIG90aGVyIHNpZ25lZCB2YWx1ZXMgb24gaXQgbGlrZSBgcHJvZmlsZSA9IDxJRD5gIGVkZ2UuXG4gICAgLy8gVXNpbmcgdGhhdCBkaXJlY3RlZCBlZGdlJ3MgSUQsIHdlIGNhbiB0aGVuIHRyYWNrIChpbiBtZW1vcnkpIHdoaWNoIElEcyBiZWxvbmcgdG8gd2hpY2gga2V5cy5cbiAgICAvLyBIZXJlIGlzIGEgcHJvYmxlbTogTXVsdGlwbGUgcHVibGljIGtleXMgY2FuIFwiY2xhaW1cIiBhbnkgbm9kZSdzIElELCBzbyB0aGlzIGlzIGRhbmdlcm91cyFcbiAgICAvLyBUaGlzIG1lYW5zIHdlIHNob3VsZCBPTkxZIHRydXN0IG91ciBcImZyaWVuZHNcIiAob3VyIGtleSByaW5nKSBwdWJsaWMga2V5cywgbm90IGFueSBvbmVzLlxuICAgIC8vIEkgaGF2ZSBub3QgeWV0IGFkZGVkIHRoYXQgdG8gU0VBIHlldCBpbiB0aGlzIGFscGhhIHJlbGVhc2UuIFRoYXQgaXMgY29taW5nIHNvb24sIGJ1dCBiZXdhcmUgaW4gdGhlIG1lYW53aGlsZSFcblxuICAgIGZ1bmN0aW9uIGNoZWNrKG1zZyl7IC8vIFJFVklTRSAvIElNUFJPVkUsIE5PIE5FRUQgVE8gUEFTUyBNU0cvRVZFIEVBQ0ggU1VCP1xuICAgICAgdmFyIGV2ZSA9IHRoaXMsIGF0ID0gZXZlLmFzLCBwdXQgPSBtc2cucHV0LCBzb3VsID0gcHV0WycjJ10sIGtleSA9IHB1dFsnLiddLCB2YWwgPSBwdXRbJzonXSwgc3RhdGUgPSBwdXRbJz4nXSwgaWQgPSBtc2dbJyMnXSwgdG1wO1xuICAgICAgaWYoIXNvdWwgfHwgIWtleSl7IHJldHVybiB9XG4gICAgICBpZigobXNnLl98fCcnKS5mYWl0aCAmJiAoYXQub3B0fHwnJykuZmFpdGggJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgbXNnLl8pe1xuICAgICAgICBTRUEub3B0LnBhY2socHV0LCBmdW5jdGlvbihyYXcpe1xuICAgICAgICBTRUEudmVyaWZ5KHJhdywgZmFsc2UsIGZ1bmN0aW9uKGRhdGEpeyAvLyB0aGlzIGlzIHN5bmNocm9ub3VzIGlmIGZhbHNlXG4gICAgICAgICAgcHV0Wyc9J10gPSBTRUEub3B0LnVucGFjayhkYXRhKTtcbiAgICAgICAgICBldmUudG8ubmV4dChtc2cpO1xuICAgICAgICB9KX0pXG4gICAgICAgIHJldHVybiBcbiAgICAgIH1cbiAgICAgIHZhciBubyA9IGZ1bmN0aW9uKHdoeSl7IGF0Lm9uKCdpbicsIHsnQCc6IGlkLCBlcnI6IG1zZy5lcnIgPSB3aHl9KSB9OyAvLyBleHBsb2l0IGludGVybmFsIHJlbGF5IHN0dW4gZm9yIG5vdywgbWF5YmUgdmlvbGF0ZXMgc3BlYywgYnV0IHRlc3RpbmcgZm9yIG5vdy4gLy8gTm90ZTogdGhpcyBtYXkgYmUgb25seSB0aGUgc2hhcmRlZCBtZXNzYWdlLCBub3Qgb3JpZ2luYWwgYmF0Y2guXG4gICAgICAvL3ZhciBubyA9IGZ1bmN0aW9uKHdoeSl7IG1zZy5hY2sod2h5KSB9O1xuICAgICAgKG1zZy5ffHwnJykuREJHICYmICgobXNnLl98fCcnKS5EQkcuYyA9ICtuZXcgRGF0ZSk7XG4gICAgICBpZigwIDw9IHNvdWwuaW5kZXhPZignPD8nKSl7IC8vIHNwZWNpYWwgY2FzZSBmb3IgXCJkbyBub3Qgc3luYyBkYXRhIFggb2xkXCIgZm9yZ2V0XG4gICAgICAgIC8vICdhfnB1Yi5rZXkvYjw/OSdcbiAgICAgICAgdG1wID0gcGFyc2VGbG9hdChzb3VsLnNwbGl0KCc8PycpWzFdfHwnJyk7XG4gICAgICAgIGlmKHRtcCAmJiAoc3RhdGUgPCAoR3VuLnN0YXRlKCkgLSAodG1wICogMTAwMCkpKSl7IC8vIHNlYyB0byBtc1xuICAgICAgICAgICh0bXAgPSBtc2cuXykgJiYgKHRtcC5zdHVuKSAmJiAodG1wLnN0dW4tLSk7IC8vIFRISVMgSVMgQkFEIENPREUhIEl0IGFzc3VtZXMgR1VOIGludGVybmFscyBkbyBzb21ldGhpbmcgdGhhdCB3aWxsIHByb2JhYmx5IGNoYW5nZSBpbiBmdXR1cmUsIGJ1dCBoYWNraW5nIGluIG5vdy5cbiAgICAgICAgICByZXR1cm47IC8vIG9taXQhXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoJ35AJyA9PT0gc291bCl7ICAvLyBzcGVjaWFsIGNhc2UgZm9yIHNoYXJlZCBzeXN0ZW0gZGF0YSwgdGhlIGxpc3Qgb2YgYWxpYXNlcy5cbiAgICAgICAgY2hlY2suYWxpYXMoZXZlLCBtc2csIHZhbCwga2V5LCBzb3VsLCBhdCwgbm8pOyByZXR1cm47XG4gICAgICB9XG4gICAgICBpZignfkAnID09PSBzb3VsLnNsaWNlKDAsMikpeyAvLyBzcGVjaWFsIGNhc2UgZm9yIHNoYXJlZCBzeXN0ZW0gZGF0YSwgdGhlIGxpc3Qgb2YgcHVibGljIGtleXMgZm9yIGFuIGFsaWFzLlxuICAgICAgICBjaGVjay5wdWJzKGV2ZSwgbXNnLCB2YWwsIGtleSwgc291bCwgYXQsIG5vKTsgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy9pZignficgPT09IHNvdWwuc2xpY2UoMCwxKSAmJiAyID09PSAodG1wID0gc291bC5zbGljZSgxKSkuc3BsaXQoJy4nKS5sZW5ndGgpeyAvLyBzcGVjaWFsIGNhc2UsIGFjY291bnQgZGF0YSBmb3IgYSBwdWJsaWMga2V5LlxuICAgICAgaWYodG1wID0gU0VBLm9wdC5wdWIoc291bCkpeyAvLyBzcGVjaWFsIGNhc2UsIGFjY291bnQgZGF0YSBmb3IgYSBwdWJsaWMga2V5LlxuICAgICAgICBjaGVjay5wdWIoZXZlLCBtc2csIHZhbCwga2V5LCBzb3VsLCBhdCwgbm8sIGF0LnVzZXJ8fCcnLCB0bXApOyByZXR1cm47XG4gICAgICB9XG4gICAgICBpZigwIDw9IHNvdWwuaW5kZXhPZignIycpKXsgLy8gc3BlY2lhbCBjYXNlIGZvciBjb250ZW50IGFkZHJlc3NpbmcgaW1tdXRhYmxlIGhhc2hlZCBkYXRhLlxuICAgICAgICBjaGVjay5oYXNoKGV2ZSwgbXNnLCB2YWwsIGtleSwgc291bCwgYXQsIG5vKTsgcmV0dXJuO1xuICAgICAgfSBcbiAgICAgIGNoZWNrLmFueShldmUsIG1zZywgdmFsLCBrZXksIHNvdWwsIGF0LCBubywgYXQudXNlcnx8JycpOyByZXR1cm47XG4gICAgICBldmUudG8ubmV4dChtc2cpOyAvLyBub3QgaGFuZGxlZFxuICAgIH1cbiAgICBjaGVjay5oYXNoID0gZnVuY3Rpb24oZXZlLCBtc2csIHZhbCwga2V5LCBzb3VsLCBhdCwgbm8peyAvLyBtYXJrIHVuYnVpbHQgQGkwMDE5NjIgJ3MgZXBpYyBoZXggY29udHJpYiFcbiAgICAgIFNFQS53b3JrKHZhbCwgbnVsbCwgZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIGZ1bmN0aW9uIGhleFRvQmFzZTY0KGhleFN0cikge1xuICAgICAgICAgIGxldCBiYXNlNjQgPSBcIlwiO1xuICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBoZXhTdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJhc2U2NCArPSAhKGkgLSAxICYgMSkgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleFN0ci5zdWJzdHJpbmcoaSAtIDEsIGkgKyAxKSwgMTYpKSA6IFwiXCJ9XG4gICAgICAgICAgcmV0dXJuIGJ0b2EoYmFzZTY0KTt9ICBcbiAgICAgICAgaWYoZGF0YSAmJiBkYXRhID09PSBrZXkuc3BsaXQoJyMnKS5zbGljZSgtMSlbMF0peyByZXR1cm4gZXZlLnRvLm5leHQobXNnKSB9XG4gICAgICAgICAgZWxzZSBpZiAoZGF0YSAmJiBkYXRhID09PSBoZXhUb0Jhc2U2NChrZXkuc3BsaXQoJyMnKS5zbGljZSgtMSlbMF0pKXsgXG4gICAgICAgICAgcmV0dXJuIGV2ZS50by5uZXh0KG1zZykgfVxuICAgICAgICBubyhcIkRhdGEgaGFzaCBub3Qgc2FtZSBhcyBoYXNoIVwiKTtcbiAgICAgIH0sIHtuYW1lOiAnU0hBLTI1Nid9KTtcbiAgICB9XG4gICAgY2hlY2suYWxpYXMgPSBmdW5jdGlvbihldmUsIG1zZywgdmFsLCBrZXksIHNvdWwsIGF0LCBubyl7IC8vIEV4YW1wbGU6IHtfOiN+QCwgfkBhbGljZTogeyN+QGFsaWNlfX1cbiAgICAgIGlmKCF2YWwpeyByZXR1cm4gbm8oXCJEYXRhIG11c3QgZXhpc3QhXCIpIH0gLy8gZGF0YSBNVVNUIGV4aXN0XG4gICAgICBpZignfkAnK2tleSA9PT0gbGlua19pcyh2YWwpKXsgcmV0dXJuIGV2ZS50by5uZXh0KG1zZykgfSAvLyBpbiBmYWN0LCBpdCBtdXN0IGJlIEVYQUNUTFkgZXF1YWwgdG8gaXRzZWxmXG4gICAgICBubyhcIkFsaWFzIG5vdCBzYW1lIVwiKTsgLy8gaWYgaXQgaXNuJ3QsIHJlamVjdC5cbiAgICB9O1xuICAgIGNoZWNrLnB1YnMgPSBmdW5jdGlvbihldmUsIG1zZywgdmFsLCBrZXksIHNvdWwsIGF0LCBubyl7IC8vIEV4YW1wbGU6IHtfOiN+QGFsaWNlLCB+YXNkZjogeyN+YXNkZn19XG4gICAgICBpZighdmFsKXsgcmV0dXJuIG5vKFwiQWxpYXMgbXVzdCBleGlzdCFcIikgfSAvLyBkYXRhIE1VU1QgZXhpc3RcbiAgICAgIGlmKGtleSA9PT0gbGlua19pcyh2YWwpKXsgcmV0dXJuIGV2ZS50by5uZXh0KG1zZykgfSAvLyBhbmQgdGhlIElEIG11c3QgYmUgRVhBQ1RMWSBlcXVhbCB0byBpdHMgcHJvcGVydHlcbiAgICAgIG5vKFwiQWxpYXMgbm90IHNhbWUhXCIpOyAvLyB0aGF0IHdheSBub2JvZHkgY2FuIHRhbXBlciB3aXRoIHRoZSBsaXN0IG9mIHB1YmxpYyBrZXlzLlxuICAgIH07XG4gICAgY2hlY2sucHViID0gYXN5bmMgZnVuY3Rpb24oZXZlLCBtc2csIHZhbCwga2V5LCBzb3VsLCBhdCwgbm8sIHVzZXIsIHB1Yil7IHZhciB0bXAgLy8gRXhhbXBsZToge186I35hc2RmLCBoZWxsbzond29ybGQnfmZkc2F9fVxuICAgICAgY29uc3QgcmF3ID0gYXdhaXQgUy5wYXJzZSh2YWwpIHx8IHt9XG4gICAgICBjb25zdCB2ZXJpZnkgPSAoY2VydGlmaWNhdGUsIGNlcnRpZmljYW50LCBjYikgPT4ge1xuICAgICAgICBpZiAoY2VydGlmaWNhdGUubSAmJiBjZXJ0aWZpY2F0ZS5zICYmIGNlcnRpZmljYW50ICYmIHB1YilcbiAgICAgICAgICAvLyBub3cgdmVyaWZ5IGNlcnRpZmljYXRlXG4gICAgICAgICAgcmV0dXJuIFNFQS52ZXJpZnkoY2VydGlmaWNhdGUsIHB1YiwgZGF0YSA9PiB7IC8vIGNoZWNrIGlmIFwicHViXCIgKG9mIHRoZSBncmFwaCBvd25lcikgcmVhbGx5IGlzc3VlZCB0aGlzIGNlcnRcbiAgICAgICAgICAgIGlmICh1ICE9PSBkYXRhICYmIHUgIT09IGRhdGEuZSAmJiBtc2cucHV0Wyc+J10gJiYgbXNnLnB1dFsnPiddID4gcGFyc2VGbG9hdChkYXRhLmUpKSByZXR1cm4gbm8oXCJDZXJ0aWZpY2F0ZSBleHBpcmVkLlwiKSAvLyBjZXJ0aWZpY2F0ZSBleHBpcmVkXG4gICAgICAgICAgICAvLyBcImRhdGEuY1wiID0gYSBsaXN0IG9mIGNlcnRpZmljYW50cy9jZXJ0aWZpZWQgdXNlcnNcbiAgICAgICAgICAgIC8vIFwiZGF0YS53XCIgPSBsZXggV1JJVEUgcGVybWlzc2lvbiwgaW4gdGhlIGZ1dHVyZSwgdGhlcmUgd2lsbCBiZSBcImRhdGEuclwiIHdoaWNoIG1lYW5zIGxleCBSRUFEIHBlcm1pc3Npb25cbiAgICAgICAgICAgIGlmICh1ICE9PSBkYXRhICYmIGRhdGEuYyAmJiBkYXRhLncgJiYgKGRhdGEuYyA9PT0gY2VydGlmaWNhbnQgfHwgZGF0YS5jLmluZGV4T2YoJyonIHx8IGNlcnRpZmljYW50KSA+IC0xKSkge1xuICAgICAgICAgICAgICAvLyBvaywgbm93IFwiY2VydGlmaWNhbnRcIiBpcyBpbiB0aGUgXCJjZXJ0aWZpY2FudHNcIiBsaXN0LCBidXQgaXMgXCJwYXRoXCIgYWxsb3dlZD8gQ2hlY2sgcGF0aFxuICAgICAgICAgICAgICBsZXQgcGF0aCA9IHNvdWwuaW5kZXhPZignLycpID4gLTEgPyBzb3VsLnJlcGxhY2Uoc291bC5zdWJzdHJpbmcoMCwgc291bC5pbmRleE9mKCcvJykgKyAxKSwgJycpIDogJydcbiAgICAgICAgICAgICAgU3RyaW5nLm1hdGNoID0gU3RyaW5nLm1hdGNoIHx8IEd1bi50ZXh0Lm1hdGNoXG4gICAgICAgICAgICAgIGNvbnN0IHcgPSBBcnJheS5pc0FycmF5KGRhdGEudykgPyBkYXRhLncgOiB0eXBlb2YgZGF0YS53ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgZGF0YS53ID09PSAnc3RyaW5nJyA/IFtkYXRhLnddIDogW11cbiAgICAgICAgICAgICAgZm9yIChjb25zdCBsZXggb2Ygdykge1xuICAgICAgICAgICAgICAgIGlmICgoU3RyaW5nLm1hdGNoKHBhdGgsIGxleFsnIyddKSAmJiBTdHJpbmcubWF0Y2goa2V5LCBsZXhbJy4nXSkpIHx8ICghbGV4WycuJ10gJiYgU3RyaW5nLm1hdGNoKHBhdGgsIGxleFsnIyddKSkgfHwgKCFsZXhbJyMnXSAmJiBTdHJpbmcubWF0Y2goa2V5LCBsZXhbJy4nXSkpIHx8IFN0cmluZy5tYXRjaCgocGF0aCA/IHBhdGggKyAnLycgKyBrZXkgOiBrZXkpLCBsZXhbJyMnXSB8fCBsZXgpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpcyBDZXJ0aWZpY2FudCBmb3JjZWQgdG8gcHJlc2VudCBpbiBQYXRoXG4gICAgICAgICAgICAgICAgICBpZiAobGV4WycrJ10gJiYgbGV4WycrJ10uaW5kZXhPZignKicpID4gLTEgJiYgcGF0aCAmJiBwYXRoLmluZGV4T2YoY2VydGlmaWNhbnQpID09IC0xICYmIGtleS5pbmRleE9mKGNlcnRpZmljYW50KSA9PSAtMSkgcmV0dXJuIG5vKGBQYXRoIFwiJHtwYXRofVwiIG9yIGtleSBcIiR7a2V5fVwiIG11c3QgY29udGFpbiBzdHJpbmcgXCIke2NlcnRpZmljYW50fVwiLmApXG4gICAgICAgICAgICAgICAgICAvLyBwYXRoIGlzIGFsbG93ZWQsIGJ1dCBpcyB0aGVyZSBhbnkgV1JJVEUgYmxvY2s/IENoZWNrIGl0IG91dFxuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEud2IgJiYgKHR5cGVvZiBkYXRhLndiID09PSAnc3RyaW5nJyB8fCAoKGRhdGEud2IgfHwge30pWycjJ10pKSkgeyAvLyBcImRhdGEud2JcIiA9IHBhdGggdG8gdGhlIFdSSVRFIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHZhciByb290ID0gZXZlLmFzLnJvb3QuJC5iYWNrKC0xKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEud2IgPT09ICdzdHJpbmcnICYmICd+JyAhPT0gZGF0YS53Yi5zbGljZSgwLCAxKSkgcm9vdCA9IHJvb3QuZ2V0KCd+JyArIHB1YilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QuZ2V0KGRhdGEud2IpLmdldChjZXJ0aWZpY2FudCkub25jZSh2YWx1ZSA9PiB7IC8vIFRPRE86IElOVEVOVCBUTyBERVBSRUNBVEUuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmICh2YWx1ZSA9PT0gMSB8fCB2YWx1ZSA9PT0gdHJ1ZSkpIHJldHVybiBubyhgQ2VydGlmaWNhbnQgJHtjZXJ0aWZpY2FudH0gYmxvY2tlZC5gKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihkYXRhKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGRhdGEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBubyhcIkNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbiBmYWlsLlwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoJ3B1YicgPT09IGtleSAmJiAnficgKyBwdWIgPT09IHNvdWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gcHViKSByZXR1cm4gZXZlLnRvLm5leHQobXNnKSAvLyB0aGUgYWNjb3VudCBNVVNUIG1hdGNoIGBwdWJgIHByb3BlcnR5IHRoYXQgZXF1YWxzIHRoZSBJRCBvZiB0aGUgcHVibGljIGtleS5cbiAgICAgICAgcmV0dXJuIG5vKFwiQWNjb3VudCBub3Qgc2FtZSFcIilcbiAgICAgIH1cblxuICAgICAgaWYgKCh0bXAgPSB1c2VyLmlzKSAmJiB0bXAucHViICYmICFyYXdbJyonXSAmJiAhcmF3WycrJ10gJiYgKHB1YiA9PT0gdG1wLnB1YiB8fCAocHViICE9PSB0bXAucHViICYmICgobXNnLl8ubXNnIHx8IHt9KS5vcHQgfHwge30pLmNlcnQpKSl7XG4gICAgICAgIFNFQS5vcHQucGFjayhtc2cucHV0LCBwYWNrZWQgPT4ge1xuICAgICAgICAgIFNFQS5zaWduKHBhY2tlZCwgKHVzZXIuXykuc2VhLCBhc3luYyBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBpZiAodSA9PT0gZGF0YSkgcmV0dXJuIG5vKFNFQS5lcnIgfHwgJ1NpZ25hdHVyZSBmYWlsLicpXG4gICAgICAgICAgICBtc2cucHV0Wyc6J10gPSB7JzonOiB0bXAgPSBTRUEub3B0LnVucGFjayhkYXRhLm0pLCAnfic6IGRhdGEuc31cbiAgICAgICAgICAgIG1zZy5wdXRbJz0nXSA9IHRtcFxuICBcbiAgICAgICAgICAgIC8vIGlmIHdyaXRpbmcgdG8gb3duIGdyYXBoLCBqdXN0IGFsbG93IGl0XG4gICAgICAgICAgICBpZiAocHViID09PSB1c2VyLmlzLnB1Yikge1xuICAgICAgICAgICAgICBpZiAodG1wID0gbGlua19pcyh2YWwpKSAoYXQuc2VhLm93blt0bXBdID0gYXQuc2VhLm93blt0bXBdIHx8IHt9KVtwdWJdID0gMVxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeUFzeW5jKG1zZy5wdXRbJzonXSwgZnVuY3Rpb24oZXJyLHMpe1xuICAgICAgICAgICAgICAgIGlmKGVycil7IHJldHVybiBubyhlcnIgfHwgXCJTdHJpbmdpZnkgZXJyb3IuXCIpIH1cbiAgICAgICAgICAgICAgICBtc2cucHV0Wyc6J10gPSBzO1xuICAgICAgICAgICAgICAgIHJldHVybiBldmUudG8ubmV4dChtc2cpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICAvLyBpZiB3cml0aW5nIHRvIG90aGVyJ3MgZ3JhcGgsIGNoZWNrIGlmIGNlcnQgZXhpc3RzIHRoZW4gdHJ5IHRvIGluamVjdCBjZXJ0IGludG8gcHV0LCBhbHNvIGluamVjdCBzZWxmIHB1YiBzbyB0aGF0IGV2ZXJ5b25lIGNhbiB2ZXJpZnkgdGhlIHB1dFxuICAgICAgICAgICAgaWYgKHB1YiAhPT0gdXNlci5pcy5wdWIgJiYgKChtc2cuXy5tc2cgfHwge30pLm9wdCB8fCB7fSkuY2VydCkge1xuICAgICAgICAgICAgICBjb25zdCBjZXJ0ID0gYXdhaXQgUy5wYXJzZShtc2cuXy5tc2cub3B0LmNlcnQpXG4gICAgICAgICAgICAgIC8vIGV2ZW4gaWYgY2VydCBleGlzdHMsIHdlIG11c3QgdmVyaWZ5IGl0XG4gICAgICAgICAgICAgIGlmIChjZXJ0ICYmIGNlcnQubSAmJiBjZXJ0LnMpXG4gICAgICAgICAgICAgICAgdmVyaWZ5KGNlcnQsIHVzZXIuaXMucHViLCBfID0+IHtcbiAgICAgICAgICAgICAgICAgIG1zZy5wdXRbJzonXVsnKyddID0gY2VydCAvLyAnKycgaXMgYSBjZXJ0aWZpY2F0ZVxuICAgICAgICAgICAgICAgICAgbXNnLnB1dFsnOiddWycqJ10gPSB1c2VyLmlzLnB1YiAvLyAnKicgaXMgcHViIG9mIHRoZSB1c2VyIHdobyBwdXRzXG4gICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeUFzeW5jKG1zZy5wdXRbJzonXSwgZnVuY3Rpb24oZXJyLHMpe1xuICAgICAgICAgICAgICAgICAgICBpZihlcnIpeyByZXR1cm4gbm8oZXJyIHx8IFwiU3RyaW5naWZ5IGVycm9yLlwiKSB9XG4gICAgICAgICAgICAgICAgICAgIG1zZy5wdXRbJzonXSA9IHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmUudG8ubmV4dChtc2cpO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwge3JhdzogMX0pXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgU0VBLm9wdC5wYWNrKG1zZy5wdXQsIHBhY2tlZCA9PiB7XG4gICAgICAgIFNFQS52ZXJpZnkocGFja2VkLCByYXdbJyonXSB8fCBwdWIsIGZ1bmN0aW9uKGRhdGEpeyB2YXIgdG1wO1xuICAgICAgICAgIGRhdGEgPSBTRUEub3B0LnVucGFjayhkYXRhKTtcbiAgICAgICAgICBpZiAodSA9PT0gZGF0YSkgcmV0dXJuIG5vKFwiVW52ZXJpZmllZCBkYXRhLlwiKSAvLyBtYWtlIHN1cmUgdGhlIHNpZ25hdHVyZSBtYXRjaGVzIHRoZSBhY2NvdW50IGl0IGNsYWltcyB0byBiZSBvbi4gLy8gcmVqZWN0IGFueSB1cGRhdGVzIHRoYXQgYXJlIHNpZ25lZCB3aXRoIGEgbWlzbWF0Y2hlZCBhY2NvdW50LlxuICAgICAgICAgIGlmICgodG1wID0gbGlua19pcyhkYXRhKSkgJiYgcHViID09PSBTRUEub3B0LnB1Yih0bXApKSAoYXQuc2VhLm93blt0bXBdID0gYXQuc2VhLm93blt0bXBdIHx8IHt9KVtwdWJdID0gMVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGNoZWNrIGlmIGNlcnQgKCcrJykgYW5kIHB1dHRlcidzIHB1YiAoJyonKSBleGlzdFxuICAgICAgICAgIGlmIChyYXdbJysnXSAmJiByYXdbJysnXVsnbSddICYmIHJhd1snKyddWydzJ10gJiYgcmF3WycqJ10pXG4gICAgICAgICAgICAvLyBub3cgdmVyaWZ5IGNlcnRpZmljYXRlXG4gICAgICAgICAgICB2ZXJpZnkocmF3WycrJ10sIHJhd1snKiddLCBfID0+IHtcbiAgICAgICAgICAgICAgbXNnLnB1dFsnPSddID0gZGF0YTtcbiAgICAgICAgICAgICAgcmV0dXJuIGV2ZS50by5uZXh0KG1zZyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbXNnLnB1dFsnPSddID0gZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBldmUudG8ubmV4dChtc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfTtcbiAgICBjaGVjay5hbnkgPSBmdW5jdGlvbihldmUsIG1zZywgdmFsLCBrZXksIHNvdWwsIGF0LCBubywgdXNlcil7IHZhciB0bXAsIHB1YjtcbiAgICAgIGlmKGF0Lm9wdC5zZWN1cmUpeyByZXR1cm4gbm8oXCJTb3VsIG1pc3NpbmcgcHVibGljIGtleSBhdCAnXCIgKyBrZXkgKyBcIicuXCIpIH1cbiAgICAgIC8vIFRPRE86IEFzayBjb21tdW5pdHkgaWYgc2hvdWxkIGF1dG8tc2lnbiBub24gdXNlci1ncmFwaCBkYXRhLlxuICAgICAgYXQub24oJ3NlY3VyZScsIGZ1bmN0aW9uKG1zZyl7IHRoaXMub2ZmKCk7XG4gICAgICAgIGlmKCFhdC5vcHQuc2VjdXJlKXsgcmV0dXJuIGV2ZS50by5uZXh0KG1zZykgfVxuICAgICAgICBubyhcIkRhdGEgY2Fubm90IGJlIGNoYW5nZWQuXCIpO1xuICAgICAgfSkub24ub24oJ3NlY3VyZScsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkID0gR3VuLnZhbGlkLCBsaW5rX2lzID0gZnVuY3Rpb24oZCxsKXsgcmV0dXJuICdzdHJpbmcnID09IHR5cGVvZiAobCA9IHZhbGlkKGQpKSAmJiBsIH0sIHN0YXRlX2lmeSA9IChHdW4uc3RhdGV8fCcnKS5pZnk7XG5cbiAgICB2YXIgcHViY3V0ID0gL1teXFx3Xy1dLzsgLy8gYW55dGhpbmcgbm90IGFscGhhbnVtZXJpYyBvciBfIC1cbiAgICBTRUEub3B0LnB1YiA9IGZ1bmN0aW9uKHMpe1xuICAgICAgaWYoIXMpeyByZXR1cm4gfVxuICAgICAgcyA9IHMuc3BsaXQoJ34nKTtcbiAgICAgIGlmKCFzIHx8ICEocyA9IHNbMV0pKXsgcmV0dXJuIH1cbiAgICAgIHMgPSBzLnNwbGl0KHB1YmN1dCkuc2xpY2UoMCwyKTtcbiAgICAgIGlmKCFzIHx8IDIgIT0gcy5sZW5ndGgpeyByZXR1cm4gfVxuICAgICAgaWYoJ0AnID09PSAoc1swXXx8JycpWzBdKXsgcmV0dXJuIH1cbiAgICAgIHMgPSBzLnNsaWNlKDAsMikuam9pbignLicpO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIFNFQS5vcHQuc3RyaW5neSA9IGZ1bmN0aW9uKHQpe1xuICAgICAgLy8gVE9ETzogZW5jcnlwdCBldGMuIG5lZWQgdG8gY2hlY2sgc3RyaW5nIHByaW1pdGl2ZS4gTWFrZSBhcyBicmVha2luZyBjaGFuZ2UuXG4gICAgfVxuICAgIFNFQS5vcHQucGFjayA9IGZ1bmN0aW9uKGQsY2IsaywgbixzKXsgdmFyIHRtcCwgZjsgLy8gcGFjayBmb3IgdmVyaWZ5aW5nXG4gICAgICBpZihTRUEub3B0LmNoZWNrKGQpKXsgcmV0dXJuIGNiKGQpIH1cbiAgICAgIGlmKGQgJiYgZFsnIyddICYmIGRbJy4nXSAmJiBkWyc+J10peyB0bXAgPSBkWyc6J107IGYgPSAxIH1cbiAgICAgIEpTT04ucGFyc2VBc3luYyhmPyB0bXAgOiBkLCBmdW5jdGlvbihlcnIsIG1ldGEpe1xuICAgICAgICB2YXIgc2lnID0gKCh1ICE9PSAobWV0YXx8JycpWyc6J10pICYmIChtZXRhfHwnJylbJ34nXSk7IC8vIG9yIGp1c3QgfiBjaGVjaz9cbiAgICAgICAgaWYoIXNpZyl7IGNiKGQpOyByZXR1cm4gfVxuICAgICAgICBjYih7bTogeycjJzpzfHxkWycjJ10sJy4nOmt8fGRbJy4nXSwnOic6KG1ldGF8fCcnKVsnOiddLCc+JzpkWyc+J118fEd1bi5zdGF0ZS5pcyhuLCBrKX0sIHM6IHNpZ30pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBPID0gU0VBLm9wdDtcbiAgICBTRUEub3B0LnVucGFjayA9IGZ1bmN0aW9uKGQsIGssIG4peyB2YXIgdG1wO1xuICAgICAgaWYodSA9PT0gZCl7IHJldHVybiB9XG4gICAgICBpZihkICYmICh1ICE9PSAodG1wID0gZFsnOiddKSkpeyByZXR1cm4gdG1wIH1cbiAgICAgIGsgPSBrIHx8IE8uZmFsbF9rZXk7IGlmKCFuICYmIE8uZmFsbF92YWwpeyBuID0ge307IG5ba10gPSBPLmZhbGxfdmFsIH1cbiAgICAgIGlmKCFrIHx8ICFuKXsgcmV0dXJuIH1cbiAgICAgIGlmKGQgPT09IG5ba10peyByZXR1cm4gZCB9XG4gICAgICBpZighU0VBLm9wdC5jaGVjayhuW2tdKSl7IHJldHVybiBkIH1cbiAgICAgIHZhciBzb3VsID0gKG4gJiYgbi5fICYmIG4uX1snIyddKSB8fCBPLmZhbGxfc291bCwgcyA9IEd1bi5zdGF0ZS5pcyhuLCBrKSB8fCBPLmZhbGxfc3RhdGU7XG4gICAgICBpZihkICYmIDQgPT09IGQubGVuZ3RoICYmIHNvdWwgPT09IGRbMF0gJiYgayA9PT0gZFsxXSAmJiBmbChzKSA9PT0gZmwoZFszXSkpe1xuICAgICAgICByZXR1cm4gZFsyXTtcbiAgICAgIH1cbiAgICAgIGlmKHMgPCBTRUEub3B0LnNodWZmbGVfYXR0YWNrKXtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9XG4gICAgfVxuICAgIFNFQS5vcHQuc2h1ZmZsZV9hdHRhY2sgPSAxNTQ2MzI5NjAwMDAwOyAvLyBKYW4gMSwgMjAxOVxuICAgIHZhciBmbCA9IE1hdGguZmxvb3I7IC8vIFRPRE86IFN0aWxsIG5lZWQgdG8gZml4IGluY29uc2lzdGVudCBzdGF0ZSBpc3N1ZS5cbiAgICAvLyBUT0RPOiBQb3RlbnRpYWwgYnVnPyBJZiBwdWIvcHJpdiBrZXkgc3RhcnRzIHdpdGggYC1gPyBJREsgaG93IHBvc3NpYmxlLlxuXG4gIH0pKFVTRSwgJy4vaW5kZXgnKTtcbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gun/sea.js\n");

/***/ })

};
;